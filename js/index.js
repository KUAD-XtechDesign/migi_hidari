/*! For license information please see index.js.LICENSE.txt */
!function(t) {
    var e = {};
    function n(i) {
        if (e[i])
            return e[i].exports;
        var r = e[i] = {
            i: i,
            l: !1,
            exports: {}
        };
        return t[i].call(r.exports, r, r.exports, n),
        r.l = !0,
        r.exports
    }
    n.m = t,
    n.c = e,
    n.d = function(t, e, i) {
        n.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: i
        })
    }
    ,
    n.r = function(t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }
    ,
    n.t = function(t, e) {
        if (1 & e && (t = n(t)),
        8 & e)
            return t;
        if (4 & e && "object" == typeof t && t && t.__esModule)
            return t;
        var i = Object.create(null);
        if (n.r(i),
        Object.defineProperty(i, "default", {
            enumerable: !0,
            value: t
        }),
        2 & e && "string" != typeof t)
            for (var r in t)
                n.d(i, r, function(e) {
                    return t[e]
                }
                .bind(null, r));
        return i
    }
    ,
    n.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        }
        : function() {
            return t
        }
        ;
        return n.d(e, "a", e),
        e
    }
    ,
    n.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }
    ,
    n.p = "/",
    n(n.s = 1)
}({
    "+lvF": function(t, e, n) {
        t.exports = n("VTer")("native-function-to-string", Function.toString)
    },
    "+rLv": function(t, e, n) {
        var i = n("dyZX").document;
        t.exports = i && i.documentElement
    },
    "0/R4": function(t, e) {
        t.exports = function(t) {
            return "object" == typeof t ? null !== t : "function" == typeof t
        }
    },
    "0mN4": function(t, e, n) {
        "use strict";
        n("OGtf")("fixed", (function(t) {
            return function() {
                return t(this, "tt", "", "")
            }
        }
        ))
    },
    "0sh+": function(t, e, n) {
        var i = n("quPj")
          , r = n("vhPU");
        t.exports = function(t, e, n) {
            if (i(e))
                throw TypeError("String#" + n + " doesn't accept regex!");
            return String(r(t))
        }
    },
    1: function(t, e, n) {
        t.exports = n("zFNl")
    },
    "1MBn": function(t, e, n) {
        var i = n("DVgA")
          , r = n("JiEa")
          , s = n("UqcF");
        t.exports = function(t) {
            var e = i(t)
              , n = r.f;
            if (n)
                for (var a, o = n(t), l = s.f, c = 0; o.length > c; )
                    l.call(t, a = o[c++]) && e.push(a);
            return e
        }
    },
    "1TsA": function(t, e) {
        t.exports = function(t, e) {
            return {
                value: e,
                done: !!t
            }
        }
    },
    "2OiF": function(t, e) {
        t.exports = function(t) {
            if ("function" != typeof t)
                throw TypeError(t + " is not a function!");
            return t
        }
    },
    "4R4u": function(t, e) {
        t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
    },
    "69bn": function(t, e, n) {
        var i = n("y3w9")
          , r = n("2OiF")
          , s = n("K0xU")("species");
        t.exports = function(t, e) {
            var n, a = i(t).constructor;
            return void 0 === a || null == (n = i(a)[s]) ? e : r(n)
        }
    },
    "8a7r": function(t, e, n) {
        "use strict";
        var i = n("hswa")
          , r = n("RjD/");
        t.exports = function(t, e, n) {
            e in t ? i.f(t, e, r(0, n)) : t[e] = n
        }
    },
    A5AN: function(t, e, n) {
        "use strict";
        var i = n("AvRE")(!0);
        t.exports = function(t, e, n) {
            return e + (n ? i(t, e).length : 1)
        }
    },
    Afnz: function(t, e, n) {
        "use strict";
        var i = n("LQAc")
          , r = n("XKFU")
          , s = n("KroJ")
          , a = n("Mukb")
          , o = n("hPIQ")
          , l = n("QaDb")
          , c = n("fyDq")
          , h = n("OP3Y")
          , u = n("K0xU")("iterator")
          , d = !([].keys && "next"in [].keys())
          , p = function() {
            return this
        };
        t.exports = function(t, e, n, f, m, g, v) {
            l(n, e, f);
            var y, x, _, w = function(t) {
                if (!d && t in T)
                    return T[t];
                switch (t) {
                case "keys":
                case "values":
                    return function() {
                        return new n(this,t)
                    }
                }
                return function() {
                    return new n(this,t)
                }
            }, b = e + " Iterator", M = "values" == m, S = !1, T = t.prototype, E = T[u] || T["@@iterator"] || m && T[m], L = E || w(m), A = m ? M ? w("entries") : L : void 0, C = "Array" == e && T.entries || E;
            if (C && (_ = h(C.call(new t))) !== Object.prototype && _.next && (c(_, b, !0),
            i || "function" == typeof _[u] || a(_, u, p)),
            M && E && "values" !== E.name && (S = !0,
            L = function() {
                return E.call(this)
            }
            ),
            i && !v || !d && !S && T[u] || a(T, u, L),
            o[e] = L,
            o[b] = p,
            m)
                if (y = {
                    values: M ? L : w("values"),
                    keys: g ? L : w("keys"),
                    entries: A
                },
                v)
                    for (x in y)
                        x in T || s(T, x, y[x]);
                else
                    r(r.P + r.F * (d || S), e, y);
            return y
        }
    },
    AvRE: function(t, e, n) {
        var i = n("RYi7")
          , r = n("vhPU");
        t.exports = function(t) {
            return function(e, n) {
                var s, a, o = String(r(e)), l = i(n), c = o.length;
                return l < 0 || l >= c ? t ? "" : void 0 : (s = o.charCodeAt(l)) < 55296 || s > 56319 || l + 1 === c || (a = o.charCodeAt(l + 1)) < 56320 || a > 57343 ? t ? o.charAt(l) : s : t ? o.slice(l, l + 2) : a - 56320 + (s - 55296 << 10) + 65536
            }
        }
    },
    Btvt: function(t, e, n) {
        "use strict";
        var i = n("I8a+")
          , r = {};
        r[n("K0xU")("toStringTag")] = "z",
        r + "" != "[object z]" && n("KroJ")(Object.prototype, "toString", (function() {
            return "[object " + i(this) + "]"
        }
        ), !0)
    },
    "C/va": function(t, e, n) {
        "use strict";
        var i = n("y3w9");
        t.exports = function() {
            var t = i(this)
              , e = "";
            return t.global && (e += "g"),
            t.ignoreCase && (e += "i"),
            t.multiline && (e += "m"),
            t.unicode && (e += "u"),
            t.sticky && (e += "y"),
            e
        }
    },
    CUlp: function(t, e, n) {
        var i, r;
        "undefined" != typeof window && window,
        void 0 === (r = "function" == typeof (i = function() {
            "use strict";
            function t() {}
            var e = t.prototype;
            return e.on = function(t, e) {
                if (t && e) {
                    var n = this._events = this._events || {}
                      , i = n[t] = n[t] || [];
                    return -1 == i.indexOf(e) && i.push(e),
                    this
                }
            }
            ,
            e.once = function(t, e) {
                if (t && e) {
                    this.on(t, e);
                    var n = this._onceEvents = this._onceEvents || {};
                    return (n[t] = n[t] || {})[e] = !0,
                    this
                }
            }
            ,
            e.off = function(t, e) {
                var n = this._events && this._events[t];
                if (n && n.length) {
                    var i = n.indexOf(e);
                    return -1 != i && n.splice(i, 1),
                    this
                }
            }
            ,
            e.emitEvent = function(t, e) {
                var n = this._events && this._events[t];
                if (n && n.length) {
                    n = n.slice(0),
                    e = e || [];
                    for (var i = this._onceEvents && this._onceEvents[t], r = 0; r < n.length; r++) {
                        var s = n[r];
                        i && i[s] && (this.off(t, s),
                        delete i[s]),
                        s.apply(this, e)
                    }
                    return this
                }
            }
            ,
            e.allOff = function() {
                delete this._events,
                delete this._onceEvents
            }
            ,
            t
        }
        ) ? i.call(e, n, e, t) : i) || (t.exports = r)
    },
    DVgA: function(t, e, n) {
        var i = n("zhAb")
          , r = n("4R4u");
        t.exports = Object.keys || function(t) {
            return i(t, r)
        }
    },
    EWmC: function(t, e, n) {
        var i = n("LZWt");
        t.exports = Array.isArray || function(t) {
            return "Array" == i(t)
        }
    },
    EemH: function(t, e, n) {
        var i = n("UqcF")
          , r = n("RjD/")
          , s = n("aCFj")
          , a = n("apmT")
          , o = n("aagx")
          , l = n("xpql")
          , c = Object.getOwnPropertyDescriptor;
        e.f = n("nh4g") ? c : function(t, e) {
            if (t = s(t),
            e = a(e, !0),
            l)
                try {
                    return c(t, e)
                } catch (t) {}
            if (o(t, e))
                return r(!i.f.call(t, e), t[e])
        }
    },
    FJW5: function(t, e, n) {
        var i = n("hswa")
          , r = n("y3w9")
          , s = n("DVgA");
        t.exports = n("nh4g") ? Object.defineProperties : function(t, e) {
            r(t);
            for (var n, a = s(e), o = a.length, l = 0; o > l; )
                i.f(t, n = a[l++], e[n]);
            return t
        }
    },
    H6hf: function(t, e, n) {
        var i = n("y3w9");
        t.exports = function(t, e, n, r) {
            try {
                return r ? e(i(n)[0], n[1]) : e(n)
            } catch (e) {
                var s = t.return;
                throw void 0 !== s && i(s.call(t)),
                e
            }
        }
    },
    HEwt: function(t, e, n) {
        "use strict";
        var i = n("m0Pp")
          , r = n("XKFU")
          , s = n("S/j/")
          , a = n("H6hf")
          , o = n("M6Qj")
          , l = n("ne8i")
          , c = n("8a7r")
          , h = n("J+6e");
        r(r.S + r.F * !n("XMVh")((function(t) {
            Array.from(t)
        }
        )), "Array", {
            from: function(t) {
                var e, n, r, u, d = s(t), p = "function" == typeof this ? this : Array, f = arguments.length, m = f > 1 ? arguments[1] : void 0, g = void 0 !== m, v = 0, y = h(d);
                if (g && (m = i(m, f > 2 ? arguments[2] : void 0, 2)),
                null == y || p == Array && o(y))
                    for (n = new p(e = l(d.length)); e > v; v++)
                        c(n, v, g ? m(d[v], v) : d[v]);
                else
                    for (u = y.call(d),
                    n = new p; !(r = u.next()).done; v++)
                        c(n, v, g ? a(u, m, [r.value, v], !0) : r.value);
                return n.length = v,
                n
            }
        })
    },
    Haw6: function(t, e, n) {
        "use strict";
        n.d(e, "a", (function() {
            return qt
        }
        ));
        var i, r, s, a, o, l, c, h, u, d, p, f, m, g, v, y, x, _, w, b, M, S, T, E, L, A, C, P = 1, R = [], I = [], D = Date.now, N = D(), O = 0, z = 1, B = function(t) {
            return t
        }, k = function() {
            return "undefined" != typeof window
        }, F = function() {
            return i || k() && (i = window.gsap) && i.registerPlugin && i
        }, H = function(t) {
            return !!~c.indexOf(t)
        }, U = function(t, e) {
            return ~R.indexOf(t) && R[R.indexOf(t) + 1][e]
        }, G = function(t, e) {
            var n = e.s
              , i = e.sc
              , r = I.indexOf(t)
              , s = i === nt.sc ? 1 : 2;
            return !~r && (r = I.push(t) - 1),
            I[r + s] || (I[r + s] = U(t, n) || (H(t) ? i : function(e) {
                return arguments.length ? t[n] = e : t[n]
            }
            ))
        }, V = function(t) {
            return U(t, "getBoundingClientRect") || (H(t) ? function() {
                return Ut.width = s.innerWidth,
                Ut.height = s.innerHeight,
                Ut
            }
            : function() {
                return st(t)
            }
            )
        }, W = function(t, e) {
            var n = e.s
              , i = e.d2
              , r = e.d
              , a = e.a;
            return (n = "scroll" + i) && (a = U(t, n)) ? a() - V(t)()[r] : H(t) ? Math.max(o[n], l[n]) - (s["inner" + i] || o["client" + i] || l["client" + i]) : t[n] - t["offset" + i]
        }, j = function(t, e) {
            for (var n = 0; n < M.length; n += 3)
                (!e || ~e.indexOf(M[n + 1])) && t(M[n], M[n + 1], M[n + 2])
        }, q = function(t) {
            return "string" == typeof t
        }, X = function(t) {
            return "function" == typeof t
        }, Y = function(t) {
            return "number" == typeof t
        }, Z = function(t) {
            return "object" == typeof t
        }, J = function(t) {
            return X(t) && t()
        }, $ = function(t, e) {
            return function() {
                var n = J(t)
                  , i = J(e);
                return function() {
                    J(n),
                    J(i)
                }
            }
        }, K = Math.abs, Q = "padding", tt = "px", et = {
            s: "scrollLeft",
            p: "left",
            p2: "Left",
            os: "right",
            os2: "Right",
            d: "width",
            d2: "Width",
            a: "x",
            sc: function(t) {
                return arguments.length ? s.scrollTo(t, nt.sc()) : s.pageXOffset || a.scrollLeft || o.scrollLeft || l.scrollLeft || 0
            }
        }, nt = {
            s: "scrollTop",
            p: "top",
            p2: "Top",
            os: "bottom",
            os2: "Bottom",
            d: "height",
            d2: "Height",
            a: "y",
            op: et,
            sc: function(t) {
                return arguments.length ? s.scrollTo(et.sc(), t) : s.pageYOffset || a.scrollTop || o.scrollTop || l.scrollTop || 0
            }
        }, it = function(t) {
            return s.getComputedStyle(t)
        }, rt = function(t, e) {
            for (var n in e)
                n in t || (t[n] = e[n]);
            return t
        }, st = function(t, e) {
            var n = e && "matrix(1, 0, 0, 1, 0, 0)" !== it(t)[x] && i.to(t, {
                x: 0,
                y: 0,
                xPercent: 0,
                yPercent: 0,
                rotation: 0,
                rotationX: 0,
                rotationY: 0,
                scale: 1,
                skewX: 0,
                skewY: 0
            }).progress(1)
              , r = t.getBoundingClientRect();
            return n && n.progress(0).kill(),
            r
        }, at = function(t, e) {
            var n = e.d2;
            return t["offset" + n] || t["client" + n] || 0
        }, ot = function(t) {
            var e, n = [], i = t.labels, r = t.duration();
            for (e in i)
                n.push(i[e] / r);
            return n
        }, lt = function(t, e, n, i) {
            return n.split(",").forEach((function(n) {
                return t(e, n, i)
            }
            ))
        }, ct = function(t, e, n) {
            return t.addEventListener(e, n, {
                passive: !0
            })
        }, ht = function(t, e, n) {
            return t.removeEventListener(e, n)
        }, ut = {
            startColor: "green",
            endColor: "red",
            indent: 0,
            fontSize: "16px",
            fontWeight: "normal"
        }, dt = {
            toggleActions: "play",
            anticipatePin: 0
        }, pt = {
            top: 0,
            left: 0,
            center: .5,
            bottom: 1,
            right: 1
        }, ft = function(t, e) {
            if (q(t)) {
                var n = t.indexOf("=")
                  , i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0;
                ~n && (t.indexOf("%") > n && (i *= e / 100),
                t = t.substr(0, n - 1)),
                t = i + (t in pt ? pt[t] * e : ~t.indexOf("%") ? parseFloat(t) * e / 100 : parseFloat(t) || 0)
            }
            return t
        }, mt = function(t, e, n, i, r, s, o) {
            var c = r.startColor
              , h = r.endColor
              , u = r.fontSize
              , d = r.indent
              , p = r.fontWeight
              , f = a.createElement("div")
              , m = H(n) || "fixed" === U(n, "pinType")
              , g = -1 !== t.indexOf("scroller")
              , v = m ? l : n
              , y = -1 !== t.indexOf("start")
              , x = y ? c : h
              , _ = "border-color:" + x + ";font-size:" + u + ";color:" + x + ";font-weight:" + p + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
            return _ += "position:" + (g && m ? "fixed;" : "absolute;"),
            (g || !m) && (_ += (i === nt ? "right" : "bottom") + ":" + (s + parseFloat(d)) + "px;"),
            o && (_ += "box-sizing:border-box;text-align:left;width:" + o.offsetWidth + "px;"),
            f._isStart = y,
            f.setAttribute("class", "gsap-marker-" + t),
            f.style.cssText = _,
            f.innerText = e || 0 === e ? t + "-" + e : t,
            v.children[0] ? v.insertBefore(f, v.children[0]) : v.appendChild(f),
            f._offset = f["offset" + i.op.d2],
            gt(f, 0, i, y),
            f
        }, gt = function(t, e, n, r) {
            var s = {
                display: "block"
            }
              , a = n[r ? "os2" : "p2"]
              , o = n[r ? "p2" : "os2"];
            t._isFlipped = r,
            s[n.a + "Percent"] = r ? -100 : 0,
            s[n.a] = r ? "1px" : 0,
            s["border" + a + "Width"] = 1,
            s["border" + o + "Width"] = 0,
            s[n.p] = e + "px",
            i.set(t, s)
        }, vt = [], yt = {}, xt = function() {
            return d || (d = u(Nt))
        }, _t = function() {
            d || (d = u(Nt),
            O || Lt("scrollStart"),
            O = D())
        }, wt = function() {
            return !v && !E && !a.fullscreenElement && h.restart(!0)
        }, bt = {}, Mt = [], St = [], Tt = function(t) {
            var e, n = i.ticker.frame, a = [], o = 0;
            if (C !== n || P) {
                for (Pt(); o < St.length; o += 4)
                    (e = s.matchMedia(St[o]).matches) !== St[o + 3] && (St[o + 3] = e,
                    e ? a.push(o) : Pt(1, St[o]) || X(St[o + 2]) && St[o + 2]());
                for (Ct(),
                o = 0; o < a.length; o++)
                    e = a[o],
                    A = St[e],
                    St[e + 2] = St[e + 1](t);
                A = 0,
                r && Rt(0, 1),
                C = n,
                Lt("matchMedia")
            }
        }, Et = function t() {
            return ht(qt, "scrollEnd", t) || Rt(!0)
        }, Lt = function(t) {
            return bt[t] && bt[t].map((function(t) {
                return t()
            }
            )) || Mt
        }, At = [], Ct = function(t) {
            for (var e = 0; e < At.length; e += 4)
                t && At[e + 3] !== t || (At[e].style.cssText = At[e + 1],
                At[e + 2].uncache = 1)
        }, Pt = function(t, e) {
            var n;
            for (_ = 0; _ < vt.length; _++)
                n = vt[_],
                e && n.media !== e || (t ? n.kill(1) : (n.scroll.rec || (n.scroll.rec = n.scroll()),
                n.revert()));
            Ct(e),
            e || Lt("revert")
        }, Rt = function(t, e) {
            if (!O || t) {
                var n = Lt("refreshInit");
                for (S && qt.sort(),
                e || Pt(),
                _ = 0; _ < vt.length; _++)
                    vt[_].refresh();
                for (n.forEach((function(t) {
                    return t && t.render && t.render(-1)
                }
                )),
                _ = vt.length; _--; )
                    vt[_].scroll.rec = 0;
                h.pause(),
                Lt("refresh")
            } else
                ct(qt, "scrollEnd", Et)
        }, It = 0, Dt = 1, Nt = function() {
            var t = vt.length
              , e = D()
              , n = e - N >= 50
              , i = t && vt[0].scroll();
            if (Dt = It > i ? -1 : 1,
            It = i,
            n && (O && !y && e - O > 200 && (O = 0,
            Lt("scrollEnd")),
            m = N,
            N = e),
            Dt < 0) {
                for (_ = t; _--; )
                    vt[_] && vt[_].update(0, n);
                Dt = 1
            } else
                for (_ = 0; _ < t; _++)
                    vt[_] && vt[_].update(0, n);
            d = 0
        }, Ot = ["left", "top", "bottom", "right", "marginBottom", "marginRight", "marginTop", "marginLeft", "display", "flexShrink", "float", "zIndex"], zt = Ot.concat(["width", "height", "boxSizing", "maxWidth", "maxHeight", "position", "margin", Q, Q + "Top", Q + "Right", Q + "Bottom", Q + "Left"]), Bt = function(t, e, n, i) {
            if (t.parentNode !== e) {
                for (var r, s = Ot.length, a = e.style, o = t.style; s--; )
                    a[r = Ot[s]] = n[r];
                a.position = "absolute" === n.position ? "absolute" : "relative",
                "inline" === n.display && (a.display = "inline-block"),
                o.bottom = o.right = "auto",
                a.overflow = "visible",
                a.boxSizing = "border-box",
                a.width = at(t, et) + tt,
                a.height = at(t, nt) + tt,
                a[Q] = o.margin = o.top = o.left = "0",
                Ft(i),
                o.width = o.maxWidth = n.width,
                o.height = o.maxHeight = n.height,
                o[Q] = n[Q],
                t.parentNode.insertBefore(e, t),
                e.appendChild(t)
            }
        }, kt = /([A-Z])/g, Ft = function(t) {
            if (t) {
                var e, n, r = t.t.style, s = t.length, a = 0;
                for ((t.t._gsap || i.core.getCache(t.t)).uncache = 1; a < s; a += 2)
                    n = t[a + 1],
                    e = t[a],
                    n ? r[e] = n : r[e] && r.removeProperty(e.replace(kt, "-$1").toLowerCase())
            }
        }, Ht = function(t) {
            for (var e = zt.length, n = t.style, i = [], r = 0; r < e; r++)
                i.push(zt[r], n[zt[r]]);
            return i.t = t,
            i
        }, Ut = {
            left: 0,
            top: 0
        }, Gt = function(t, e, n, i, r, s, a, c, h, u, d, f) {
            if (X(t) && (t = t(c)),
            q(t) && "max" === t.substr(0, 3) && (t = f + ("=" === t.charAt(4) ? ft("0" + t.substr(3), n) : 0)),
            Y(t))
                a && gt(a, n, i, !0);
            else {
                X(e) && (e = e(c));
                var m, g, v, y = p(e)[0] || l, x = st(y) || {}, _ = t.split(" ");
                x && (x.left || x.top) || "none" !== it(y).display || (v = y.style.display,
                y.style.display = "block",
                x = st(y),
                v ? y.style.display = v : y.style.removeProperty("display")),
                m = ft(_[0], x[i.d]),
                g = ft(_[1] || "0", n),
                t = x[i.p] - h[i.p] - u + m + r - g,
                a && gt(a, g, i, n - g < 20 || a._isStart && g > 20),
                n -= n - g
            }
            if (s) {
                var w = t + n
                  , b = s._isStart;
                f = "scroll" + i.d2,
                gt(s, w, i, b && w > 20 || !b && (d ? Math.max(l[f], o[f]) : s.parentNode[f]) <= w + 1),
                d && (h = st(a),
                d && (s.style[i.op.p] = h[i.op.p] - i.op.m - s._offset + tt))
            }
            return Math.round(t)
        }, Vt = /(?:webkit|moz|length|cssText|inset)/i, Wt = function(t, e, n, r) {
            if (t.parentNode !== e) {
                var s, a, o = t.style;
                if (e === l) {
                    for (s in t._stOrig = o.cssText,
                    a = it(t))
                        +s || Vt.test(s) || !a[s] || "string" != typeof o[s] || "0" === s || (o[s] = a[s]);
                    o.top = n,
                    o.left = r
                } else
                    o.cssText = t._stOrig;
                i.core.getCache(t).uncache = 1,
                e.appendChild(t)
            }
        }, jt = function(t, e) {
            var n, r, s = G(t, e), a = "_scroll" + e.p2, o = function e(o, l, c, h, u) {
                var d = e.tween
                  , p = l.onComplete
                  , f = {};
                return d && d.kill(),
                n = Math.round(c),
                l[a] = o,
                l.modifiers = f,
                f[a] = function(t) {
                    return (t = Math.round(s())) !== n && t !== r && Math.abs(t - n) > 2 ? (d.kill(),
                    e.tween = 0) : t = c + h * d.ratio + u * d.ratio * d.ratio,
                    r = n,
                    n = Math.round(t)
                }
                ,
                l.onComplete = function() {
                    e.tween = 0,
                    p && p.call(d)
                }
                ,
                d = e.tween = i.to(t, l)
            };
            return t[a] = s,
            t.addEventListener("mousewheel", (function() {
                return o.tween && o.tween.kill() && (o.tween = 0)
            }
            )),
            o
        };
        et.op = nt;
        var qt = function() {
            function t(e, n) {
                r || t.register(i) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
                this.init(e, n)
            }
            return t.prototype.init = function(e, n) {
                if (this.progress = this.start = 0,
                this.vars && this.kill(1),
                z) {
                    var r, c, h, u, d, g, x, w, b, M, E, C, I, N, k, F, j, J, $, lt, pt, gt, xt, bt, Mt, St, Tt, Lt, At, Ct, Pt, Rt, It, Nt, Ot, zt, kt, Vt, qt, Xt = (e = rt(q(e) || Y(e) || e.nodeType ? {
                        trigger: e
                    } : e, dt)).horizontal ? et : nt, Yt = e, Zt = Yt.onUpdate, Jt = Yt.toggleClass, $t = Yt.id, Kt = Yt.onToggle, Qt = Yt.onRefresh, te = Yt.scrub, ee = Yt.trigger, ne = Yt.pin, ie = Yt.pinSpacing, re = Yt.invalidateOnRefresh, se = Yt.anticipatePin, ae = Yt.onScrubComplete, oe = Yt.onSnapComplete, le = Yt.once, ce = Yt.snap, he = Yt.pinReparent, ue = !te && 0 !== te, de = p(e.scroller || s)[0], pe = i.core.getCache(de), fe = H(de), me = "pinType"in e ? "fixed" === e.pinType : fe || "fixed" === U(de, "pinType"), ge = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack], ve = ue && e.toggleActions.split(" "), ye = "markers"in e ? e.markers : dt.markers, xe = fe ? 0 : parseFloat(it(de)["border" + Xt.p2 + "Width"]) || 0, _e = this, we = e.onRefreshInit && function() {
                        return e.onRefreshInit(_e)
                    }
                    , be = function(t, e, n) {
                        var i = n.d
                          , r = n.d2
                          , a = n.a;
                        return (a = U(t, "getBoundingClientRect")) ? function() {
                            return a()[i]
                        }
                        : function() {
                            return (e ? s["inner" + r] : t["client" + r]) || 0
                        }
                    }(de, fe, Xt), Me = function(t, e) {
                        return !e || ~R.indexOf(t) ? V(t) : function() {
                            return Ut
                        }
                    }(de, fe);
                    _e.media = A,
                    se *= 45,
                    vt.push(_e),
                    _e.scroller = de,
                    _e.scroll = G(de, Xt),
                    d = _e.scroll(),
                    _e.vars = e,
                    n = n || e.animation,
                    "refreshPriority"in e && (S = 1),
                    pe.tweenScroll = pe.tweenScroll || {
                        top: jt(de, nt),
                        left: jt(de, et)
                    },
                    _e.tweenTo = r = pe.tweenScroll[Xt.p],
                    n && (n.vars.lazy = !1,
                    n._initted || !1 !== n.vars.immediateRender && !1 !== e.immediateRender && n.render(0, !0, !0),
                    _e.animation = n.pause(),
                    n.scrollTrigger = _e,
                    (Rt = Y(te) && te) && (Pt = i.to(n, {
                        ease: "power3",
                        duration: Rt,
                        onComplete: function() {
                            return ae && ae(_e)
                        }
                    })),
                    At = 0,
                    $t || ($t = n.vars.id)),
                    ce && (Z(ce) || (ce = {
                        snapTo: ce
                    }),
                    "scrollBehavior"in l.style && i.set(fe ? [l, o] : de, {
                        scrollBehavior: "auto"
                    }),
                    h = X(ce.snapTo) ? ce.snapTo : "labels" === ce.snapTo ? function(t) {
                        return function(e) {
                            return i.utils.snap(ot(t), e)
                        }
                    }(n) : "labelsDirectional" === ce.snapTo ? (Vt = n,
                    function(t, e) {
                        var n, i = ot(Vt);
                        if (i.sort((function(t, e) {
                            return t - e
                        }
                        )),
                        e.direction > 0) {
                            for (n = 0; n < i.length; n++)
                                if (i[n] >= t)
                                    return i[n];
                            return i.pop()
                        }
                        for (n = i.length; n--; )
                            if (i[n] <= t)
                                return i[n];
                        return i[0]
                    }
                    ) : i.utils.snap(ce.snapTo),
                    It = ce.duration || {
                        min: .1,
                        max: 2
                    },
                    It = Z(It) ? f(It.min, It.max) : f(It, It),
                    Nt = i.delayedCall(ce.delay || Rt / 2 || .1, (function() {
                        if (Math.abs(_e.getVelocity()) < 10 && !y) {
                            var t = n && !ue ? n.totalProgress() : _e.progress
                              , e = (t - Ct) / (D() - m) * 1e3 || 0
                              , i = K(e / 2) * e / .185
                              , s = t + i
                              , a = f(0, 1, h(s, _e))
                              , o = _e.scroll()
                              , l = Math.round(x + a * N)
                              , c = r.tween;
                            if (o <= w && o >= x && l !== o) {
                                if (c && !c._initted && c.data <= Math.abs(l - o))
                                    return;
                                r(l, {
                                    duration: It(K(.185 * Math.max(K(s - t), K(a - t)) / e / .05 || 0)),
                                    ease: ce.ease || "power3",
                                    data: Math.abs(l - o),
                                    onComplete: function() {
                                        At = Ct = n && !ue ? n.totalProgress() : _e.progress,
                                        oe && oe(_e)
                                    }
                                }, o, i * N, l - o - i * N)
                            }
                        } else
                            _e.isActive && Nt.restart(!0)
                    }
                    )).pause()),
                    $t && (yt[$t] = _e),
                    ee = _e.trigger = p(ee || ne)[0],
                    ne = !0 === ne ? ee : p(ne)[0],
                    q(Jt) && (Jt = {
                        targets: ee,
                        className: Jt
                    }),
                    ne && (!1 === ie || "margin" === ie || (ie = !(!ie && "flex" === it(ne.parentNode).display) && Q),
                    _e.pin = ne,
                    !1 !== e.force3D && i.set(ne, {
                        force3D: !0
                    }),
                    (c = i.core.getCache(ne)).spacer ? k = c.pinState : (c.spacer = J = a.createElement("div"),
                    J.setAttribute("class", "pin-spacer" + ($t ? " pin-spacer-" + $t : "")),
                    c.pinState = k = Ht(ne)),
                    _e.spacer = J = c.spacer,
                    Lt = it(ne),
                    bt = Lt[ie + Xt.os2],
                    lt = i.getProperty(ne),
                    pt = i.quickSetter(ne, Xt.a, tt),
                    Bt(ne, J, Lt),
                    j = Ht(ne)),
                    ye && (I = Z(ye) ? rt(ye, ut) : ut,
                    E = mt("scroller-start", $t, de, Xt, I, 0),
                    C = mt("scroller-end", $t, de, Xt, I, 0, E),
                    $ = E["offset" + Xt.op.d2],
                    b = mt("start", $t, de, Xt, I, $),
                    M = mt("end", $t, de, Xt, I, $),
                    me || ((qt = fe ? l : de).style.position = "absolute" === it(qt).position ? "absolute" : "relative",
                    i.set([E, C], {
                        force3D: !0
                    }),
                    St = i.quickSetter(E, Xt.a, tt),
                    Tt = i.quickSetter(C, Xt.a, tt))),
                    _e.revert = function(t) {
                        var e = !1 !== t || !_e.enabled
                          , i = v;
                        e !== u && (e && (zt = Math.max(_e.scroll(), _e.scroll.rec || 0),
                        Ot = _e.progress,
                        kt = n && n.progress()),
                        b && [b, M, E, C].forEach((function(t) {
                            return t.style.display = e ? "none" : "block"
                        }
                        )),
                        e && (v = 1),
                        _e.update(e),
                        v = i,
                        ne && (e ? function(t, e, n) {
                            if (Ft(n),
                            t.parentNode === e) {
                                var i = e.parentNode;
                                i && (i.insertBefore(t, e),
                                i.removeChild(e))
                            }
                        }(ne, J, k) : (!he || !_e.isActive) && Bt(ne, J, it(ne), Mt)),
                        u = e)
                    }
                    ,
                    _e.refresh = function(r) {
                        if (!v && _e.enabled)
                            if (ne && r && O)
                                ct(t, "scrollEnd", Et);
                            else {
                                v = 1,
                                Pt && Pt.pause(),
                                re && n && n.progress(0).invalidate(),
                                u || _e.revert();
                                for (var s, a, o, c, h, p, f, m, y, _ = be(), S = Me(), L = W(de, Xt), A = 0, P = 0, R = e.end, I = e.endTrigger || ee, D = e.start || (0 !== e.start && ee ? ne ? "0 0" : "0 100%" : 0), z = ee && Math.max(0, vt.indexOf(_e)) || 0, B = z; B--; )
                                    (f = vt[B].pin) && (f === ee || f === ne) && vt[B].revert();
                                for (x = Gt(D, ee, _, Xt, _e.scroll(), b, E, _e, S, xe, me, L) || (ne ? -.001 : 0),
                                X(R) && (R = R(_e)),
                                q(R) && !R.indexOf("+=") && (~R.indexOf(" ") ? R = (q(D) ? D.split(" ")[0] : "") + R : (A = ft(R.substr(2), _),
                                R = q(D) ? D : x + A,
                                I = ee)),
                                w = Math.max(x, Gt(R || (I ? "100% 0" : L), I, _, Xt, _e.scroll() + A, M, C, _e, S, xe, me, L)) || -.001,
                                N = w - x || (x -= .01) && .001,
                                A = 0,
                                B = z; B--; )
                                    (f = (p = vt[B]).pin) && p.start - p._pinPush < x && (s = p.end - p.start,
                                    f === ee && (A += s),
                                    f === ne && (P += s));
                                if (x += A,
                                w += A,
                                _e._pinPush = P,
                                b && A && ((s = {})[Xt.a] = "+=" + A,
                                i.set([b, M], s)),
                                ne)
                                    s = it(ne),
                                    c = Xt === nt,
                                    o = _e.scroll(),
                                    gt = parseFloat(lt(Xt.a)) + P,
                                    !L && w > 1 && ((fe ? l : de).style["overflow-" + Xt.a] = "scroll"),
                                    Bt(ne, J, s),
                                    j = Ht(ne),
                                    a = st(ne, !0),
                                    m = me && G(de, c ? et : nt)(),
                                    ie && ((Mt = [ie + Xt.os2, N + P + tt]).t = J,
                                    (B = ie === Q ? at(ne, Xt) + N + P : 0) && Mt.push(Xt.d, B + tt),
                                    Ft(Mt),
                                    me && _e.scroll(zt)),
                                    me && ((h = {
                                        top: a.top + (c ? o - x : m) + tt,
                                        left: a.left + (c ? m : o - x) + tt,
                                        boxSizing: "border-box",
                                        position: "fixed"
                                    }).width = h.maxWidth = Math.ceil(a.width) + tt,
                                    h.height = h.maxHeight = Math.ceil(a.height) + tt,
                                    h.margin = h.marginTop = h.marginRight = h.marginBottom = h.marginLeft = "0",
                                    h[Q] = s[Q],
                                    h[Q + "Top"] = s[Q + "Top"],
                                    h[Q + "Right"] = s[Q + "Right"],
                                    h[Q + "Bottom"] = s[Q + "Bottom"],
                                    h[Q + "Left"] = s[Q + "Left"],
                                    F = function(t, e, n) {
                                        for (var i, r = [], s = t.length, a = n ? 8 : 0; a < s; a += 2)
                                            i = t[a],
                                            r.push(i, i in e ? e[i] : t[a + 1]);
                                        return r.t = t.t,
                                        r
                                    }(k, h, he)),
                                    n ? (y = n._initted,
                                    T(1),
                                    n.progress(1, !0),
                                    xt = lt(Xt.a) - gt + N + P,
                                    N !== xt && F.splice(F.length - 2, 2),
                                    n.progress(0, !0),
                                    y || n.invalidate(),
                                    T(0)) : xt = N;
                                else if (ee && _e.scroll())
                                    for (a = ee.parentNode; a && a !== l; )
                                        a._pinOffset && (x -= a._pinOffset,
                                        w -= a._pinOffset),
                                        a = a.parentNode;
                                for (B = 0; B < z; B++)
                                    (p = vt[B].pin) && (p === ee || p === ne) && vt[B].revert(!1);
                                _e.start = x,
                                _e.end = w,
                                (d = g = _e.scroll()) < zt && _e.scroll(zt),
                                _e.revert(!1),
                                v = 0,
                                n && ue && n._initted && n.progress(kt, !0).render(n.time(), !0, !0),
                                Ot !== _e.progress && (Pt && n.totalProgress(Ot, !0),
                                _e.progress = Ot,
                                _e.update()),
                                ne && ie && (J._pinOffset = Math.round(_e.progress * xt)),
                                Qt && Qt(_e)
                            }
                    }
                    ,
                    _e.getVelocity = function() {
                        return (_e.scroll() - g) / (D() - m) * 1e3 || 0
                    }
                    ,
                    _e.update = function(t, e) {
                        var i, s, a, o, c, h = _e.scroll(), u = t ? 0 : (h - x) / N, f = u < 0 ? 0 : u > 1 ? 1 : u || 0, y = _e.progress;
                        if (e && (g = d,
                        d = h,
                        ce && (Ct = At,
                        At = n && !ue ? n.totalProgress() : f)),
                        se && !f && ne && !v && !P && O && x < h + (h - g) / (D() - m) * se && (f = 1e-4),
                        f !== y && _e.enabled) {
                            if (o = (c = (i = _e.isActive = !!f && f < 1) !== (!!y && y < 1)) || !!f != !!y,
                            _e.direction = f > y ? 1 : -1,
                            _e.progress = f,
                            ue || (!Pt || v || P ? n && n.totalProgress(f, !!v) : (Pt.vars.totalProgress = f,
                            Pt.invalidate().restart())),
                            ne)
                                if (t && ie && (J.style[ie + Xt.os2] = bt),
                                me) {
                                    if (o) {
                                        if (a = !t && f > y && w + 1 > h && h + 1 >= W(de, Xt),
                                        he)
                                            if (t || !i && !a)
                                                Wt(ne, J);
                                            else {
                                                var _ = st(ne, !0)
                                                  , b = h - x;
                                                Wt(ne, l, _.top + (Xt === nt ? b : 0) + tt, _.left + (Xt === nt ? 0 : b) + tt)
                                            }
                                        Ft(i || a ? F : j),
                                        xt !== N && f < 1 && i || pt(gt + (1 !== f || a ? 0 : xt))
                                    }
                                } else
                                    pt(gt + xt * f);
                            ce && !r.tween && !v && !P && Nt.restart(!0),
                            Jt && (c || le && f && (f < 1 || !L)) && p(Jt.targets).forEach((function(t) {
                                return t.classList[i || le ? "add" : "remove"](Jt.className)
                            }
                            )),
                            Zt && !ue && !t && Zt(_e),
                            o && !v ? (s = f && !y ? 0 : 1 === f ? 1 : 1 === y ? 2 : 3,
                            ue && (a = !c && "none" !== ve[s + 1] && ve[s + 1] || ve[s],
                            n && ("complete" === a || "reset" === a || a in n) && ("complete" === a ? n.pause().totalProgress(1) : "reset" === a ? n.restart(!0).pause() : n[a]()),
                            Zt && Zt(_e)),
                            !c && L || (Kt && c && Kt(_e),
                            ge[s] && ge[s](_e),
                            le && (1 === f ? _e.kill(!1, 1) : ge[s] = 0),
                            c || ge[s = 1 === f ? 1 : 3] && ge[s](_e))) : ue && Zt && !v && Zt(_e)
                        }
                        Tt && (St(h + (E._isFlipped ? 1 : 0)),
                        Tt(h))
                    }
                    ,
                    _e.enable = function() {
                        _e.enabled || (_e.enabled = !0,
                        ct(de, "resize", wt),
                        ct(de, "scroll", _t),
                        we && ct(t, "refreshInit", we),
                        n && n.add ? i.delayedCall(.01, (function() {
                            return x || w || _e.refresh()
                        }
                        )) && (N = .01) && (x = w = 0) : _e.refresh())
                    }
                    ,
                    _e.disable = function(e, n) {
                        if (_e.enabled && (!1 !== e && _e.revert(),
                        _e.enabled = _e.isActive = !1,
                        n || Pt && Pt.pause(),
                        zt = 0,
                        c && (c.uncache = 1),
                        we && ht(t, "refreshInit", we),
                        Nt && (Nt.pause(),
                        r.tween && r.tween.kill() && (r.tween = 0)),
                        !fe)) {
                            for (var i = vt.length; i--; )
                                if (vt[i].scroller === de && vt[i] !== _e)
                                    return;
                            ht(de, "resize", wt),
                            ht(de, "scroll", _t)
                        }
                    }
                    ,
                    _e.kill = function(t, e) {
                        _e.disable(t, e),
                        $t && delete yt[$t];
                        var i = vt.indexOf(_e);
                        vt.splice(i, 1),
                        i === _ && Dt > 0 && _--,
                        n && (n.scrollTrigger = null,
                        t && n.render(-1),
                        e || n.kill()),
                        b && [b, M, E, C].forEach((function(t) {
                            return t.parentNode.removeChild(t)
                        }
                        )),
                        ne && (c && (c.uncache = 1),
                        i = 0,
                        vt.forEach((function(t) {
                            return t.pin === ne && i++
                        }
                        )),
                        i || (c.spacer = 0))
                    }
                    ,
                    _e.enable()
                } else
                    this.update = this.refresh = this.kill = B
            }
            ,
            t.register = function(e) {
                if (!r && (i = e || F(),
                k() && window.document && (s = window,
                a = document,
                o = a.documentElement,
                l = a.body),
                i && (p = i.utils.toArray,
                f = i.utils.clamp,
                T = i.core.suppressOverwrites || B,
                i.core.globals("ScrollTrigger", t),
                l))) {
                    u = s.requestAnimationFrame || function(t) {
                        return setTimeout(t, 16)
                    }
                    ,
                    ct(s, "mousewheel", _t),
                    c = [s, a, o, l],
                    ct(a, "scroll", _t);
                    var n, d = l.style, m = d.borderTop;
                    d.borderTop = "1px solid #000",
                    n = st(l),
                    nt.m = Math.round(n.top + nt.sc()) || 0,
                    et.m = Math.round(n.left + et.sc()) || 0,
                    m ? d.borderTop = m : d.removeProperty("border-top"),
                    g = setInterval(xt, 200),
                    i.delayedCall(.5, (function() {
                        return P = 0
                    }
                    )),
                    ct(a, "touchcancel", B),
                    ct(l, "touchstart", B),
                    lt(ct, a, "pointerdown,touchstart,mousedown", (function() {
                        return y = 1
                    }
                    )),
                    lt(ct, a, "pointerup,touchend,mouseup", (function() {
                        return y = 0
                    }
                    )),
                    x = i.utils.checkPrefix("transform"),
                    zt.push(x),
                    r = D(),
                    h = i.delayedCall(.2, Rt).pause(),
                    M = [a, "visibilitychange", function() {
                        var t = s.innerWidth
                          , e = s.innerHeight;
                        a.hidden ? (w = t,
                        b = e) : w === t && b === e || wt()
                    }
                    , a, "DOMContentLoaded", Rt, s, "load", function() {
                        return O || Rt()
                    }
                    , s, "resize", wt],
                    j(ct)
                }
                return r
            }
            ,
            t.defaults = function(t) {
                for (var e in t)
                    dt[e] = t[e]
            }
            ,
            t.kill = function() {
                z = 0,
                vt.slice(0).forEach((function(t) {
                    return t.kill(1)
                }
                ))
            }
            ,
            t.config = function(t) {
                "limitCallbacks"in t && (L = !!t.limitCallbacks);
                var e = t.syncInterval;
                e && clearInterval(g) || (g = e) && setInterval(xt, e),
                "autoRefreshEvents"in t && (j(ht) || j(ct, t.autoRefreshEvents || "none"),
                E = -1 === (t.autoRefreshEvents + "").indexOf("resize"))
            }
            ,
            t.scrollerProxy = function(t, e) {
                var n = p(t)[0]
                  , i = I.indexOf(n)
                  , r = H(n);
                ~i && I.splice(i, r ? 6 : 2),
                r ? R.unshift(s, e, l, e, o, e) : R.unshift(n, e)
            }
            ,
            t.matchMedia = function(t) {
                var e, n, i, r, a;
                for (n in t)
                    i = St.indexOf(n),
                    r = t[n],
                    A = n,
                    "all" === n ? r() : (e = s.matchMedia(n)) && (e.matches && (a = r()),
                    ~i ? (St[i + 1] = $(St[i + 1], r),
                    St[i + 2] = $(St[i + 2], a)) : (i = St.length,
                    St.push(n, r, a),
                    e.addListener ? e.addListener(Tt) : e.addEventListener("change", Tt)),
                    St[i + 3] = e.matches),
                    A = 0;
                return St
            }
            ,
            t.clearMatchMedia = function(t) {
                t || (St.length = 0),
                (t = St.indexOf(t)) >= 0 && St.splice(t, 4)
            }
            ,
            t
        }();
        qt.version = "3.6.0",
        qt.saveStyles = function(t) {
            return t ? p(t).forEach((function(t) {
                if (t && t.style) {
                    var e = At.indexOf(t);
                    e >= 0 && At.splice(e, 4),
                    At.push(t, t.style.cssText, i.core.getCache(t), A)
                }
            }
            )) : At
        }
        ,
        qt.revert = function(t, e) {
            return Pt(!t, e)
        }
        ,
        qt.create = function(t, e) {
            return new qt(t,e)
        }
        ,
        qt.refresh = function(t) {
            return t ? wt() : Rt(!0)
        }
        ,
        qt.update = Nt,
        qt.maxScroll = function(t, e) {
            return W(t, e ? et : nt)
        }
        ,
        qt.getScrollFunc = function(t, e) {
            return G(p(t)[0], e ? et : nt)
        }
        ,
        qt.getById = function(t) {
            return yt[t]
        }
        ,
        qt.getAll = function() {
            return vt.slice(0)
        }
        ,
        qt.isScrolling = function() {
            return !!O
        }
        ,
        qt.addEventListener = function(t, e) {
            var n = bt[t] || (bt[t] = []);
            ~n.indexOf(e) || n.push(e)
        }
        ,
        qt.removeEventListener = function(t, e) {
            var n = bt[t]
              , i = n && n.indexOf(e);
            i >= 0 && n.splice(i, 1)
        }
        ,
        qt.batch = function(t, e) {
            var n, r = [], s = {}, a = e.interval || .016, o = e.batchMax || 1e9, l = function(t, e) {
                var n = []
                  , r = []
                  , s = i.delayedCall(a, (function() {
                    e(n, r),
                    n = [],
                    r = []
                }
                )).pause();
                return function(t) {
                    n.length || s.restart(!0),
                    n.push(t.trigger),
                    r.push(t),
                    o <= n.length && s.progress(1)
                }
            };
            for (n in e)
                s[n] = "on" === n.substr(0, 2) && X(e[n]) && "onRefreshInit" !== n ? l(0, e[n]) : e[n];
            return X(o) && (o = o(),
            ct(qt, "refresh", (function() {
                return o = e.batchMax()
            }
            ))),
            p(t).forEach((function(t) {
                var e = {};
                for (n in s)
                    e[n] = s[n];
                e.trigger = t,
                r.push(qt.create(e))
            }
            )),
            r
        }
        ,
        qt.sort = function(t) {
            return vt.sort(t || function(t, e) {
                return -1e6 * (t.vars.refreshPriority || 0) + t.start - (e.start + -1e6 * (e.vars.refreshPriority || 0))
            }
            )
        }
        ,
        F() && i.registerPlugin(qt)
    },
    "I8a+": function(t, e, n) {
        var i = n("LZWt")
          , r = n("K0xU")("toStringTag")
          , s = "Arguments" == i(function() {
            return arguments
        }());
        t.exports = function(t) {
            var e, n, a;
            return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (n = function(t, e) {
                try {
                    return t[e]
                } catch (t) {}
            }(e = Object(t), r)) ? n : s ? i(e) : "Object" == (a = i(e)) && "function" == typeof e.callee ? "Arguments" : a
        }
    },
    "IU+Z": function(t, e, n) {
        "use strict";
        n("sMXx");
        var i = n("KroJ")
          , r = n("Mukb")
          , s = n("eeVq")
          , a = n("vhPU")
          , o = n("K0xU")
          , l = n("Ugos")
          , c = o("species")
          , h = !s((function() {
            var t = /./;
            return t.exec = function() {
                var t = [];
                return t.groups = {
                    a: "7"
                },
                t
            }
            ,
            "7" !== "".replace(t, "$<a>")
        }
        ))
          , u = function() {
            var t = /(?:)/
              , e = t.exec;
            t.exec = function() {
                return e.apply(this, arguments)
            }
            ;
            var n = "ab".split(t);
            return 2 === n.length && "a" === n[0] && "b" === n[1]
        }();
        t.exports = function(t, e, n) {
            var d = o(t)
              , p = !s((function() {
                var e = {};
                return e[d] = function() {
                    return 7
                }
                ,
                7 != ""[t](e)
            }
            ))
              , f = p ? !s((function() {
                var e = !1
                  , n = /a/;
                return n.exec = function() {
                    return e = !0,
                    null
                }
                ,
                "split" === t && (n.constructor = {},
                n.constructor[c] = function() {
                    return n
                }
                ),
                n[d](""),
                !e
            }
            )) : void 0;
            if (!p || !f || "replace" === t && !h || "split" === t && !u) {
                var m = /./[d]
                  , g = n(a, d, ""[t], (function(t, e, n, i, r) {
                    return e.exec === l ? p && !r ? {
                        done: !0,
                        value: m.call(e, n, i)
                    } : {
                        done: !0,
                        value: t.call(n, e, i)
                    } : {
                        done: !1
                    }
                }
                ))
                  , v = g[0]
                  , y = g[1];
                i(String.prototype, t, v),
                r(RegExp.prototype, d, 2 == e ? function(t, e) {
                    return y.call(t, this, e)
                }
                : function(t) {
                    return y.call(t, this)
                }
                )
            }
        }
    },
    Iw71: function(t, e, n) {
        var i = n("0/R4")
          , r = n("dyZX").document
          , s = i(r) && i(r.createElement);
        t.exports = function(t) {
            return s ? r.createElement(t) : {}
        }
    },
    "J+6e": function(t, e, n) {
        var i = n("I8a+")
          , r = n("K0xU")("iterator")
          , s = n("hPIQ");
        t.exports = n("g3g5").getIteratorMethod = function(t) {
            if (null != t)
                return t[r] || t["@@iterator"] || s[i(t)]
        }
    },
    JiEa: function(t, e) {
        e.f = Object.getOwnPropertySymbols
    },
    K0xU: function(t, e, n) {
        var i = n("VTer")("wks")
          , r = n("ylqs")
          , s = n("dyZX").Symbol
          , a = "function" == typeof s;
        (t.exports = function(t) {
            return i[t] || (i[t] = a && s[t] || (a ? s : r)("Symbol." + t))
        }
        ).store = i
    },
    KKXr: function(t, e, n) {
        "use strict";
        var i = n("quPj")
          , r = n("y3w9")
          , s = n("69bn")
          , a = n("A5AN")
          , o = n("ne8i")
          , l = n("Xxuz")
          , c = n("Ugos")
          , h = n("eeVq")
          , u = Math.min
          , d = [].push
          , p = "length"
          , f = !h((function() {
            RegExp(4294967295, "y")
        }
        ));
        n("IU+Z")("split", 2, (function(t, e, n, h) {
            var m;
            return m = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1)[p] || 2 != "ab".split(/(?:ab)*/)[p] || 4 != ".".split(/(.?)(.?)/)[p] || ".".split(/()()/)[p] > 1 || "".split(/.?/)[p] ? function(t, e) {
                var r = String(this);
                if (void 0 === t && 0 === e)
                    return [];
                if (!i(t))
                    return n.call(r, t, e);
                for (var s, a, o, l = [], h = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""), u = 0, f = void 0 === e ? 4294967295 : e >>> 0, m = new RegExp(t.source,h + "g"); (s = c.call(m, r)) && !((a = m.lastIndex) > u && (l.push(r.slice(u, s.index)),
                s[p] > 1 && s.index < r[p] && d.apply(l, s.slice(1)),
                o = s[0][p],
                u = a,
                l[p] >= f)); )
                    m.lastIndex === s.index && m.lastIndex++;
                return u === r[p] ? !o && m.test("") || l.push("") : l.push(r.slice(u)),
                l[p] > f ? l.slice(0, f) : l
            }
            : "0".split(void 0, 0)[p] ? function(t, e) {
                return void 0 === t && 0 === e ? [] : n.call(this, t, e)
            }
            : n,
            [function(n, i) {
                var r = t(this)
                  , s = null == n ? void 0 : n[e];
                return void 0 !== s ? s.call(n, r, i) : m.call(String(r), n, i)
            }
            , function(t, e) {
                var i = h(m, t, this, e, m !== n);
                if (i.done)
                    return i.value;
                var c = r(t)
                  , d = String(this)
                  , p = s(c, RegExp)
                  , g = c.unicode
                  , v = (c.ignoreCase ? "i" : "") + (c.multiline ? "m" : "") + (c.unicode ? "u" : "") + (f ? "y" : "g")
                  , y = new p(f ? c : "^(?:" + c.source + ")",v)
                  , x = void 0 === e ? 4294967295 : e >>> 0;
                if (0 === x)
                    return [];
                if (0 === d.length)
                    return null === l(y, d) ? [d] : [];
                for (var _ = 0, w = 0, b = []; w < d.length; ) {
                    y.lastIndex = f ? w : 0;
                    var M, S = l(y, f ? d : d.slice(w));
                    if (null === S || (M = u(o(y.lastIndex + (f ? 0 : w)), d.length)) === _)
                        w = a(d, w, g);
                    else {
                        if (b.push(d.slice(_, w)),
                        b.length === x)
                            return b;
                        for (var T = 1; T <= S.length - 1; T++)
                            if (b.push(S[T]),
                            b.length === x)
                                return b;
                        w = _ = M
                    }
                }
                return b.push(d.slice(_)),
                b
            }
            ]
        }
        ))
    },
    KroJ: function(t, e, n) {
        var i = n("dyZX")
          , r = n("Mukb")
          , s = n("aagx")
          , a = n("ylqs")("src")
          , o = n("+lvF")
          , l = ("" + o).split("toString");
        n("g3g5").inspectSource = function(t) {
            return o.call(t)
        }
        ,
        (t.exports = function(t, e, n, o) {
            var c = "function" == typeof n;
            c && (s(n, "name") || r(n, "name", e)),
            t[e] !== n && (c && (s(n, a) || r(n, a, t[e] ? "" + t[e] : l.join(String(e)))),
            t === i ? t[e] = n : o ? t[e] ? t[e] = n : r(t, e, n) : (delete t[e],
            r(t, e, n)))
        }
        )(Function.prototype, "toString", (function() {
            return "function" == typeof this && this[a] || o.call(this)
        }
        ))
    },
    Kuth: function(t, e, n) {
        var i = n("y3w9")
          , r = n("FJW5")
          , s = n("4R4u")
          , a = n("YTvA")("IE_PROTO")
          , o = function() {}
          , l = function() {
            var t, e = n("Iw71")("iframe"), i = s.length;
            for (e.style.display = "none",
            n("+rLv").appendChild(e),
            e.src = "javascript:",
            (t = e.contentWindow.document).open(),
            t.write("<script>document.F=Object<\/script>"),
            t.close(),
            l = t.F; i--; )
                delete l.prototype[s[i]];
            return l()
        };
        t.exports = Object.create || function(t, e) {
            var n;
            return null !== t ? (o.prototype = i(t),
            n = new o,
            o.prototype = null,
            n[a] = t) : n = l(),
            void 0 === e ? n : r(n, e)
        }
    },
    L9s1: function(t, e, n) {
        "use strict";
        var i = n("XKFU")
          , r = n("0sh+");
        i(i.P + i.F * n("UUeW")("includes"), "String", {
            includes: function(t) {
                return !!~r(this, t, "includes").indexOf(t, arguments.length > 1 ? arguments[1] : void 0)
            }
        })
    },
    LQAc: function(t, e) {
        t.exports = !1
    },
    LZWt: function(t, e) {
        var n = {}.toString;
        t.exports = function(t) {
            return n.call(t).slice(8, -1)
        }
    },
    M6Qj: function(t, e, n) {
        var i = n("hPIQ")
          , r = n("K0xU")("iterator")
          , s = Array.prototype;
        t.exports = function(t) {
            return void 0 !== t && (i.Array === t || s[r] === t)
        }
    },
    Mukb: function(t, e, n) {
        var i = n("hswa")
          , r = n("RjD/");
        t.exports = n("nh4g") ? function(t, e, n) {
            return i.f(t, e, r(1, n))
        }
        : function(t, e, n) {
            return t[e] = n,
            t
        }
    },
    N8g3: function(t, e, n) {
        e.f = n("K0xU")
    },
    OEbY: function(t, e, n) {
        n("nh4g") && "g" != /./g.flags && n("hswa").f(RegExp.prototype, "flags", {
            configurable: !0,
            get: n("C/va")
        })
    },
    OGtf: function(t, e, n) {
        var i = n("XKFU")
          , r = n("eeVq")
          , s = n("vhPU")
          , a = /"/g
          , o = function(t, e, n, i) {
            var r = String(s(t))
              , o = "<" + e;
            return "" !== n && (o += " " + n + '="' + String(i).replace(a, "&quot;") + '"'),
            o + ">" + r + "</" + e + ">"
        };
        t.exports = function(t, e) {
            var n = {};
            n[t] = e(o),
            i(i.P + i.F * r((function() {
                var e = ""[t]('"');
                return e !== e.toLowerCase() || e.split('"').length > 3
            }
            )), "String", n)
        }
    },
    OP3Y: function(t, e, n) {
        var i = n("aagx")
          , r = n("S/j/")
          , s = n("YTvA")("IE_PROTO")
          , a = Object.prototype;
        t.exports = Object.getPrototypeOf || function(t) {
            return t = r(t),
            i(t, s) ? t[s] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? a : null
        }
    },
    OnI7: function(t, e, n) {
        var i = n("dyZX")
          , r = n("g3g5")
          , s = n("LQAc")
          , a = n("N8g3")
          , o = n("hswa").f;
        t.exports = function(t) {
            var e = r.Symbol || (r.Symbol = s ? {} : i.Symbol || {});
            "_" == t.charAt(0) || t in e || o(e, t, {
                value: a.f(t)
            })
        }
    },
    QaDb: function(t, e, n) {
        "use strict";
        var i = n("Kuth")
          , r = n("RjD/")
          , s = n("fyDq")
          , a = {};
        n("Mukb")(a, n("K0xU")("iterator"), (function() {
            return this
        }
        )),
        t.exports = function(t, e, n) {
            t.prototype = i(a, {
                next: r(1, n)
            }),
            s(t, e + " Iterator")
        }
    },
    RYi7: function(t, e) {
        var n = Math.ceil
          , i = Math.floor;
        t.exports = function(t) {
            return isNaN(t = +t) ? 0 : (t > 0 ? i : n)(t)
        }
    },
    "RjD/": function(t, e) {
        t.exports = function(t, e) {
            return {
                enumerable: !(1 & t),
                configurable: !(2 & t),
                writable: !(4 & t),
                value: e
            }
        }
    },
    "S/j/": function(t, e, n) {
        var i = n("vhPU");
        t.exports = function(t) {
            return Object(i(t))
        }
    },
    UUeW: function(t, e, n) {
        var i = n("K0xU")("match");
        t.exports = function(t) {
            var e = /./;
            try {
                "/./"[t](e)
            } catch (n) {
                try {
                    return e[i] = !1,
                    !"/./"[t](e)
                } catch (t) {}
            }
            return !0
        }
    },
    Ugos: function(t, e, n) {
        "use strict";
        var i, r, s = n("C/va"), a = RegExp.prototype.exec, o = String.prototype.replace, l = a, c = (i = /a/,
        r = /b*/g,
        a.call(i, "a"),
        a.call(r, "a"),
        0 !== i.lastIndex || 0 !== r.lastIndex), h = void 0 !== /()??/.exec("")[1];
        (c || h) && (l = function(t) {
            var e, n, i, r, l = this;
            return h && (n = new RegExp("^" + l.source + "$(?!\\s)",s.call(l))),
            c && (e = l.lastIndex),
            i = a.call(l, t),
            c && i && (l.lastIndex = l.global ? i.index + i[0].length : e),
            h && i && i.length > 1 && o.call(i[0], n, (function() {
                for (r = 1; r < arguments.length - 2; r++)
                    void 0 === arguments[r] && (i[r] = void 0)
            }
            )),
            i
        }
        ),
        t.exports = l
    },
    UqcF: function(t, e) {
        e.f = {}.propertyIsEnumerable
    },
    VTer: function(t, e, n) {
        var i = n("g3g5")
          , r = n("dyZX")
          , s = r["__core-js_shared__"] || (r["__core-js_shared__"] = {});
        (t.exports = function(t, e) {
            return s[t] || (s[t] = void 0 !== e ? e : {})
        }
        )("versions", []).push({
            version: i.version,
            mode: n("LQAc") ? "pure" : "global",
            copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
        })
    },
    VaY2: function(t, e, n) {
        "use strict";
        n.d(e, "a", (function() {
            return l
        }
        ));
        n("XfO3"),
        n("HEwt"),
        n("a1Th"),
        n("Btvt"),
        n("rE2o"),
        n("ioFf"),
        n("rGqo");
        var i, r = !1, s = null, a = function(t) {
            if (Array.isArray(t)) {
                for (var e = 0, n = new Array(t.length); e < t.length; e++)
                    n[e] = t[e];
                return n
            }
        }(i = document.querySelectorAll(".js-parallax")) || function(t) {
            if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t))
                return Array.from(t)
        }(i) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance")
        }(), o = function() {
            r = window.innerWidth < window.BREAKPOINT;
            var t = !0
              , e = !1
              , n = void 0;
            try {
                for (var i, o = a[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                    var l = i.value;
                    s.unobserve(l),
                    s.observe(l)
                }
            } catch (t) {
                e = !0,
                n = t
            } finally {
                try {
                    t || null == o.return || o.return()
                } finally {
                    if (e)
                        throw n
                }
            }
        }, l = function() {
            r = window.innerWidth < window.BREAKPOINT,
            s = new IntersectionObserver((function(t) {
                t.forEach((function(t) {
                    var e = function() {
                        var e = t.target.dataset.speed
                          , n = r ? .4 * e : e;
                        gsap.to(t.target, {
                            duration: .5,
                            ease: "power2.out",
                            y: t.target.getBoundingClientRect().top * n
                        })
                    };
                    t.isIntersecting ? window.addEventListener("scroll", e, {
                        capture: !1,
                        passive: !0
                    }) : window.removeEventListener("scroll", e, {
                        capture: !1,
                        passive: !0
                    })
                }
                ))
            }
            ),{
                rootMargin: "0px"
            });
            var t = !0
              , e = !1
              , n = void 0;
            try {
                for (var i, l = a[Symbol.iterator](); !(t = (i = l.next()).done); t = !0) {
                    var c = i.value;
                    s.observe(c)
                }
            } catch (t) {
                e = !0,
                n = t
            } finally {
                try {
                    t || null == l.return || l.return()
                } finally {
                    if (e)
                        throw n
                }
            }
            window.addEventListener("resize", o)
        }
    },
    XKFU: function(t, e, n) {
        var i = n("dyZX")
          , r = n("g3g5")
          , s = n("Mukb")
          , a = n("KroJ")
          , o = n("m0Pp")
          , l = function(t, e, n) {
            var c, h, u, d, p = t & l.F, f = t & l.G, m = t & l.S, g = t & l.P, v = t & l.B, y = f ? i : m ? i[e] || (i[e] = {}) : (i[e] || {}).prototype, x = f ? r : r[e] || (r[e] = {}), _ = x.prototype || (x.prototype = {});
            for (c in f && (n = e),
            n)
                u = ((h = !p && y && void 0 !== y[c]) ? y : n)[c],
                d = v && h ? o(u, i) : g && "function" == typeof u ? o(Function.call, u) : u,
                y && a(y, c, u, t & l.U),
                x[c] != u && s(x, c, d),
                g && _[c] != u && (_[c] = u)
        };
        i.core = r,
        l.F = 1,
        l.G = 2,
        l.S = 4,
        l.P = 8,
        l.B = 16,
        l.W = 32,
        l.U = 64,
        l.R = 128,
        t.exports = l
    },
    XMVh: function(t, e, n) {
        var i = n("K0xU")("iterator")
          , r = !1;
        try {
            var s = [7][i]();
            s.return = function() {
                r = !0
            }
            ,
            Array.from(s, (function() {
                throw 2
            }
            ))
        } catch (t) {}
        t.exports = function(t, e) {
            if (!e && !r)
                return !1;
            var n = !1;
            try {
                var s = [7]
                  , a = s[i]();
                a.next = function() {
                    return {
                        done: n = !0
                    }
                }
                ,
                s[i] = function() {
                    return a
                }
                ,
                t(s)
            } catch (t) {}
            return n
        }
    },
    XfO3: function(t, e, n) {
        "use strict";
        var i = n("AvRE")(!0);
        n("Afnz")(String, "String", (function(t) {
            this._t = String(t),
            this._i = 0
        }
        ), (function() {
            var t, e = this._t, n = this._i;
            return n >= e.length ? {
                value: void 0,
                done: !0
            } : (t = i(e, n),
            this._i += t.length,
            {
                value: t,
                done: !1
            })
        }
        ))
    },
    Xxuz: function(t, e, n) {
        "use strict";
        var i = n("I8a+")
          , r = RegExp.prototype.exec;
        t.exports = function(t, e) {
            var n = t.exec;
            if ("function" == typeof n) {
                var s = n.call(t, e);
                if ("object" != typeof s)
                    throw new TypeError("RegExp exec method returned something other than an Object or null");
                return s
            }
            if ("RegExp" !== i(t))
                throw new TypeError("RegExp#exec called on incompatible receiver");
            return r.call(t, e)
        }
    },
    YTvA: function(t, e, n) {
        var i = n("VTer")("keys")
          , r = n("ylqs");
        t.exports = function(t) {
            return i[t] || (i[t] = r(t))
        }
    },
    Ymqv: function(t, e, n) {
        var i = n("LZWt");
        t.exports = Object("z").propertyIsEnumerable(0) ? Object : function(t) {
            return "String" == i(t) ? t.split("") : Object(t)
        }
    },
    Z2Ku: function(t, e, n) {
        "use strict";
        var i = n("XKFU")
          , r = n("w2a5")(!0);
        i(i.P, "Array", {
            includes: function(t) {
                return r(this, t, arguments.length > 1 ? arguments[1] : void 0)
            }
        }),
        n("nGyu")("includes")
    },
    Z6vF: function(t, e, n) {
        var i = n("ylqs")("meta")
          , r = n("0/R4")
          , s = n("aagx")
          , a = n("hswa").f
          , o = 0
          , l = Object.isExtensible || function() {
            return !0
        }
          , c = !n("eeVq")((function() {
            return l(Object.preventExtensions({}))
        }
        ))
          , h = function(t) {
            a(t, i, {
                value: {
                    i: "O" + ++o,
                    w: {}
                }
            })
        }
          , u = t.exports = {
            KEY: i,
            NEED: !1,
            fastKey: function(t, e) {
                if (!r(t))
                    return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;
                if (!s(t, i)) {
                    if (!l(t))
                        return "F";
                    if (!e)
                        return "E";
                    h(t)
                }
                return t[i].i
            },
            getWeak: function(t, e) {
                if (!s(t, i)) {
                    if (!l(t))
                        return !0;
                    if (!e)
                        return !1;
                    h(t)
                }
                return t[i].w
            },
            onFreeze: function(t) {
                return c && u.NEED && l(t) && !s(t, i) && h(t),
                t
            }
        }
    },
    a1Th: function(t, e, n) {
        "use strict";
        n("OEbY");
        var i = n("y3w9")
          , r = n("C/va")
          , s = n("nh4g")
          , a = /./.toString
          , o = function(t) {
            n("KroJ")(RegExp.prototype, "toString", t, !0)
        };
        n("eeVq")((function() {
            return "/a/b" != a.call({
                source: "a",
                flags: "b"
            })
        }
        )) ? o((function() {
            var t = i(this);
            return "/".concat(t.source, "/", "flags"in t ? t.flags : !s && t instanceof RegExp ? r.call(t) : void 0)
        }
        )) : "toString" != a.name && o((function() {
            return a.call(this)
        }
        ))
    },
    aCFj: function(t, e, n) {
        var i = n("Ymqv")
          , r = n("vhPU");
        t.exports = function(t) {
            return i(r(t))
        }
    },
    aagx: function(t, e) {
        var n = {}.hasOwnProperty;
        t.exports = function(t, e) {
            return n.call(t, e)
        }
    },
    apmT: function(t, e, n) {
        var i = n("0/R4");
        t.exports = function(t, e) {
            if (!i(t))
                return t;
            var n, r;
            if (e && "function" == typeof (n = t.toString) && !i(r = n.call(t)))
                return r;
            if ("function" == typeof (n = t.valueOf) && !i(r = n.call(t)))
                return r;
            if (!e && "function" == typeof (n = t.toString) && !i(r = n.call(t)))
                return r;
            throw TypeError("Can't convert object to primitive value")
        }
    },
    cRqm: function(t, e, n) {
        "use strict";
        n.d(e, "a", (function() {
            return i
        }
        ));
        var i = function t() {
            !function(t, e) {
                if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }(this, t),
            sessionStorage.getItem("visited") || sessionStorage.setItem("visited", "true")
        }
    },
    "d/Gc": function(t, e, n) {
        var i = n("RYi7")
          , r = Math.max
          , s = Math.min;
        t.exports = function(t, e) {
            return (t = i(t)) < 0 ? r(t + e, 0) : s(t, e)
        }
    },
    dyZX: function(t, e) {
        var n = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = n)
    },
    e7yV: function(t, e, n) {
        var i = n("aCFj")
          , r = n("kJMx").f
          , s = {}.toString
          , a = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        t.exports.f = function(t) {
            return a && "[object Window]" == s.call(t) ? function(t) {
                try {
                    return r(t)
                } catch (t) {
                    return a.slice()
                }
            }(t) : r(i(t))
        }
    },
    eeVq: function(t, e) {
        t.exports = function(t) {
            try {
                return !!t()
            } catch (t) {
                return !0
            }
        }
    },
    fyDq: function(t, e, n) {
        var i = n("hswa").f
          , r = n("aagx")
          , s = n("K0xU")("toStringTag");
        t.exports = function(t, e, n) {
            t && !r(t = n ? t : t.prototype, s) && i(t, s, {
                configurable: !0,
                value: e
            })
        }
    },
    g3g5: function(t, e) {
        var n = t.exports = {
            version: "2.6.10"
        };
        "number" == typeof __e && (__e = n)
    },
    hPIQ: function(t, e) {
        t.exports = {}
    },
    hswa: function(t, e, n) {
        var i = n("y3w9")
          , r = n("xpql")
          , s = n("apmT")
          , a = Object.defineProperty;
        e.f = n("nh4g") ? Object.defineProperty : function(t, e, n) {
            if (i(t),
            e = s(e, !0),
            i(n),
            r)
                try {
                    return a(t, e, n)
                } catch (t) {}
            if ("get"in n || "set"in n)
                throw TypeError("Accessors not supported!");
            return "value"in n && (t[e] = n.value),
            t
        }
    },
    ioFf: function(t, e, n) {
        "use strict";
        var i = n("dyZX")
          , r = n("aagx")
          , s = n("nh4g")
          , a = n("XKFU")
          , o = n("KroJ")
          , l = n("Z6vF").KEY
          , c = n("eeVq")
          , h = n("VTer")
          , u = n("fyDq")
          , d = n("ylqs")
          , p = n("K0xU")
          , f = n("N8g3")
          , m = n("OnI7")
          , g = n("1MBn")
          , v = n("EWmC")
          , y = n("y3w9")
          , x = n("0/R4")
          , _ = n("S/j/")
          , w = n("aCFj")
          , b = n("apmT")
          , M = n("RjD/")
          , S = n("Kuth")
          , T = n("e7yV")
          , E = n("EemH")
          , L = n("JiEa")
          , A = n("hswa")
          , C = n("DVgA")
          , P = E.f
          , R = A.f
          , I = T.f
          , D = i.Symbol
          , N = i.JSON
          , O = N && N.stringify
          , z = p("_hidden")
          , B = p("toPrimitive")
          , k = {}.propertyIsEnumerable
          , F = h("symbol-registry")
          , H = h("symbols")
          , U = h("op-symbols")
          , G = Object.prototype
          , V = "function" == typeof D && !!L.f
          , W = i.QObject
          , j = !W || !W.prototype || !W.prototype.findChild
          , q = s && c((function() {
            return 7 != S(R({}, "a", {
                get: function() {
                    return R(this, "a", {
                        value: 7
                    }).a
                }
            })).a
        }
        )) ? function(t, e, n) {
            var i = P(G, e);
            i && delete G[e],
            R(t, e, n),
            i && t !== G && R(G, e, i)
        }
        : R
          , X = function(t) {
            var e = H[t] = S(D.prototype);
            return e._k = t,
            e
        }
          , Y = V && "symbol" == typeof D.iterator ? function(t) {
            return "symbol" == typeof t
        }
        : function(t) {
            return t instanceof D
        }
          , Z = function(t, e, n) {
            return t === G && Z(U, e, n),
            y(t),
            e = b(e, !0),
            y(n),
            r(H, e) ? (n.enumerable ? (r(t, z) && t[z][e] && (t[z][e] = !1),
            n = S(n, {
                enumerable: M(0, !1)
            })) : (r(t, z) || R(t, z, M(1, {})),
            t[z][e] = !0),
            q(t, e, n)) : R(t, e, n)
        }
          , J = function(t, e) {
            y(t);
            for (var n, i = g(e = w(e)), r = 0, s = i.length; s > r; )
                Z(t, n = i[r++], e[n]);
            return t
        }
          , $ = function(t) {
            var e = k.call(this, t = b(t, !0));
            return !(this === G && r(H, t) && !r(U, t)) && (!(e || !r(this, t) || !r(H, t) || r(this, z) && this[z][t]) || e)
        }
          , K = function(t, e) {
            if (t = w(t),
            e = b(e, !0),
            t !== G || !r(H, e) || r(U, e)) {
                var n = P(t, e);
                return !n || !r(H, e) || r(t, z) && t[z][e] || (n.enumerable = !0),
                n
            }
        }
          , Q = function(t) {
            for (var e, n = I(w(t)), i = [], s = 0; n.length > s; )
                r(H, e = n[s++]) || e == z || e == l || i.push(e);
            return i
        }
          , tt = function(t) {
            for (var e, n = t === G, i = I(n ? U : w(t)), s = [], a = 0; i.length > a; )
                !r(H, e = i[a++]) || n && !r(G, e) || s.push(H[e]);
            return s
        };
        V || (o((D = function() {
            if (this instanceof D)
                throw TypeError("Symbol is not a constructor!");
            var t = d(arguments.length > 0 ? arguments[0] : void 0)
              , e = function(n) {
                this === G && e.call(U, n),
                r(this, z) && r(this[z], t) && (this[z][t] = !1),
                q(this, t, M(1, n))
            };
            return s && j && q(G, t, {
                configurable: !0,
                set: e
            }),
            X(t)
        }
        ).prototype, "toString", (function() {
            return this._k
        }
        )),
        E.f = K,
        A.f = Z,
        n("kJMx").f = T.f = Q,
        n("UqcF").f = $,
        L.f = tt,
        s && !n("LQAc") && o(G, "propertyIsEnumerable", $, !0),
        f.f = function(t) {
            return X(p(t))
        }
        ),
        a(a.G + a.W + a.F * !V, {
            Symbol: D
        });
        for (var et = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), nt = 0; et.length > nt; )
            p(et[nt++]);
        for (var it = C(p.store), rt = 0; it.length > rt; )
            m(it[rt++]);
        a(a.S + a.F * !V, "Symbol", {
            for: function(t) {
                return r(F, t += "") ? F[t] : F[t] = D(t)
            },
            keyFor: function(t) {
                if (!Y(t))
                    throw TypeError(t + " is not a symbol!");
                for (var e in F)
                    if (F[e] === t)
                        return e
            },
            useSetter: function() {
                j = !0
            },
            useSimple: function() {
                j = !1
            }
        }),
        a(a.S + a.F * !V, "Object", {
            create: function(t, e) {
                return void 0 === e ? S(t) : J(S(t), e)
            },
            defineProperty: Z,
            defineProperties: J,
            getOwnPropertyDescriptor: K,
            getOwnPropertyNames: Q,
            getOwnPropertySymbols: tt
        });
        var st = c((function() {
            L.f(1)
        }
        ));
        a(a.S + a.F * st, "Object", {
            getOwnPropertySymbols: function(t) {
                return L.f(_(t))
            }
        }),
        N && a(a.S + a.F * (!V || c((function() {
            var t = D();
            return "[null]" != O([t]) || "{}" != O({
                a: t
            }) || "{}" != O(Object(t))
        }
        ))), "JSON", {
            stringify: function(t) {
                for (var e, n, i = [t], r = 1; arguments.length > r; )
                    i.push(arguments[r++]);
                if (n = e = i[1],
                (x(e) || void 0 !== t) && !Y(t))
                    return v(e) || (e = function(t, e) {
                        if ("function" == typeof n && (e = n.call(this, t, e)),
                        !Y(e))
                            return e
                    }
                    ),
                    i[1] = e,
                    O.apply(N, i)
            }
        }),
        D.prototype[B] || n("Mukb")(D.prototype, B, D.prototype.valueOf),
        u(D, "Symbol"),
        u(Math, "Math", !0),
        u(i.JSON, "JSON", !0)
    },
    kJMx: function(t, e, n) {
        var i = n("zhAb")
          , r = n("4R4u").concat("length", "prototype");
        e.f = Object.getOwnPropertyNames || function(t) {
            return i(t, r)
        }
    },
    m0Pp: function(t, e, n) {
        var i = n("2OiF");
        t.exports = function(t, e, n) {
            if (i(t),
            void 0 === e)
                return t;
            switch (n) {
            case 1:
                return function(n) {
                    return t.call(e, n)
                }
                ;
            case 2:
                return function(n, i) {
                    return t.call(e, n, i)
                }
                ;
            case 3:
                return function(n, i, r) {
                    return t.call(e, n, i, r)
                }
            }
            return function() {
                return t.apply(e, arguments)
            }
        }
    },
    nGyu: function(t, e, n) {
        var i = n("K0xU")("unscopables")
          , r = Array.prototype;
        null == r[i] && n("Mukb")(r, i, {}),
        t.exports = function(t) {
            r[i][t] = !0
        }
    },
    ne8i: function(t, e, n) {
        var i = n("RYi7")
          , r = Math.min;
        t.exports = function(t) {
            return t > 0 ? r(i(t), 9007199254740991) : 0
        }
    },
    nh4g: function(t, e, n) {
        t.exports = !n("eeVq")((function() {
            return 7 != Object.defineProperty({}, "a", {
                get: function() {
                    return 7
                }
            }).a
        }
        ))
    },
    quPj: function(t, e, n) {
        var i = n("0/R4")
          , r = n("LZWt")
          , s = n("K0xU")("match");
        t.exports = function(t) {
            var e;
            return i(t) && (void 0 !== (e = t[s]) ? !!e : "RegExp" == r(t))
        }
    },
    rE2o: function(t, e, n) {
        n("OnI7")("asyncIterator")
    },
    rGqo: function(t, e, n) {
        for (var i = n("yt8O"), r = n("DVgA"), s = n("KroJ"), a = n("dyZX"), o = n("Mukb"), l = n("hPIQ"), c = n("K0xU"), h = c("iterator"), u = c("toStringTag"), d = l.Array, p = {
            CSSRuleList: !0,
            CSSStyleDeclaration: !1,
            CSSValueList: !1,
            ClientRectList: !1,
            DOMRectList: !1,
            DOMStringList: !1,
            DOMTokenList: !0,
            DataTransferItemList: !1,
            FileList: !1,
            HTMLAllCollection: !1,
            HTMLCollection: !1,
            HTMLFormElement: !1,
            HTMLSelectElement: !1,
            MediaList: !0,
            MimeTypeArray: !1,
            NamedNodeMap: !1,
            NodeList: !0,
            PaintRequestList: !1,
            Plugin: !1,
            PluginArray: !1,
            SVGLengthList: !1,
            SVGNumberList: !1,
            SVGPathSegList: !1,
            SVGPointList: !1,
            SVGStringList: !1,
            SVGTransformList: !1,
            SourceBufferList: !1,
            StyleSheetList: !0,
            TextTrackCueList: !1,
            TextTrackList: !1,
            TouchList: !1
        }, f = r(p), m = 0; m < f.length; m++) {
            var g, v = f[m], y = p[v], x = a[v], _ = x && x.prototype;
            if (_ && (_[h] || o(_, h, d),
            _[u] || o(_, u, v),
            l[v] = d,
            y))
                for (g in i)
                    _[g] || s(_, g, i[g], !0)
        }
    },
    rjBh: function(t, e, n) {
        "use strict";
        n.d(e, "a", (function() {
            return s
        }
        ));
        n("rE2o"),
        n("ioFf"),
        n("rGqo");
        var i = null
          , r = []
          , s = function() {
            r = document.querySelectorAll(".js-hover-change-image img");
            var t = !0
              , e = !1
              , n = void 0;
            try {
                for (var s, a = function() {
                    var t = s.value;
                    t.addEventListener("mouseenter", (function() {
                        !function(t) {
                            i = t.src,
                            t.src = t.dataset.hover
                        }(t)
                    }
                    ))
                }, o = r[Symbol.iterator](); !(t = (s = o.next()).done); t = !0)
                    a()
            } catch (t) {
                e = !0,
                n = t
            } finally {
                try {
                    t || null == o.return || o.return()
                } finally {
                    if (e)
                        throw n
                }
            }
            var l = !0
              , c = !1
              , h = void 0;
            try {
                for (var u, d = function() {
                    var t = u.value;
                    t.addEventListener("mouseout", (function() {
                        !function(t) {
                            t.src = i
                        }(t)
                    }
                    ))
                }, p = r[Symbol.iterator](); !(l = (u = p.next()).done); l = !0)
                    d()
            } catch (t) {
                c = !0,
                h = t
            } finally {
                try {
                    l || null == p.return || p.return()
                } finally {
                    if (c)
                        throw h
                }
            }
        }
    },
    sMXx: function(t, e, n) {
        "use strict";
        var i = n("Ugos");
        n("XKFU")({
            target: "RegExp",
            proto: !0,
            forced: i !== /./.exec
        }, {
            exec: i
        })
    },
    vX6Q: function(t, e, n) {
        var i, r;
        !function(s, a) {
            "use strict";
            i = [n("CUlp")],
            void 0 === (r = function(t) {
                return function(t, e) {
                    var n = t.jQuery
                      , i = t.console;
                    function r(t, e) {
                        for (var n in e)
                            t[n] = e[n];
                        return t
                    }
                    var s = Array.prototype.slice;
                    function a(t, e, o) {
                        if (!(this instanceof a))
                            return new a(t,e,o);
                        var l, c = t;
                        ("string" == typeof t && (c = document.querySelectorAll(t)),
                        c) ? (this.elements = (l = c,
                        Array.isArray(l) ? l : "object" == typeof l && "number" == typeof l.length ? s.call(l) : [l]),
                        this.options = r({}, this.options),
                        "function" == typeof e ? o = e : r(this.options, e),
                        o && this.on("always", o),
                        this.getImages(),
                        n && (this.jqDeferred = new n.Deferred),
                        setTimeout(this.check.bind(this))) : i.error("Bad element for imagesLoaded " + (c || t))
                    }
                    a.prototype = Object.create(e.prototype),
                    a.prototype.options = {},
                    a.prototype.getImages = function() {
                        this.images = [],
                        this.elements.forEach(this.addElementImages, this)
                    }
                    ,
                    a.prototype.addElementImages = function(t) {
                        "IMG" == t.nodeName && this.addImage(t),
                        !0 === this.options.background && this.addElementBackgroundImages(t);
                        var e = t.nodeType;
                        if (e && o[e]) {
                            for (var n = t.querySelectorAll("img"), i = 0; i < n.length; i++) {
                                var r = n[i];
                                this.addImage(r)
                            }
                            if ("string" == typeof this.options.background) {
                                var s = t.querySelectorAll(this.options.background);
                                for (i = 0; i < s.length; i++) {
                                    var a = s[i];
                                    this.addElementBackgroundImages(a)
                                }
                            }
                        }
                    }
                    ;
                    var o = {
                        1: !0,
                        9: !0,
                        11: !0
                    };
                    function l(t) {
                        this.img = t
                    }
                    function c(t, e) {
                        this.url = t,
                        this.element = e,
                        this.img = new Image
                    }
                    return a.prototype.addElementBackgroundImages = function(t) {
                        var e = getComputedStyle(t);
                        if (e)
                            for (var n = /url\((['"])?(.*?)\1\)/gi, i = n.exec(e.backgroundImage); null !== i; ) {
                                var r = i && i[2];
                                r && this.addBackground(r, t),
                                i = n.exec(e.backgroundImage)
                            }
                    }
                    ,
                    a.prototype.addImage = function(t) {
                        var e = new l(t);
                        this.images.push(e)
                    }
                    ,
                    a.prototype.addBackground = function(t, e) {
                        var n = new c(t,e);
                        this.images.push(n)
                    }
                    ,
                    a.prototype.check = function() {
                        var t = this;
                        function e(e, n, i) {
                            setTimeout((function() {
                                t.progress(e, n, i)
                            }
                            ))
                        }
                        this.progressedCount = 0,
                        this.hasAnyBroken = !1,
                        this.images.length ? this.images.forEach((function(t) {
                            t.once("progress", e),
                            t.check()
                        }
                        )) : this.complete()
                    }
                    ,
                    a.prototype.progress = function(t, e, n) {
                        this.progressedCount++,
                        this.hasAnyBroken = this.hasAnyBroken || !t.isLoaded,
                        this.emitEvent("progress", [this, t, e]),
                        this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, t),
                        this.progressedCount == this.images.length && this.complete(),
                        this.options.debug && i && i.log("progress: " + n, t, e)
                    }
                    ,
                    a.prototype.complete = function() {
                        var t = this.hasAnyBroken ? "fail" : "done";
                        if (this.isComplete = !0,
                        this.emitEvent(t, [this]),
                        this.emitEvent("always", [this]),
                        this.jqDeferred) {
                            var e = this.hasAnyBroken ? "reject" : "resolve";
                            this.jqDeferred[e](this)
                        }
                    }
                    ,
                    l.prototype = Object.create(e.prototype),
                    l.prototype.check = function() {
                        this.getIsImageComplete() ? this.confirm(0 !== this.img.naturalWidth, "naturalWidth") : (this.proxyImage = new Image,
                        this.proxyImage.addEventListener("load", this),
                        this.proxyImage.addEventListener("error", this),
                        this.img.addEventListener("load", this),
                        this.img.addEventListener("error", this),
                        this.proxyImage.src = this.img.src)
                    }
                    ,
                    l.prototype.getIsImageComplete = function() {
                        return this.img.complete && this.img.naturalWidth
                    }
                    ,
                    l.prototype.confirm = function(t, e) {
                        this.isLoaded = t,
                        this.emitEvent("progress", [this, this.img, e])
                    }
                    ,
                    l.prototype.handleEvent = function(t) {
                        var e = "on" + t.type;
                        this[e] && this[e](t)
                    }
                    ,
                    l.prototype.onload = function() {
                        this.confirm(!0, "onload"),
                        this.unbindEvents()
                    }
                    ,
                    l.prototype.onerror = function() {
                        this.confirm(!1, "onerror"),
                        this.unbindEvents()
                    }
                    ,
                    l.prototype.unbindEvents = function() {
                        this.proxyImage.removeEventListener("load", this),
                        this.proxyImage.removeEventListener("error", this),
                        this.img.removeEventListener("load", this),
                        this.img.removeEventListener("error", this)
                    }
                    ,
                    c.prototype = Object.create(l.prototype),
                    c.prototype.check = function() {
                        this.img.addEventListener("load", this),
                        this.img.addEventListener("error", this),
                        this.img.src = this.url,
                        this.getIsImageComplete() && (this.confirm(0 !== this.img.naturalWidth, "naturalWidth"),
                        this.unbindEvents())
                    }
                    ,
                    c.prototype.unbindEvents = function() {
                        this.img.removeEventListener("load", this),
                        this.img.removeEventListener("error", this)
                    }
                    ,
                    c.prototype.confirm = function(t, e) {
                        this.isLoaded = t,
                        this.emitEvent("progress", [this, this.element, e])
                    }
                    ,
                    a.makeJQueryPlugin = function(e) {
                        (e = e || t.jQuery) && ((n = e).fn.imagesLoaded = function(t, e) {
                            return new a(this,t,e).jqDeferred.promise(n(this))
                        }
                        )
                    }
                    ,
                    a.makeJQueryPlugin(),
                    a
                }(s, t)
            }
            .apply(e, i)) || (t.exports = r)
        }("undefined" != typeof window ? window : this)
    },
    vhPU: function(t, e) {
        t.exports = function(t) {
            if (null == t)
                throw TypeError("Can't call method on  " + t);
            return t
        }
    },
    w2a5: function(t, e, n) {
        var i = n("aCFj")
          , r = n("ne8i")
          , s = n("d/Gc");
        t.exports = function(t) {
            return function(e, n, a) {
                var o, l = i(e), c = r(l.length), h = s(a, c);
                if (t && n != n) {
                    for (; c > h; )
                        if ((o = l[h++]) != o)
                            return !0
                } else
                    for (; c > h; h++)
                        if ((t || h in l) && l[h] === n)
                            return t || h || 0;
                return !t && -1
            }
        }
    },
    xpql: function(t, e, n) {
        t.exports = !n("nh4g") && !n("eeVq")((function() {
            return 7 != Object.defineProperty(n("Iw71")("div"), "a", {
                get: function() {
                    return 7
                }
            }).a
        }
        ))
    },
    y3w9: function(t, e, n) {
        var i = n("0/R4");
        t.exports = function(t) {
            if (!i(t))
                throw TypeError(t + " is not an object!");
            return t
        }
    },
    ylqs: function(t, e) {
        var n = 0
          , i = Math.random();
        t.exports = function(t) {
            return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++n + i).toString(36))
        }
    },
    yt8O: function(t, e, n) {
        "use strict";
        var i = n("nGyu")
          , r = n("1TsA")
          , s = n("hPIQ")
          , a = n("aCFj");
        t.exports = n("Afnz")(Array, "Array", (function(t, e) {
            this._t = a(t),
            this._i = 0,
            this._k = e
        }
        ), (function() {
            var t = this._t
              , e = this._k
              , n = this._i++;
            return !t || n >= t.length ? (this._t = void 0,
            r(1)) : r(0, "keys" == e ? n : "values" == e ? t[n] : [n, t[n]])
        }
        ), "values"),
        s.Arguments = s.Array,
        i("keys"),
        i("values"),
        i("entries")
    },
    zFNl: function(t, e, n) {
        "use strict";
        n.r(e);
        var i = n("VaY2")
          , r = n("rjBh");
        function s(t) {
            return null !== t && "object" == typeof t && "constructor"in t && t.constructor === Object
        }
        function a(t, e) {
            void 0 === t && (t = {}),
            void 0 === e && (e = {}),
            Object.keys(e).forEach((function(n) {
                void 0 === t[n] ? t[n] = e[n] : s(e[n]) && s(t[n]) && Object.keys(e[n]).length > 0 && a(t[n], e[n])
            }
            ))
        }
        var o = {
            body: {},
            addEventListener: function() {},
            removeEventListener: function() {},
            activeElement: {
                blur: function() {},
                nodeName: ""
            },
            querySelector: function() {
                return null
            },
            querySelectorAll: function() {
                return []
            },
            getElementById: function() {
                return null
            },
            createEvent: function() {
                return {
                    initEvent: function() {}
                }
            },
            createElement: function() {
                return {
                    children: [],
                    childNodes: [],
                    style: {},
                    setAttribute: function() {},
                    getElementsByTagName: function() {
                        return []
                    }
                }
            },
            createElementNS: function() {
                return {}
            },
            importNode: function() {
                return null
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            }
        };
        function l() {
            var t = "undefined" != typeof document ? document : {};
            return a(t, o),
            t
        }
        var c = {
            document: o,
            navigator: {
                userAgent: ""
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            },
            history: {
                replaceState: function() {},
                pushState: function() {},
                go: function() {},
                back: function() {}
            },
            CustomEvent: function() {
                return this
            },
            addEventListener: function() {},
            removeEventListener: function() {},
            getComputedStyle: function() {
                return {
                    getPropertyValue: function() {
                        return ""
                    }
                }
            },
            Image: function() {},
            Date: function() {},
            screen: {},
            setTimeout: function() {},
            clearTimeout: function() {},
            matchMedia: function() {
                return {}
            },
            requestAnimationFrame: function(t) {
                return "undefined" == typeof setTimeout ? (t(),
                null) : setTimeout(t, 0)
            },
            cancelAnimationFrame: function(t) {
                "undefined" != typeof setTimeout && clearTimeout(t)
            }
        };
        function h() {
            var t = "undefined" != typeof window ? window : {};
            return a(t, c),
            t
        }
        function u(t) {
            return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }
            )(t)
        }
        function d(t, e) {
            return (d = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e,
                t
            }
            )(t, e)
        }
        function p() {
            if ("undefined" == typeof Reflect || !Reflect.construct)
                return !1;
            if (Reflect.construct.sham)
                return !1;
            if ("function" == typeof Proxy)
                return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}
                ))),
                !0
            } catch (t) {
                return !1
            }
        }
        function f(t, e, n) {
            return (f = p() ? Reflect.construct : function(t, e, n) {
                var i = [null];
                i.push.apply(i, e);
                var r = new (Function.bind.apply(t, i));
                return n && d(r, n.prototype),
                r
            }
            ).apply(null, arguments)
        }
        function m(t) {
            var e = "function" == typeof Map ? new Map : void 0;
            return (m = function(t) {
                if (null === t || (n = t,
                -1 === Function.toString.call(n).indexOf("[native code]")))
                    return t;
                var n;
                if ("function" != typeof t)
                    throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== e) {
                    if (e.has(t))
                        return e.get(t);
                    e.set(t, i)
                }
                function i() {
                    return f(t, arguments, u(this).constructor)
                }
                return i.prototype = Object.create(t.prototype, {
                    constructor: {
                        value: i,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }),
                d(i, t)
            }
            )(t)
        }
        var g = function(t) {
            var e, n;
            function i(e) {
                var n, i, r;
                return n = t.call.apply(t, [this].concat(e)) || this,
                i = function(t) {
                    if (void 0 === t)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }(n),
                r = i.__proto__,
                Object.defineProperty(i, "__proto__", {
                    get: function() {
                        return r
                    },
                    set: function(t) {
                        r.__proto__ = t
                    }
                }),
                n
            }
            return n = t,
            (e = i).prototype = Object.create(n.prototype),
            e.prototype.constructor = e,
            e.__proto__ = n,
            i
        }(m(Array));
        function v(t) {
            void 0 === t && (t = []);
            var e = [];
            return t.forEach((function(t) {
                Array.isArray(t) ? e.push.apply(e, v(t)) : e.push(t)
            }
            )),
            e
        }
        function y(t, e) {
            return Array.prototype.filter.call(t, e)
        }
        function x(t, e) {
            var n = h()
              , i = l()
              , r = [];
            if (!e && t instanceof g)
                return t;
            if (!t)
                return new g(r);
            if ("string" == typeof t) {
                var s = t.trim();
                if (s.indexOf("<") >= 0 && s.indexOf(">") >= 0) {
                    var a = "div";
                    0 === s.indexOf("<li") && (a = "ul"),
                    0 === s.indexOf("<tr") && (a = "tbody"),
                    0 !== s.indexOf("<td") && 0 !== s.indexOf("<th") || (a = "tr"),
                    0 === s.indexOf("<tbody") && (a = "table"),
                    0 === s.indexOf("<option") && (a = "select");
                    var o = i.createElement(a);
                    o.innerHTML = s;
                    for (var c = 0; c < o.childNodes.length; c += 1)
                        r.push(o.childNodes[c])
                } else
                    r = function(t, e) {
                        if ("string" != typeof t)
                            return [t];
                        for (var n = [], i = e.querySelectorAll(t), r = 0; r < i.length; r += 1)
                            n.push(i[r]);
                        return n
                    }(t.trim(), e || i)
            } else if (t.nodeType || t === n || t === i)
                r.push(t);
            else if (Array.isArray(t)) {
                if (t instanceof g)
                    return t;
                r = t
            }
            return new g(function(t) {
                for (var e = [], n = 0; n < t.length; n += 1)
                    -1 === e.indexOf(t[n]) && e.push(t[n]);
                return e
            }(r))
        }
        x.fn = g.prototype;
        var _ = "resize scroll".split(" ");
        function w(t) {
            return function() {
                for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++)
                    n[i] = arguments[i];
                if (void 0 === n[0]) {
                    for (var r = 0; r < this.length; r += 1)
                        _.indexOf(t) < 0 && (t in this[r] ? this[r][t]() : x(this[r]).trigger(t));
                    return this
                }
                return this.on.apply(this, [t].concat(n))
            }
        }
        w("click"),
        w("blur"),
        w("focus"),
        w("focusin"),
        w("focusout"),
        w("keyup"),
        w("keydown"),
        w("keypress"),
        w("submit"),
        w("change"),
        w("mousedown"),
        w("mousemove"),
        w("mouseup"),
        w("mouseenter"),
        w("mouseleave"),
        w("mouseout"),
        w("mouseover"),
        w("touchstart"),
        w("touchend"),
        w("touchmove"),
        w("resize"),
        w("scroll");
        var b = {
            addClass: function() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                    e[n] = arguments[n];
                var i = v(e.map((function(t) {
                    return t.split(" ")
                }
                )));
                return this.forEach((function(t) {
                    var e;
                    (e = t.classList).add.apply(e, i)
                }
                )),
                this
            },
            removeClass: function() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                    e[n] = arguments[n];
                var i = v(e.map((function(t) {
                    return t.split(" ")
                }
                )));
                return this.forEach((function(t) {
                    var e;
                    (e = t.classList).remove.apply(e, i)
                }
                )),
                this
            },
            hasClass: function() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                    e[n] = arguments[n];
                var i = v(e.map((function(t) {
                    return t.split(" ")
                }
                )));
                return y(this, (function(t) {
                    return i.filter((function(e) {
                        return t.classList.contains(e)
                    }
                    )).length > 0
                }
                )).length > 0
            },
            toggleClass: function() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                    e[n] = arguments[n];
                var i = v(e.map((function(t) {
                    return t.split(" ")
                }
                )));
                this.forEach((function(t) {
                    i.forEach((function(e) {
                        t.classList.toggle(e)
                    }
                    ))
                }
                ))
            },
            attr: function(t, e) {
                if (1 === arguments.length && "string" == typeof t)
                    return this[0] ? this[0].getAttribute(t) : void 0;
                for (var n = 0; n < this.length; n += 1)
                    if (2 === arguments.length)
                        this[n].setAttribute(t, e);
                    else
                        for (var i in t)
                            this[n][i] = t[i],
                            this[n].setAttribute(i, t[i]);
                return this
            },
            removeAttr: function(t) {
                for (var e = 0; e < this.length; e += 1)
                    this[e].removeAttribute(t);
                return this
            },
            transform: function(t) {
                for (var e = 0; e < this.length; e += 1)
                    this[e].style.transform = t;
                return this
            },
            transition: function(t) {
                for (var e = 0; e < this.length; e += 1)
                    this[e].style.transitionDuration = "string" != typeof t ? t + "ms" : t;
                return this
            },
            on: function() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                    e[n] = arguments[n];
                var i = e[0]
                  , r = e[1]
                  , s = e[2]
                  , a = e[3];
                function o(t) {
                    var e = t.target;
                    if (e) {
                        var n = t.target.dom7EventData || [];
                        if (n.indexOf(t) < 0 && n.unshift(t),
                        x(e).is(r))
                            s.apply(e, n);
                        else
                            for (var i = x(e).parents(), a = 0; a < i.length; a += 1)
                                x(i[a]).is(r) && s.apply(i[a], n)
                    }
                }
                function l(t) {
                    var e = t && t.target && t.target.dom7EventData || [];
                    e.indexOf(t) < 0 && e.unshift(t),
                    s.apply(this, e)
                }
                "function" == typeof e[1] && (i = e[0],
                s = e[1],
                a = e[2],
                r = void 0),
                a || (a = !1);
                for (var c, h = i.split(" "), u = 0; u < this.length; u += 1) {
                    var d = this[u];
                    if (r)
                        for (c = 0; c < h.length; c += 1) {
                            var p = h[c];
                            d.dom7LiveListeners || (d.dom7LiveListeners = {}),
                            d.dom7LiveListeners[p] || (d.dom7LiveListeners[p] = []),
                            d.dom7LiveListeners[p].push({
                                listener: s,
                                proxyListener: o
                            }),
                            d.addEventListener(p, o, a)
                        }
                    else
                        for (c = 0; c < h.length; c += 1) {
                            var f = h[c];
                            d.dom7Listeners || (d.dom7Listeners = {}),
                            d.dom7Listeners[f] || (d.dom7Listeners[f] = []),
                            d.dom7Listeners[f].push({
                                listener: s,
                                proxyListener: l
                            }),
                            d.addEventListener(f, l, a)
                        }
                }
                return this
            },
            off: function() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                    e[n] = arguments[n];
                var i = e[0]
                  , r = e[1]
                  , s = e[2]
                  , a = e[3];
                "function" == typeof e[1] && (i = e[0],
                s = e[1],
                a = e[2],
                r = void 0),
                a || (a = !1);
                for (var o = i.split(" "), l = 0; l < o.length; l += 1)
                    for (var c = o[l], h = 0; h < this.length; h += 1) {
                        var u = this[h]
                          , d = void 0;
                        if (!r && u.dom7Listeners ? d = u.dom7Listeners[c] : r && u.dom7LiveListeners && (d = u.dom7LiveListeners[c]),
                        d && d.length)
                            for (var p = d.length - 1; p >= 0; p -= 1) {
                                var f = d[p];
                                s && f.listener === s || s && f.listener && f.listener.dom7proxy && f.listener.dom7proxy === s ? (u.removeEventListener(c, f.proxyListener, a),
                                d.splice(p, 1)) : s || (u.removeEventListener(c, f.proxyListener, a),
                                d.splice(p, 1))
                            }
                    }
                return this
            },
            trigger: function() {
                for (var t = h(), e = arguments.length, n = new Array(e), i = 0; i < e; i++)
                    n[i] = arguments[i];
                for (var r = n[0].split(" "), s = n[1], a = 0; a < r.length; a += 1)
                    for (var o = r[a], l = 0; l < this.length; l += 1) {
                        var c = this[l];
                        if (t.CustomEvent) {
                            var u = new t.CustomEvent(o,{
                                detail: s,
                                bubbles: !0,
                                cancelable: !0
                            });
                            c.dom7EventData = n.filter((function(t, e) {
                                return e > 0
                            }
                            )),
                            c.dispatchEvent(u),
                            c.dom7EventData = [],
                            delete c.dom7EventData
                        }
                    }
                return this
            },
            transitionEnd: function(t) {
                var e = this;
                return t && e.on("transitionend", (function n(i) {
                    i.target === this && (t.call(this, i),
                    e.off("transitionend", n))
                }
                )),
                this
            },
            outerWidth: function(t) {
                if (this.length > 0) {
                    if (t) {
                        var e = this.styles();
                        return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left"))
                    }
                    return this[0].offsetWidth
                }
                return null
            },
            outerHeight: function(t) {
                if (this.length > 0) {
                    if (t) {
                        var e = this.styles();
                        return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom"))
                    }
                    return this[0].offsetHeight
                }
                return null
            },
            styles: function() {
                var t = h();
                return this[0] ? t.getComputedStyle(this[0], null) : {}
            },
            offset: function() {
                if (this.length > 0) {
                    var t = h()
                      , e = l()
                      , n = this[0]
                      , i = n.getBoundingClientRect()
                      , r = e.body
                      , s = n.clientTop || r.clientTop || 0
                      , a = n.clientLeft || r.clientLeft || 0
                      , o = n === t ? t.scrollY : n.scrollTop
                      , c = n === t ? t.scrollX : n.scrollLeft;
                    return {
                        top: i.top + o - s,
                        left: i.left + c - a
                    }
                }
                return null
            },
            css: function(t, e) {
                var n, i = h();
                if (1 === arguments.length) {
                    if ("string" != typeof t) {
                        for (n = 0; n < this.length; n += 1)
                            for (var r in t)
                                this[n].style[r] = t[r];
                        return this
                    }
                    if (this[0])
                        return i.getComputedStyle(this[0], null).getPropertyValue(t)
                }
                if (2 === arguments.length && "string" == typeof t) {
                    for (n = 0; n < this.length; n += 1)
                        this[n].style[t] = e;
                    return this
                }
                return this
            },
            each: function(t) {
                return t ? (this.forEach((function(e, n) {
                    t.apply(e, [e, n])
                }
                )),
                this) : this
            },
            html: function(t) {
                if (void 0 === t)
                    return this[0] ? this[0].innerHTML : null;
                for (var e = 0; e < this.length; e += 1)
                    this[e].innerHTML = t;
                return this
            },
            text: function(t) {
                if (void 0 === t)
                    return this[0] ? this[0].textContent.trim() : null;
                for (var e = 0; e < this.length; e += 1)
                    this[e].textContent = t;
                return this
            },
            is: function(t) {
                var e, n, i = h(), r = l(), s = this[0];
                if (!s || void 0 === t)
                    return !1;
                if ("string" == typeof t) {
                    if (s.matches)
                        return s.matches(t);
                    if (s.webkitMatchesSelector)
                        return s.webkitMatchesSelector(t);
                    if (s.msMatchesSelector)
                        return s.msMatchesSelector(t);
                    for (e = x(t),
                    n = 0; n < e.length; n += 1)
                        if (e[n] === s)
                            return !0;
                    return !1
                }
                if (t === r)
                    return s === r;
                if (t === i)
                    return s === i;
                if (t.nodeType || t instanceof g) {
                    for (e = t.nodeType ? [t] : t,
                    n = 0; n < e.length; n += 1)
                        if (e[n] === s)
                            return !0;
                    return !1
                }
                return !1
            },
            index: function() {
                var t, e = this[0];
                if (e) {
                    for (t = 0; null !== (e = e.previousSibling); )
                        1 === e.nodeType && (t += 1);
                    return t
                }
            },
            eq: function(t) {
                if (void 0 === t)
                    return this;
                var e = this.length;
                if (t > e - 1)
                    return x([]);
                if (t < 0) {
                    var n = e + t;
                    return x(n < 0 ? [] : [this[n]])
                }
                return x([this[t]])
            },
            append: function() {
                for (var t, e = l(), n = 0; n < arguments.length; n += 1) {
                    t = n < 0 || arguments.length <= n ? void 0 : arguments[n];
                    for (var i = 0; i < this.length; i += 1)
                        if ("string" == typeof t) {
                            var r = e.createElement("div");
                            for (r.innerHTML = t; r.firstChild; )
                                this[i].appendChild(r.firstChild)
                        } else if (t instanceof g)
                            for (var s = 0; s < t.length; s += 1)
                                this[i].appendChild(t[s]);
                        else
                            this[i].appendChild(t)
                }
                return this
            },
            prepend: function(t) {
                var e, n, i = l();
                for (e = 0; e < this.length; e += 1)
                    if ("string" == typeof t) {
                        var r = i.createElement("div");
                        for (r.innerHTML = t,
                        n = r.childNodes.length - 1; n >= 0; n -= 1)
                            this[e].insertBefore(r.childNodes[n], this[e].childNodes[0])
                    } else if (t instanceof g)
                        for (n = 0; n < t.length; n += 1)
                            this[e].insertBefore(t[n], this[e].childNodes[0]);
                    else
                        this[e].insertBefore(t, this[e].childNodes[0]);
                return this
            },
            next: function(t) {
                return this.length > 0 ? t ? this[0].nextElementSibling && x(this[0].nextElementSibling).is(t) ? x([this[0].nextElementSibling]) : x([]) : this[0].nextElementSibling ? x([this[0].nextElementSibling]) : x([]) : x([])
            },
            nextAll: function(t) {
                var e = []
                  , n = this[0];
                if (!n)
                    return x([]);
                for (; n.nextElementSibling; ) {
                    var i = n.nextElementSibling;
                    t ? x(i).is(t) && e.push(i) : e.push(i),
                    n = i
                }
                return x(e)
            },
            prev: function(t) {
                if (this.length > 0) {
                    var e = this[0];
                    return t ? e.previousElementSibling && x(e.previousElementSibling).is(t) ? x([e.previousElementSibling]) : x([]) : e.previousElementSibling ? x([e.previousElementSibling]) : x([])
                }
                return x([])
            },
            prevAll: function(t) {
                var e = []
                  , n = this[0];
                if (!n)
                    return x([]);
                for (; n.previousElementSibling; ) {
                    var i = n.previousElementSibling;
                    t ? x(i).is(t) && e.push(i) : e.push(i),
                    n = i
                }
                return x(e)
            },
            parent: function(t) {
                for (var e = [], n = 0; n < this.length; n += 1)
                    null !== this[n].parentNode && (t ? x(this[n].parentNode).is(t) && e.push(this[n].parentNode) : e.push(this[n].parentNode));
                return x(e)
            },
            parents: function(t) {
                for (var e = [], n = 0; n < this.length; n += 1)
                    for (var i = this[n].parentNode; i; )
                        t ? x(i).is(t) && e.push(i) : e.push(i),
                        i = i.parentNode;
                return x(e)
            },
            closest: function(t) {
                var e = this;
                return void 0 === t ? x([]) : (e.is(t) || (e = e.parents(t).eq(0)),
                e)
            },
            find: function(t) {
                for (var e = [], n = 0; n < this.length; n += 1)
                    for (var i = this[n].querySelectorAll(t), r = 0; r < i.length; r += 1)
                        e.push(i[r]);
                return x(e)
            },
            children: function(t) {
                for (var e = [], n = 0; n < this.length; n += 1)
                    for (var i = this[n].children, r = 0; r < i.length; r += 1)
                        t && !x(i[r]).is(t) || e.push(i[r]);
                return x(e)
            },
            filter: function(t) {
                return x(y(this, t))
            },
            remove: function() {
                for (var t = 0; t < this.length; t += 1)
                    this[t].parentNode && this[t].parentNode.removeChild(this[t]);
                return this
            }
        };
        Object.keys(b).forEach((function(t) {
            Object.defineProperty(x.fn, t, {
                value: b[t],
                writable: !0
            })
        }
        ));
        var M, S, T, E = x;
        function L(t, e) {
            return void 0 === e && (e = 0),
            setTimeout(t, e)
        }
        function A() {
            return Date.now()
        }
        function C(t, e) {
            void 0 === e && (e = "x");
            var n, i, r, s = h(), a = function(t) {
                var e, n = h();
                return n.getComputedStyle && (e = n.getComputedStyle(t, null)),
                !e && t.currentStyle && (e = t.currentStyle),
                e || (e = t.style),
                e
            }(t);
            return s.WebKitCSSMatrix ? ((i = a.transform || a.webkitTransform).split(",").length > 6 && (i = i.split(", ").map((function(t) {
                return t.replace(",", ".")
            }
            )).join(", ")),
            r = new s.WebKitCSSMatrix("none" === i ? "" : i)) : n = (r = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,")).toString().split(","),
            "x" === e && (i = s.WebKitCSSMatrix ? r.m41 : 16 === n.length ? parseFloat(n[12]) : parseFloat(n[4])),
            "y" === e && (i = s.WebKitCSSMatrix ? r.m42 : 16 === n.length ? parseFloat(n[13]) : parseFloat(n[5])),
            i || 0
        }
        function P(t) {
            return "object" == typeof t && null !== t && t.constructor && "Object" === Object.prototype.toString.call(t).slice(8, -1)
        }
        function R() {
            for (var t = Object(arguments.length <= 0 ? void 0 : arguments[0]), e = ["__proto__", "constructor", "prototype"], n = 1; n < arguments.length; n += 1) {
                var i = n < 0 || arguments.length <= n ? void 0 : arguments[n];
                if (null != i)
                    for (var r = Object.keys(Object(i)).filter((function(t) {
                        return e.indexOf(t) < 0
                    }
                    )), s = 0, a = r.length; s < a; s += 1) {
                        var o = r[s]
                          , l = Object.getOwnPropertyDescriptor(i, o);
                        void 0 !== l && l.enumerable && (P(t[o]) && P(i[o]) ? i[o].__swiper__ ? t[o] = i[o] : R(t[o], i[o]) : !P(t[o]) && P(i[o]) ? (t[o] = {},
                        i[o].__swiper__ ? t[o] = i[o] : R(t[o], i[o])) : t[o] = i[o])
                    }
            }
            return t
        }
        function I(t, e) {
            Object.keys(e).forEach((function(n) {
                P(e[n]) && Object.keys(e[n]).forEach((function(i) {
                    "function" == typeof e[n][i] && (e[n][i] = e[n][i].bind(t))
                }
                )),
                t[n] = e[n]
            }
            ))
        }
        function D() {
            return M || (M = function() {
                var t = h()
                  , e = l();
                return {
                    touch: !!("ontouchstart"in t || t.DocumentTouch && e instanceof t.DocumentTouch),
                    pointerEvents: !!t.PointerEvent && "maxTouchPoints"in t.navigator && t.navigator.maxTouchPoints >= 0,
                    observer: "MutationObserver"in t || "WebkitMutationObserver"in t,
                    passiveListener: function() {
                        var e = !1;
                        try {
                            var n = Object.defineProperty({}, "passive", {
                                get: function() {
                                    e = !0
                                }
                            });
                            t.addEventListener("testPassiveListener", null, n)
                        } catch (t) {}
                        return e
                    }(),
                    gestures: "ongesturestart"in t
                }
            }()),
            M
        }
        function N(t) {
            return void 0 === t && (t = {}),
            S || (S = function(t) {
                var e = (void 0 === t ? {} : t).userAgent
                  , n = D()
                  , i = h()
                  , r = i.navigator.platform
                  , s = e || i.navigator.userAgent
                  , a = {
                    ios: !1,
                    android: !1
                }
                  , o = i.screen.width
                  , l = i.screen.height
                  , c = s.match(/(Android);?[\s\/]+([\d.]+)?/)
                  , u = s.match(/(iPad).*OS\s([\d_]+)/)
                  , d = s.match(/(iPod)(.*OS\s([\d_]+))?/)
                  , p = !u && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
                  , f = "Win32" === r
                  , m = "MacIntel" === r;
                return !u && m && n.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(o + "x" + l) >= 0 && ((u = s.match(/(Version)\/([\d.]+)/)) || (u = [0, 1, "13_0_0"]),
                m = !1),
                c && !f && (a.os = "android",
                a.android = !0),
                (u || p || d) && (a.os = "ios",
                a.ios = !0),
                a
            }(t)),
            S
        }
        function O() {
            return T || (T = function() {
                var t, e = h();
                return {
                    isEdge: !!e.navigator.userAgent.match(/Edge/g),
                    isSafari: (t = e.navigator.userAgent.toLowerCase(),
                    t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0),
                    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
                }
            }()),
            T
        }
        var z = {
            name: "resize",
            create: function() {
                var t = this;
                R(t, {
                    resize: {
                        observer: null,
                        createObserver: function() {
                            t && !t.destroyed && t.initialized && (t.resize.observer = new ResizeObserver((function(e) {
                                var n = t.width
                                  , i = t.height
                                  , r = n
                                  , s = i;
                                e.forEach((function(e) {
                                    var n = e.contentBoxSize
                                      , i = e.contentRect
                                      , a = e.target;
                                    a && a !== t.el || (r = i ? i.width : (n[0] || n).inlineSize,
                                    s = i ? i.height : (n[0] || n).blockSize)
                                }
                                )),
                                r === n && s === i || t.resize.resizeHandler()
                            }
                            )),
                            t.resize.observer.observe(t.el))
                        },
                        removeObserver: function() {
                            t.resize.observer && t.resize.observer.unobserve && t.el && (t.resize.observer.unobserve(t.el),
                            t.resize.observer = null)
                        },
                        resizeHandler: function() {
                            t && !t.destroyed && t.initialized && (t.emit("beforeResize"),
                            t.emit("resize"))
                        },
                        orientationChangeHandler: function() {
                            t && !t.destroyed && t.initialized && t.emit("orientationchange")
                        }
                    }
                })
            },
            on: {
                init: function(t) {
                    var e = h();
                    t.params.resizeObserver && void 0 !== h().ResizeObserver ? t.resize.createObserver() : (e.addEventListener("resize", t.resize.resizeHandler),
                    e.addEventListener("orientationchange", t.resize.orientationChangeHandler))
                },
                destroy: function(t) {
                    var e = h();
                    t.resize.removeObserver(),
                    e.removeEventListener("resize", t.resize.resizeHandler),
                    e.removeEventListener("orientationchange", t.resize.orientationChangeHandler)
                }
            }
        };
        function B() {
            return (B = Object.assign || function(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var n = arguments[e];
                    for (var i in n)
                        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
                }
                return t
            }
            ).apply(this, arguments)
        }
        var k = {
            attach: function(t, e) {
                void 0 === e && (e = {});
                var n = h()
                  , i = this
                  , r = new (n.MutationObserver || n.WebkitMutationObserver)((function(t) {
                    if (1 !== t.length) {
                        var e = function() {
                            i.emit("observerUpdate", t[0])
                        };
                        n.requestAnimationFrame ? n.requestAnimationFrame(e) : n.setTimeout(e, 0)
                    } else
                        i.emit("observerUpdate", t[0])
                }
                ));
                r.observe(t, {
                    attributes: void 0 === e.attributes || e.attributes,
                    childList: void 0 === e.childList || e.childList,
                    characterData: void 0 === e.characterData || e.characterData
                }),
                i.observer.observers.push(r)
            },
            init: function() {
                if (this.support.observer && this.params.observer) {
                    if (this.params.observeParents)
                        for (var t = this.$el.parents(), e = 0; e < t.length; e += 1)
                            this.observer.attach(t[e]);
                    this.observer.attach(this.$el[0], {
                        childList: this.params.observeSlideChildren
                    }),
                    this.observer.attach(this.$wrapperEl[0], {
                        attributes: !1
                    })
                }
            },
            destroy: function() {
                this.observer.observers.forEach((function(t) {
                    t.disconnect()
                }
                )),
                this.observer.observers = []
            }
        }
          , F = {
            name: "observer",
            params: {
                observer: !1,
                observeParents: !1,
                observeSlideChildren: !1
            },
            create: function() {
                I(this, {
                    observer: B({}, k, {
                        observers: []
                    })
                })
            },
            on: {
                init: function(t) {
                    t.observer.init()
                },
                destroy: function(t) {
                    t.observer.destroy()
                }
            }
        };
        function H(t) {
            var e = l()
              , n = h()
              , i = this.touchEventsData
              , r = this.params
              , s = this.touches;
            if (!this.animating || !r.preventInteractionOnTransition) {
                var a = t;
                a.originalEvent && (a = a.originalEvent);
                var o = E(a.target);
                if ("wrapper" !== r.touchEventsTarget || o.closest(this.wrapperEl).length)
                    if (i.isTouchEvent = "touchstart" === a.type,
                    i.isTouchEvent || !("which"in a) || 3 !== a.which)
                        if (!(!i.isTouchEvent && "button"in a && a.button > 0))
                            if (!i.isTouched || !i.isMoved)
                                if (!!r.noSwipingClass && "" !== r.noSwipingClass && a.target && a.target.shadowRoot && t.path && t.path[0] && (o = E(t.path[0])),
                                r.noSwiping && o.closest(r.noSwipingSelector ? r.noSwipingSelector : "." + r.noSwipingClass)[0])
                                    this.allowClick = !0;
                                else if (!r.swipeHandler || o.closest(r.swipeHandler)[0]) {
                                    s.currentX = "touchstart" === a.type ? a.targetTouches[0].pageX : a.pageX,
                                    s.currentY = "touchstart" === a.type ? a.targetTouches[0].pageY : a.pageY;
                                    var c = s.currentX
                                      , u = s.currentY
                                      , d = r.edgeSwipeDetection || r.iOSEdgeSwipeDetection
                                      , p = r.edgeSwipeThreshold || r.iOSEdgeSwipeThreshold;
                                    if (d && (c <= p || c >= n.innerWidth - p)) {
                                        if ("prevent" !== d)
                                            return;
                                        t.preventDefault()
                                    }
                                    if (R(i, {
                                        isTouched: !0,
                                        isMoved: !1,
                                        allowTouchCallbacks: !0,
                                        isScrolling: void 0,
                                        startMoving: void 0
                                    }),
                                    s.startX = c,
                                    s.startY = u,
                                    i.touchStartTime = A(),
                                    this.allowClick = !0,
                                    this.updateSize(),
                                    this.swipeDirection = void 0,
                                    r.threshold > 0 && (i.allowThresholdMove = !1),
                                    "touchstart" !== a.type) {
                                        var f = !0;
                                        o.is(i.formElements) && (f = !1),
                                        e.activeElement && E(e.activeElement).is(i.formElements) && e.activeElement !== o[0] && e.activeElement.blur();
                                        var m = f && this.allowTouchMove && r.touchStartPreventDefault;
                                        !r.touchStartForcePreventDefault && !m || o[0].isContentEditable || a.preventDefault()
                                    }
                                    this.emit("touchStart", a)
                                }
            }
        }
        function U(t) {
            var e = l()
              , n = this.touchEventsData
              , i = this.params
              , r = this.touches
              , s = this.rtlTranslate
              , a = t;
            if (a.originalEvent && (a = a.originalEvent),
            n.isTouched) {
                if (!n.isTouchEvent || "touchmove" === a.type) {
                    var o = "touchmove" === a.type && a.targetTouches && (a.targetTouches[0] || a.changedTouches[0])
                      , c = "touchmove" === a.type ? o.pageX : a.pageX
                      , h = "touchmove" === a.type ? o.pageY : a.pageY;
                    if (a.preventedByNestedSwiper)
                        return r.startX = c,
                        void (r.startY = h);
                    if (!this.allowTouchMove)
                        return this.allowClick = !1,
                        void (n.isTouched && (R(r, {
                            startX: c,
                            startY: h,
                            currentX: c,
                            currentY: h
                        }),
                        n.touchStartTime = A()));
                    if (n.isTouchEvent && i.touchReleaseOnEdges && !i.loop)
                        if (this.isVertical()) {
                            if (h < r.startY && this.translate <= this.maxTranslate() || h > r.startY && this.translate >= this.minTranslate())
                                return n.isTouched = !1,
                                void (n.isMoved = !1)
                        } else if (c < r.startX && this.translate <= this.maxTranslate() || c > r.startX && this.translate >= this.minTranslate())
                            return;
                    if (n.isTouchEvent && e.activeElement && a.target === e.activeElement && E(a.target).is(n.formElements))
                        return n.isMoved = !0,
                        void (this.allowClick = !1);
                    if (n.allowTouchCallbacks && this.emit("touchMove", a),
                    !(a.targetTouches && a.targetTouches.length > 1)) {
                        r.currentX = c,
                        r.currentY = h;
                        var u = r.currentX - r.startX
                          , d = r.currentY - r.startY;
                        if (!(this.params.threshold && Math.sqrt(Math.pow(u, 2) + Math.pow(d, 2)) < this.params.threshold)) {
                            var p;
                            if (void 0 === n.isScrolling)
                                this.isHorizontal() && r.currentY === r.startY || this.isVertical() && r.currentX === r.startX ? n.isScrolling = !1 : u * u + d * d >= 25 && (p = 180 * Math.atan2(Math.abs(d), Math.abs(u)) / Math.PI,
                                n.isScrolling = this.isHorizontal() ? p > i.touchAngle : 90 - p > i.touchAngle);
                            if (n.isScrolling && this.emit("touchMoveOpposite", a),
                            void 0 === n.startMoving && (r.currentX === r.startX && r.currentY === r.startY || (n.startMoving = !0)),
                            n.isScrolling)
                                n.isTouched = !1;
                            else if (n.startMoving) {
                                this.allowClick = !1,
                                !i.cssMode && a.cancelable && a.preventDefault(),
                                i.touchMoveStopPropagation && !i.nested && a.stopPropagation(),
                                n.isMoved || (i.loop && this.loopFix(),
                                n.startTranslate = this.getTranslate(),
                                this.setTransition(0),
                                this.animating && this.$wrapperEl.trigger("webkitTransitionEnd transitionend"),
                                n.allowMomentumBounce = !1,
                                !i.grabCursor || !0 !== this.allowSlideNext && !0 !== this.allowSlidePrev || this.setGrabCursor(!0),
                                this.emit("sliderFirstMove", a)),
                                this.emit("sliderMove", a),
                                n.isMoved = !0;
                                var f = this.isHorizontal() ? u : d;
                                r.diff = f,
                                f *= i.touchRatio,
                                s && (f = -f),
                                this.swipeDirection = f > 0 ? "prev" : "next",
                                n.currentTranslate = f + n.startTranslate;
                                var m = !0
                                  , g = i.resistanceRatio;
                                if (i.touchReleaseOnEdges && (g = 0),
                                f > 0 && n.currentTranslate > this.minTranslate() ? (m = !1,
                                i.resistance && (n.currentTranslate = this.minTranslate() - 1 + Math.pow(-this.minTranslate() + n.startTranslate + f, g))) : f < 0 && n.currentTranslate < this.maxTranslate() && (m = !1,
                                i.resistance && (n.currentTranslate = this.maxTranslate() + 1 - Math.pow(this.maxTranslate() - n.startTranslate - f, g))),
                                m && (a.preventedByNestedSwiper = !0),
                                !this.allowSlideNext && "next" === this.swipeDirection && n.currentTranslate < n.startTranslate && (n.currentTranslate = n.startTranslate),
                                !this.allowSlidePrev && "prev" === this.swipeDirection && n.currentTranslate > n.startTranslate && (n.currentTranslate = n.startTranslate),
                                this.allowSlidePrev || this.allowSlideNext || (n.currentTranslate = n.startTranslate),
                                i.threshold > 0) {
                                    if (!(Math.abs(f) > i.threshold || n.allowThresholdMove))
                                        return void (n.currentTranslate = n.startTranslate);
                                    if (!n.allowThresholdMove)
                                        return n.allowThresholdMove = !0,
                                        r.startX = r.currentX,
                                        r.startY = r.currentY,
                                        n.currentTranslate = n.startTranslate,
                                        void (r.diff = this.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY)
                                }
                                i.followFinger && !i.cssMode && ((i.freeMode || i.watchSlidesProgress || i.watchSlidesVisibility) && (this.updateActiveIndex(),
                                this.updateSlidesClasses()),
                                i.freeMode && (0 === n.velocities.length && n.velocities.push({
                                    position: r[this.isHorizontal() ? "startX" : "startY"],
                                    time: n.touchStartTime
                                }),
                                n.velocities.push({
                                    position: r[this.isHorizontal() ? "currentX" : "currentY"],
                                    time: A()
                                })),
                                this.updateProgress(n.currentTranslate),
                                this.setTranslate(n.currentTranslate))
                            }
                        }
                    }
                }
            } else
                n.startMoving && n.isScrolling && this.emit("touchMoveOpposite", a)
        }
        function G(t) {
            var e = this
              , n = e.touchEventsData
              , i = e.params
              , r = e.touches
              , s = e.rtlTranslate
              , a = e.$wrapperEl
              , o = e.slidesGrid
              , l = e.snapGrid
              , c = t;
            if (c.originalEvent && (c = c.originalEvent),
            n.allowTouchCallbacks && e.emit("touchEnd", c),
            n.allowTouchCallbacks = !1,
            !n.isTouched)
                return n.isMoved && i.grabCursor && e.setGrabCursor(!1),
                n.isMoved = !1,
                void (n.startMoving = !1);
            i.grabCursor && n.isMoved && n.isTouched && (!0 === e.allowSlideNext || !0 === e.allowSlidePrev) && e.setGrabCursor(!1);
            var h, u = A(), d = u - n.touchStartTime;
            if (e.allowClick && (e.updateClickedSlide(c),
            e.emit("tap click", c),
            d < 300 && u - n.lastClickTime < 300 && e.emit("doubleTap doubleClick", c)),
            n.lastClickTime = A(),
            L((function() {
                e.destroyed || (e.allowClick = !0)
            }
            )),
            !n.isTouched || !n.isMoved || !e.swipeDirection || 0 === r.diff || n.currentTranslate === n.startTranslate)
                return n.isTouched = !1,
                n.isMoved = !1,
                void (n.startMoving = !1);
            if (n.isTouched = !1,
            n.isMoved = !1,
            n.startMoving = !1,
            h = i.followFinger ? s ? e.translate : -e.translate : -n.currentTranslate,
            !i.cssMode)
                if (i.freeMode) {
                    if (h < -e.minTranslate())
                        return void e.slideTo(e.activeIndex);
                    if (h > -e.maxTranslate())
                        return void (e.slides.length < l.length ? e.slideTo(l.length - 1) : e.slideTo(e.slides.length - 1));
                    if (i.freeModeMomentum) {
                        if (n.velocities.length > 1) {
                            var p = n.velocities.pop()
                              , f = n.velocities.pop()
                              , m = p.position - f.position
                              , g = p.time - f.time;
                            e.velocity = m / g,
                            e.velocity /= 2,
                            Math.abs(e.velocity) < i.freeModeMinimumVelocity && (e.velocity = 0),
                            (g > 150 || A() - p.time > 300) && (e.velocity = 0)
                        } else
                            e.velocity = 0;
                        e.velocity *= i.freeModeMomentumVelocityRatio,
                        n.velocities.length = 0;
                        var v = 1e3 * i.freeModeMomentumRatio
                          , y = e.velocity * v
                          , x = e.translate + y;
                        s && (x = -x);
                        var _, w, b = !1, M = 20 * Math.abs(e.velocity) * i.freeModeMomentumBounceRatio;
                        if (x < e.maxTranslate())
                            i.freeModeMomentumBounce ? (x + e.maxTranslate() < -M && (x = e.maxTranslate() - M),
                            _ = e.maxTranslate(),
                            b = !0,
                            n.allowMomentumBounce = !0) : x = e.maxTranslate(),
                            i.loop && i.centeredSlides && (w = !0);
                        else if (x > e.minTranslate())
                            i.freeModeMomentumBounce ? (x - e.minTranslate() > M && (x = e.minTranslate() + M),
                            _ = e.minTranslate(),
                            b = !0,
                            n.allowMomentumBounce = !0) : x = e.minTranslate(),
                            i.loop && i.centeredSlides && (w = !0);
                        else if (i.freeModeSticky) {
                            for (var S, T = 0; T < l.length; T += 1)
                                if (l[T] > -x) {
                                    S = T;
                                    break
                                }
                            x = -(x = Math.abs(l[S] - x) < Math.abs(l[S - 1] - x) || "next" === e.swipeDirection ? l[S] : l[S - 1])
                        }
                        if (w && e.once("transitionEnd", (function() {
                            e.loopFix()
                        }
                        )),
                        0 !== e.velocity) {
                            if (v = s ? Math.abs((-x - e.translate) / e.velocity) : Math.abs((x - e.translate) / e.velocity),
                            i.freeModeSticky) {
                                var E = Math.abs((s ? -x : x) - e.translate)
                                  , C = e.slidesSizesGrid[e.activeIndex];
                                v = E < C ? i.speed : E < 2 * C ? 1.5 * i.speed : 2.5 * i.speed
                            }
                        } else if (i.freeModeSticky)
                            return void e.slideToClosest();
                        i.freeModeMomentumBounce && b ? (e.updateProgress(_),
                        e.setTransition(v),
                        e.setTranslate(x),
                        e.transitionStart(!0, e.swipeDirection),
                        e.animating = !0,
                        a.transitionEnd((function() {
                            e && !e.destroyed && n.allowMomentumBounce && (e.emit("momentumBounce"),
                            e.setTransition(i.speed),
                            setTimeout((function() {
                                e.setTranslate(_),
                                a.transitionEnd((function() {
                                    e && !e.destroyed && e.transitionEnd()
                                }
                                ))
                            }
                            ), 0))
                        }
                        ))) : e.velocity ? (e.updateProgress(x),
                        e.setTransition(v),
                        e.setTranslate(x),
                        e.transitionStart(!0, e.swipeDirection),
                        e.animating || (e.animating = !0,
                        a.transitionEnd((function() {
                            e && !e.destroyed && e.transitionEnd()
                        }
                        )))) : (e.emit("_freeModeNoMomentumRelease"),
                        e.updateProgress(x)),
                        e.updateActiveIndex(),
                        e.updateSlidesClasses()
                    } else {
                        if (i.freeModeSticky)
                            return void e.slideToClosest();
                        i.freeMode && e.emit("_freeModeNoMomentumRelease")
                    }
                    (!i.freeModeMomentum || d >= i.longSwipesMs) && (e.updateProgress(),
                    e.updateActiveIndex(),
                    e.updateSlidesClasses())
                } else {
                    for (var P = 0, R = e.slidesSizesGrid[0], I = 0; I < o.length; I += I < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup) {
                        var D = I < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
                        void 0 !== o[I + D] ? h >= o[I] && h < o[I + D] && (P = I,
                        R = o[I + D] - o[I]) : h >= o[I] && (P = I,
                        R = o[o.length - 1] - o[o.length - 2])
                    }
                    var N = (h - o[P]) / R
                      , O = P < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup;
                    if (d > i.longSwipesMs) {
                        if (!i.longSwipes)
                            return void e.slideTo(e.activeIndex);
                        "next" === e.swipeDirection && (N >= i.longSwipesRatio ? e.slideTo(P + O) : e.slideTo(P)),
                        "prev" === e.swipeDirection && (N > 1 - i.longSwipesRatio ? e.slideTo(P + O) : e.slideTo(P))
                    } else {
                        if (!i.shortSwipes)
                            return void e.slideTo(e.activeIndex);
                        e.navigation && (c.target === e.navigation.nextEl || c.target === e.navigation.prevEl) ? c.target === e.navigation.nextEl ? e.slideTo(P + O) : e.slideTo(P) : ("next" === e.swipeDirection && e.slideTo(P + O),
                        "prev" === e.swipeDirection && e.slideTo(P))
                    }
                }
        }
        function V() {
            var t = this.params
              , e = this.el;
            if (!e || 0 !== e.offsetWidth) {
                t.breakpoints && this.setBreakpoint();
                var n = this.allowSlideNext
                  , i = this.allowSlidePrev
                  , r = this.snapGrid;
                this.allowSlideNext = !0,
                this.allowSlidePrev = !0,
                this.updateSize(),
                this.updateSlides(),
                this.updateSlidesClasses(),
                ("auto" === t.slidesPerView || t.slidesPerView > 1) && this.isEnd && !this.isBeginning && !this.params.centeredSlides ? this.slideTo(this.slides.length - 1, 0, !1, !0) : this.slideTo(this.activeIndex, 0, !1, !0),
                this.autoplay && this.autoplay.running && this.autoplay.paused && this.autoplay.run(),
                this.allowSlidePrev = i,
                this.allowSlideNext = n,
                this.params.watchOverflow && r !== this.snapGrid && this.checkOverflow()
            }
        }
        function W(t) {
            this.allowClick || (this.params.preventClicks && t.preventDefault(),
            this.params.preventClicksPropagation && this.animating && (t.stopPropagation(),
            t.stopImmediatePropagation()))
        }
        function j() {
            var t = this.wrapperEl
              , e = this.rtlTranslate;
            this.previousTranslate = this.translate,
            this.isHorizontal() ? this.translate = e ? t.scrollWidth - t.offsetWidth - t.scrollLeft : -t.scrollLeft : this.translate = -t.scrollTop,
            -0 === this.translate && (this.translate = 0),
            this.updateActiveIndex(),
            this.updateSlidesClasses();
            var n = this.maxTranslate() - this.minTranslate();
            (0 === n ? 0 : (this.translate - this.minTranslate()) / n) !== this.progress && this.updateProgress(e ? -this.translate : this.translate),
            this.emit("setTranslate", this.translate, !1)
        }
        var q = !1;
        function X() {}
        var Y = {
            init: !0,
            direction: "horizontal",
            touchEventsTarget: "container",
            initialSlide: 0,
            speed: 300,
            cssMode: !1,
            updateOnWindowResize: !0,
            resizeObserver: !1,
            nested: !1,
            width: null,
            height: null,
            preventInteractionOnTransition: !1,
            userAgent: null,
            url: null,
            edgeSwipeDetection: !1,
            edgeSwipeThreshold: 20,
            freeMode: !1,
            freeModeMomentum: !0,
            freeModeMomentumRatio: 1,
            freeModeMomentumBounce: !0,
            freeModeMomentumBounceRatio: 1,
            freeModeMomentumVelocityRatio: 1,
            freeModeSticky: !1,
            freeModeMinimumVelocity: .02,
            autoHeight: !1,
            setWrapperSize: !1,
            virtualTranslate: !1,
            effect: "slide",
            breakpoints: void 0,
            breakpointsBase: "window",
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerColumn: 1,
            slidesPerColumnFill: "column",
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            centeredSlides: !1,
            centeredSlidesBounds: !1,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: !0,
            centerInsufficientSlides: !1,
            watchOverflow: !1,
            roundLengths: !1,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: !0,
            shortSwipes: !0,
            longSwipes: !0,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: !0,
            allowTouchMove: !0,
            threshold: 0,
            touchMoveStopPropagation: !1,
            touchStartPreventDefault: !0,
            touchStartForcePreventDefault: !1,
            touchReleaseOnEdges: !1,
            uniqueNavElements: !0,
            resistance: !0,
            resistanceRatio: .85,
            watchSlidesProgress: !1,
            watchSlidesVisibility: !1,
            grabCursor: !1,
            preventClicks: !0,
            preventClicksPropagation: !0,
            slideToClickedSlide: !1,
            preloadImages: !0,
            updateOnImagesReady: !0,
            loop: !1,
            loopAdditionalSlides: 0,
            loopedSlides: null,
            loopFillGroupWithBlank: !1,
            loopPreventsSlide: !0,
            allowSlidePrev: !0,
            allowSlideNext: !0,
            swipeHandler: null,
            noSwiping: !0,
            noSwipingClass: "swiper-no-swiping",
            noSwipingSelector: null,
            passiveListeners: !0,
            containerModifierClass: "swiper-container-",
            slideClass: "swiper-slide",
            slideBlankClass: "swiper-slide-invisible-blank",
            slideActiveClass: "swiper-slide-active",
            slideDuplicateActiveClass: "swiper-slide-duplicate-active",
            slideVisibleClass: "swiper-slide-visible",
            slideDuplicateClass: "swiper-slide-duplicate",
            slideNextClass: "swiper-slide-next",
            slideDuplicateNextClass: "swiper-slide-duplicate-next",
            slidePrevClass: "swiper-slide-prev",
            slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
            wrapperClass: "swiper-wrapper",
            runCallbacksOnInit: !0,
            _emitClasses: !1
        };
        function Z(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        var J = {
            modular: {
                useParams: function(t) {
                    var e = this;
                    e.modules && Object.keys(e.modules).forEach((function(n) {
                        var i = e.modules[n];
                        i.params && R(t, i.params)
                    }
                    ))
                },
                useModules: function(t) {
                    void 0 === t && (t = {});
                    var e = this;
                    e.modules && Object.keys(e.modules).forEach((function(n) {
                        var i = e.modules[n]
                          , r = t[n] || {};
                        i.on && e.on && Object.keys(i.on).forEach((function(t) {
                            e.on(t, i.on[t])
                        }
                        )),
                        i.create && i.create.bind(e)(r)
                    }
                    ))
                }
            },
            eventsEmitter: {
                on: function(t, e, n) {
                    var i = this;
                    if ("function" != typeof e)
                        return i;
                    var r = n ? "unshift" : "push";
                    return t.split(" ").forEach((function(t) {
                        i.eventsListeners[t] || (i.eventsListeners[t] = []),
                        i.eventsListeners[t][r](e)
                    }
                    )),
                    i
                },
                once: function(t, e, n) {
                    var i = this;
                    if ("function" != typeof e)
                        return i;
                    function r() {
                        i.off(t, r),
                        r.__emitterProxy && delete r.__emitterProxy;
                        for (var n = arguments.length, s = new Array(n), a = 0; a < n; a++)
                            s[a] = arguments[a];
                        e.apply(i, s)
                    }
                    return r.__emitterProxy = e,
                    i.on(t, r, n)
                },
                onAny: function(t, e) {
                    if ("function" != typeof t)
                        return this;
                    var n = e ? "unshift" : "push";
                    return this.eventsAnyListeners.indexOf(t) < 0 && this.eventsAnyListeners[n](t),
                    this
                },
                offAny: function(t) {
                    if (!this.eventsAnyListeners)
                        return this;
                    var e = this.eventsAnyListeners.indexOf(t);
                    return e >= 0 && this.eventsAnyListeners.splice(e, 1),
                    this
                },
                off: function(t, e) {
                    var n = this;
                    return n.eventsListeners ? (t.split(" ").forEach((function(t) {
                        void 0 === e ? n.eventsListeners[t] = [] : n.eventsListeners[t] && n.eventsListeners[t].forEach((function(i, r) {
                            (i === e || i.__emitterProxy && i.__emitterProxy === e) && n.eventsListeners[t].splice(r, 1)
                        }
                        ))
                    }
                    )),
                    n) : n
                },
                emit: function() {
                    var t, e, n, i = this;
                    if (!i.eventsListeners)
                        return i;
                    for (var r = arguments.length, s = new Array(r), a = 0; a < r; a++)
                        s[a] = arguments[a];
                    "string" == typeof s[0] || Array.isArray(s[0]) ? (t = s[0],
                    e = s.slice(1, s.length),
                    n = i) : (t = s[0].events,
                    e = s[0].data,
                    n = s[0].context || i),
                    e.unshift(n);
                    var o = Array.isArray(t) ? t : t.split(" ");
                    return o.forEach((function(t) {
                        i.eventsAnyListeners && i.eventsAnyListeners.length && i.eventsAnyListeners.forEach((function(i) {
                            i.apply(n, [t].concat(e))
                        }
                        )),
                        i.eventsListeners && i.eventsListeners[t] && i.eventsListeners[t].forEach((function(t) {
                            t.apply(n, e)
                        }
                        ))
                    }
                    )),
                    i
                }
            },
            update: {
                updateSize: function() {
                    var t, e, n = this.$el;
                    t = void 0 !== this.params.width && null !== this.params.width ? this.params.width : n[0].clientWidth,
                    e = void 0 !== this.params.height && null !== this.params.height ? this.params.height : n[0].clientHeight,
                    0 === t && this.isHorizontal() || 0 === e && this.isVertical() || (t = t - parseInt(n.css("padding-left") || 0, 10) - parseInt(n.css("padding-right") || 0, 10),
                    e = e - parseInt(n.css("padding-top") || 0, 10) - parseInt(n.css("padding-bottom") || 0, 10),
                    Number.isNaN(t) && (t = 0),
                    Number.isNaN(e) && (e = 0),
                    R(this, {
                        width: t,
                        height: e,
                        size: this.isHorizontal() ? t : e
                    }))
                },
                updateSlides: function() {
                    var t = this
                      , e = function(e) {
                        return t.isHorizontal() ? e : {
                            width: "height",
                            "margin-top": "margin-left",
                            "margin-bottom ": "margin-right",
                            "margin-left": "margin-top",
                            "margin-right": "margin-bottom",
                            "padding-left": "padding-top",
                            "padding-right": "padding-bottom",
                            marginRight: "marginBottom"
                        }[e]
                    }
                      , n = function(t, n) {
                        return parseFloat(t.getPropertyValue(e(n)) || 0)
                    }
                      , i = t.params
                      , r = t.$wrapperEl
                      , s = t.size
                      , a = t.rtlTranslate
                      , o = t.wrongRTL
                      , l = t.virtual && i.virtual.enabled
                      , c = l ? t.virtual.slides.length : t.slides.length
                      , h = r.children("." + t.params.slideClass)
                      , u = l ? t.virtual.slides.length : h.length
                      , d = []
                      , p = []
                      , f = []
                      , m = i.slidesOffsetBefore;
                    "function" == typeof m && (m = i.slidesOffsetBefore.call(t));
                    var g = i.slidesOffsetAfter;
                    "function" == typeof g && (g = i.slidesOffsetAfter.call(t));
                    var v = t.snapGrid.length
                      , y = t.slidesGrid.length
                      , x = i.spaceBetween
                      , _ = -m
                      , w = 0
                      , b = 0;
                    if (void 0 !== s) {
                        var M, S;
                        "string" == typeof x && x.indexOf("%") >= 0 && (x = parseFloat(x.replace("%", "")) / 100 * s),
                        t.virtualSize = -x,
                        a ? h.css({
                            marginLeft: "",
                            marginTop: ""
                        }) : h.css({
                            marginRight: "",
                            marginBottom: ""
                        }),
                        i.slidesPerColumn > 1 && (M = Math.floor(u / i.slidesPerColumn) === u / t.params.slidesPerColumn ? u : Math.ceil(u / i.slidesPerColumn) * i.slidesPerColumn,
                        "auto" !== i.slidesPerView && "row" === i.slidesPerColumnFill && (M = Math.max(M, i.slidesPerView * i.slidesPerColumn)));
                        for (var T, E, L, A = i.slidesPerColumn, C = M / A, P = Math.floor(u / i.slidesPerColumn), I = 0; I < u; I += 1) {
                            S = 0;
                            var D = h.eq(I);
                            if (i.slidesPerColumn > 1) {
                                var N = void 0
                                  , O = void 0
                                  , z = void 0;
                                if ("row" === i.slidesPerColumnFill && i.slidesPerGroup > 1) {
                                    var B = Math.floor(I / (i.slidesPerGroup * i.slidesPerColumn))
                                      , k = I - i.slidesPerColumn * i.slidesPerGroup * B
                                      , F = 0 === B ? i.slidesPerGroup : Math.min(Math.ceil((u - B * A * i.slidesPerGroup) / A), i.slidesPerGroup);
                                    N = (O = k - (z = Math.floor(k / F)) * F + B * i.slidesPerGroup) + z * M / A,
                                    D.css({
                                        "-webkit-box-ordinal-group": N,
                                        "-moz-box-ordinal-group": N,
                                        "-ms-flex-order": N,
                                        "-webkit-order": N,
                                        order: N
                                    })
                                } else
                                    "column" === i.slidesPerColumnFill ? (z = I - (O = Math.floor(I / A)) * A,
                                    (O > P || O === P && z === A - 1) && (z += 1) >= A && (z = 0,
                                    O += 1)) : O = I - (z = Math.floor(I / C)) * C;
                                D.css(e("margin-top"), 0 !== z && i.spaceBetween && i.spaceBetween + "px")
                            }
                            if ("none" !== D.css("display")) {
                                if ("auto" === i.slidesPerView) {
                                    var H = getComputedStyle(D[0])
                                      , U = D[0].style.transform
                                      , G = D[0].style.webkitTransform;
                                    if (U && (D[0].style.transform = "none"),
                                    G && (D[0].style.webkitTransform = "none"),
                                    i.roundLengths)
                                        S = t.isHorizontal() ? D.outerWidth(!0) : D.outerHeight(!0);
                                    else {
                                        var V = n(H, "width")
                                          , W = n(H, "padding-left")
                                          , j = n(H, "padding-right")
                                          , q = n(H, "margin-left")
                                          , X = n(H, "margin-right")
                                          , Y = H.getPropertyValue("box-sizing");
                                        if (Y && "border-box" === Y)
                                            S = V + q + X;
                                        else {
                                            var Z = D[0]
                                              , J = Z.clientWidth;
                                            S = V + W + j + q + X + (Z.offsetWidth - J)
                                        }
                                    }
                                    U && (D[0].style.transform = U),
                                    G && (D[0].style.webkitTransform = G),
                                    i.roundLengths && (S = Math.floor(S))
                                } else
                                    S = (s - (i.slidesPerView - 1) * x) / i.slidesPerView,
                                    i.roundLengths && (S = Math.floor(S)),
                                    h[I] && (h[I].style[e("width")] = S + "px");
                                h[I] && (h[I].swiperSlideSize = S),
                                f.push(S),
                                i.centeredSlides ? (_ = _ + S / 2 + w / 2 + x,
                                0 === w && 0 !== I && (_ = _ - s / 2 - x),
                                0 === I && (_ = _ - s / 2 - x),
                                Math.abs(_) < .001 && (_ = 0),
                                i.roundLengths && (_ = Math.floor(_)),
                                b % i.slidesPerGroup == 0 && d.push(_),
                                p.push(_)) : (i.roundLengths && (_ = Math.floor(_)),
                                (b - Math.min(t.params.slidesPerGroupSkip, b)) % t.params.slidesPerGroup == 0 && d.push(_),
                                p.push(_),
                                _ = _ + S + x),
                                t.virtualSize += S + x,
                                w = S,
                                b += 1
                            }
                        }
                        if (t.virtualSize = Math.max(t.virtualSize, s) + g,
                        a && o && ("slide" === i.effect || "coverflow" === i.effect) && r.css({
                            width: t.virtualSize + i.spaceBetween + "px"
                        }),
                        i.setWrapperSize)
                            r.css(((E = {})[e("width")] = t.virtualSize + i.spaceBetween + "px",
                            E));
                        if (i.slidesPerColumn > 1)
                            if (t.virtualSize = (S + i.spaceBetween) * M,
                            t.virtualSize = Math.ceil(t.virtualSize / i.slidesPerColumn) - i.spaceBetween,
                            r.css(((L = {})[e("width")] = t.virtualSize + i.spaceBetween + "px",
                            L)),
                            i.centeredSlides) {
                                T = [];
                                for (var $ = 0; $ < d.length; $ += 1) {
                                    var K = d[$];
                                    i.roundLengths && (K = Math.floor(K)),
                                    d[$] < t.virtualSize + d[0] && T.push(K)
                                }
                                d = T
                            }
                        if (!i.centeredSlides) {
                            T = [];
                            for (var Q = 0; Q < d.length; Q += 1) {
                                var tt = d[Q];
                                i.roundLengths && (tt = Math.floor(tt)),
                                d[Q] <= t.virtualSize - s && T.push(tt)
                            }
                            d = T,
                            Math.floor(t.virtualSize - s) - Math.floor(d[d.length - 1]) > 1 && d.push(t.virtualSize - s)
                        }
                        if (0 === d.length && (d = [0]),
                        0 !== i.spaceBetween) {
                            var et, nt = t.isHorizontal() && a ? "marginLeft" : e("marginRight");
                            h.filter((function(t, e) {
                                return !i.cssMode || e !== h.length - 1
                            }
                            )).css(((et = {})[nt] = x + "px",
                            et))
                        }
                        if (i.centeredSlides && i.centeredSlidesBounds) {
                            var it = 0;
                            f.forEach((function(t) {
                                it += t + (i.spaceBetween ? i.spaceBetween : 0)
                            }
                            ));
                            var rt = (it -= i.spaceBetween) - s;
                            d = d.map((function(t) {
                                return t < 0 ? -m : t > rt ? rt + g : t
                            }
                            ))
                        }
                        if (i.centerInsufficientSlides) {
                            var st = 0;
                            if (f.forEach((function(t) {
                                st += t + (i.spaceBetween ? i.spaceBetween : 0)
                            }
                            )),
                            (st -= i.spaceBetween) < s) {
                                var at = (s - st) / 2;
                                d.forEach((function(t, e) {
                                    d[e] = t - at
                                }
                                )),
                                p.forEach((function(t, e) {
                                    p[e] = t + at
                                }
                                ))
                            }
                        }
                        R(t, {
                            slides: h,
                            snapGrid: d,
                            slidesGrid: p,
                            slidesSizesGrid: f
                        }),
                        u !== c && t.emit("slidesLengthChange"),
                        d.length !== v && (t.params.watchOverflow && t.checkOverflow(),
                        t.emit("snapGridLengthChange")),
                        p.length !== y && t.emit("slidesGridLengthChange"),
                        (i.watchSlidesProgress || i.watchSlidesVisibility) && t.updateSlidesOffset()
                    }
                },
                updateAutoHeight: function(t) {
                    var e, n = [], i = 0;
                    if ("number" == typeof t ? this.setTransition(t) : !0 === t && this.setTransition(this.params.speed),
                    "auto" !== this.params.slidesPerView && this.params.slidesPerView > 1)
                        if (this.params.centeredSlides)
                            this.visibleSlides.each((function(t) {
                                n.push(t)
                            }
                            ));
                        else
                            for (e = 0; e < Math.ceil(this.params.slidesPerView); e += 1) {
                                var r = this.activeIndex + e;
                                if (r > this.slides.length)
                                    break;
                                n.push(this.slides.eq(r)[0])
                            }
                    else
                        n.push(this.slides.eq(this.activeIndex)[0]);
                    for (e = 0; e < n.length; e += 1)
                        if (void 0 !== n[e]) {
                            var s = n[e].offsetHeight;
                            i = s > i ? s : i
                        }
                    i && this.$wrapperEl.css("height", i + "px")
                },
                updateSlidesOffset: function() {
                    for (var t = this.slides, e = 0; e < t.length; e += 1)
                        t[e].swiperSlideOffset = this.isHorizontal() ? t[e].offsetLeft : t[e].offsetTop
                },
                updateSlidesProgress: function(t) {
                    void 0 === t && (t = this && this.translate || 0);
                    var e = this.params
                      , n = this.slides
                      , i = this.rtlTranslate;
                    if (0 !== n.length) {
                        void 0 === n[0].swiperSlideOffset && this.updateSlidesOffset();
                        var r = -t;
                        i && (r = t),
                        n.removeClass(e.slideVisibleClass),
                        this.visibleSlidesIndexes = [],
                        this.visibleSlides = [];
                        for (var s = 0; s < n.length; s += 1) {
                            var a = n[s]
                              , o = (r + (e.centeredSlides ? this.minTranslate() : 0) - a.swiperSlideOffset) / (a.swiperSlideSize + e.spaceBetween);
                            if (e.watchSlidesVisibility || e.centeredSlides && e.autoHeight) {
                                var l = -(r - a.swiperSlideOffset)
                                  , c = l + this.slidesSizesGrid[s];
                                (l >= 0 && l < this.size - 1 || c > 1 && c <= this.size || l <= 0 && c >= this.size) && (this.visibleSlides.push(a),
                                this.visibleSlidesIndexes.push(s),
                                n.eq(s).addClass(e.slideVisibleClass))
                            }
                            a.progress = i ? -o : o
                        }
                        this.visibleSlides = E(this.visibleSlides)
                    }
                },
                updateProgress: function(t) {
                    if (void 0 === t) {
                        var e = this.rtlTranslate ? -1 : 1;
                        t = this && this.translate && this.translate * e || 0
                    }
                    var n = this.params
                      , i = this.maxTranslate() - this.minTranslate()
                      , r = this.progress
                      , s = this.isBeginning
                      , a = this.isEnd
                      , o = s
                      , l = a;
                    0 === i ? (r = 0,
                    s = !0,
                    a = !0) : (s = (r = (t - this.minTranslate()) / i) <= 0,
                    a = r >= 1),
                    R(this, {
                        progress: r,
                        isBeginning: s,
                        isEnd: a
                    }),
                    (n.watchSlidesProgress || n.watchSlidesVisibility || n.centeredSlides && n.autoHeight) && this.updateSlidesProgress(t),
                    s && !o && this.emit("reachBeginning toEdge"),
                    a && !l && this.emit("reachEnd toEdge"),
                    (o && !s || l && !a) && this.emit("fromEdge"),
                    this.emit("progress", r)
                },
                updateSlidesClasses: function() {
                    var t, e = this.slides, n = this.params, i = this.$wrapperEl, r = this.activeIndex, s = this.realIndex, a = this.virtual && n.virtual.enabled;
                    e.removeClass(n.slideActiveClass + " " + n.slideNextClass + " " + n.slidePrevClass + " " + n.slideDuplicateActiveClass + " " + n.slideDuplicateNextClass + " " + n.slideDuplicatePrevClass),
                    (t = a ? this.$wrapperEl.find("." + n.slideClass + '[data-swiper-slide-index="' + r + '"]') : e.eq(r)).addClass(n.slideActiveClass),
                    n.loop && (t.hasClass(n.slideDuplicateClass) ? i.children("." + n.slideClass + ":not(." + n.slideDuplicateClass + ')[data-swiper-slide-index="' + s + '"]').addClass(n.slideDuplicateActiveClass) : i.children("." + n.slideClass + "." + n.slideDuplicateClass + '[data-swiper-slide-index="' + s + '"]').addClass(n.slideDuplicateActiveClass));
                    var o = t.nextAll("." + n.slideClass).eq(0).addClass(n.slideNextClass);
                    n.loop && 0 === o.length && (o = e.eq(0)).addClass(n.slideNextClass);
                    var l = t.prevAll("." + n.slideClass).eq(0).addClass(n.slidePrevClass);
                    n.loop && 0 === l.length && (l = e.eq(-1)).addClass(n.slidePrevClass),
                    n.loop && (o.hasClass(n.slideDuplicateClass) ? i.children("." + n.slideClass + ":not(." + n.slideDuplicateClass + ')[data-swiper-slide-index="' + o.attr("data-swiper-slide-index") + '"]').addClass(n.slideDuplicateNextClass) : i.children("." + n.slideClass + "." + n.slideDuplicateClass + '[data-swiper-slide-index="' + o.attr("data-swiper-slide-index") + '"]').addClass(n.slideDuplicateNextClass),
                    l.hasClass(n.slideDuplicateClass) ? i.children("." + n.slideClass + ":not(." + n.slideDuplicateClass + ')[data-swiper-slide-index="' + l.attr("data-swiper-slide-index") + '"]').addClass(n.slideDuplicatePrevClass) : i.children("." + n.slideClass + "." + n.slideDuplicateClass + '[data-swiper-slide-index="' + l.attr("data-swiper-slide-index") + '"]').addClass(n.slideDuplicatePrevClass)),
                    this.emitSlidesClasses()
                },
                updateActiveIndex: function(t) {
                    var e, n = this.rtlTranslate ? this.translate : -this.translate, i = this.slidesGrid, r = this.snapGrid, s = this.params, a = this.activeIndex, o = this.realIndex, l = this.snapIndex, c = t;
                    if (void 0 === c) {
                        for (var h = 0; h < i.length; h += 1)
                            void 0 !== i[h + 1] ? n >= i[h] && n < i[h + 1] - (i[h + 1] - i[h]) / 2 ? c = h : n >= i[h] && n < i[h + 1] && (c = h + 1) : n >= i[h] && (c = h);
                        s.normalizeSlideIndex && (c < 0 || void 0 === c) && (c = 0)
                    }
                    if (r.indexOf(n) >= 0)
                        e = r.indexOf(n);
                    else {
                        var u = Math.min(s.slidesPerGroupSkip, c);
                        e = u + Math.floor((c - u) / s.slidesPerGroup)
                    }
                    if (e >= r.length && (e = r.length - 1),
                    c !== a) {
                        var d = parseInt(this.slides.eq(c).attr("data-swiper-slide-index") || c, 10);
                        R(this, {
                            snapIndex: e,
                            realIndex: d,
                            previousIndex: a,
                            activeIndex: c
                        }),
                        this.emit("activeIndexChange"),
                        this.emit("snapIndexChange"),
                        o !== d && this.emit("realIndexChange"),
                        (this.initialized || this.params.runCallbacksOnInit) && this.emit("slideChange")
                    } else
                        e !== l && (this.snapIndex = e,
                        this.emit("snapIndexChange"))
                },
                updateClickedSlide: function(t) {
                    var e, n = this.params, i = E(t.target).closest("." + n.slideClass)[0], r = !1;
                    if (i)
                        for (var s = 0; s < this.slides.length; s += 1)
                            if (this.slides[s] === i) {
                                r = !0,
                                e = s;
                                break
                            }
                    if (!i || !r)
                        return this.clickedSlide = void 0,
                        void (this.clickedIndex = void 0);
                    this.clickedSlide = i,
                    this.virtual && this.params.virtual.enabled ? this.clickedIndex = parseInt(E(i).attr("data-swiper-slide-index"), 10) : this.clickedIndex = e,
                    n.slideToClickedSlide && void 0 !== this.clickedIndex && this.clickedIndex !== this.activeIndex && this.slideToClickedSlide()
                }
            },
            translate: {
                getTranslate: function(t) {
                    void 0 === t && (t = this.isHorizontal() ? "x" : "y");
                    var e = this.params
                      , n = this.rtlTranslate
                      , i = this.translate
                      , r = this.$wrapperEl;
                    if (e.virtualTranslate)
                        return n ? -i : i;
                    if (e.cssMode)
                        return i;
                    var s = C(r[0], t);
                    return n && (s = -s),
                    s || 0
                },
                setTranslate: function(t, e) {
                    var n = this.rtlTranslate
                      , i = this.params
                      , r = this.$wrapperEl
                      , s = this.wrapperEl
                      , a = this.progress
                      , o = 0
                      , l = 0;
                    this.isHorizontal() ? o = n ? -t : t : l = t,
                    i.roundLengths && (o = Math.floor(o),
                    l = Math.floor(l)),
                    i.cssMode ? s[this.isHorizontal() ? "scrollLeft" : "scrollTop"] = this.isHorizontal() ? -o : -l : i.virtualTranslate || r.transform("translate3d(" + o + "px, " + l + "px, 0px)"),
                    this.previousTranslate = this.translate,
                    this.translate = this.isHorizontal() ? o : l;
                    var c = this.maxTranslate() - this.minTranslate();
                    (0 === c ? 0 : (t - this.minTranslate()) / c) !== a && this.updateProgress(t),
                    this.emit("setTranslate", this.translate, e)
                },
                minTranslate: function() {
                    return -this.snapGrid[0]
                },
                maxTranslate: function() {
                    return -this.snapGrid[this.snapGrid.length - 1]
                },
                translateTo: function(t, e, n, i, r) {
                    void 0 === t && (t = 0),
                    void 0 === e && (e = this.params.speed),
                    void 0 === n && (n = !0),
                    void 0 === i && (i = !0);
                    var s = this
                      , a = s.params
                      , o = s.wrapperEl;
                    if (s.animating && a.preventInteractionOnTransition)
                        return !1;
                    var l, c = s.minTranslate(), h = s.maxTranslate();
                    if (l = i && t > c ? c : i && t < h ? h : t,
                    s.updateProgress(l),
                    a.cssMode) {
                        var u, d = s.isHorizontal();
                        if (0 === e)
                            o[d ? "scrollLeft" : "scrollTop"] = -l;
                        else if (o.scrollTo)
                            o.scrollTo(((u = {})[d ? "left" : "top"] = -l,
                            u.behavior = "smooth",
                            u));
                        else
                            o[d ? "scrollLeft" : "scrollTop"] = -l;
                        return !0
                    }
                    return 0 === e ? (s.setTransition(0),
                    s.setTranslate(l),
                    n && (s.emit("beforeTransitionStart", e, r),
                    s.emit("transitionEnd"))) : (s.setTransition(e),
                    s.setTranslate(l),
                    n && (s.emit("beforeTransitionStart", e, r),
                    s.emit("transitionStart")),
                    s.animating || (s.animating = !0,
                    s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function(t) {
                        s && !s.destroyed && t.target === this && (s.$wrapperEl[0].removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd),
                        s.$wrapperEl[0].removeEventListener("webkitTransitionEnd", s.onTranslateToWrapperTransitionEnd),
                        s.onTranslateToWrapperTransitionEnd = null,
                        delete s.onTranslateToWrapperTransitionEnd,
                        n && s.emit("transitionEnd"))
                    }
                    ),
                    s.$wrapperEl[0].addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd),
                    s.$wrapperEl[0].addEventListener("webkitTransitionEnd", s.onTranslateToWrapperTransitionEnd))),
                    !0
                }
            },
            transition: {
                setTransition: function(t, e) {
                    this.params.cssMode || this.$wrapperEl.transition(t),
                    this.emit("setTransition", t, e)
                },
                transitionStart: function(t, e) {
                    void 0 === t && (t = !0);
                    var n = this.activeIndex
                      , i = this.params
                      , r = this.previousIndex;
                    if (!i.cssMode) {
                        i.autoHeight && this.updateAutoHeight();
                        var s = e;
                        if (s || (s = n > r ? "next" : n < r ? "prev" : "reset"),
                        this.emit("transitionStart"),
                        t && n !== r) {
                            if ("reset" === s)
                                return void this.emit("slideResetTransitionStart");
                            this.emit("slideChangeTransitionStart"),
                            "next" === s ? this.emit("slideNextTransitionStart") : this.emit("slidePrevTransitionStart")
                        }
                    }
                },
                transitionEnd: function(t, e) {
                    void 0 === t && (t = !0);
                    var n = this.activeIndex
                      , i = this.previousIndex
                      , r = this.params;
                    if (this.animating = !1,
                    !r.cssMode) {
                        this.setTransition(0);
                        var s = e;
                        if (s || (s = n > i ? "next" : n < i ? "prev" : "reset"),
                        this.emit("transitionEnd"),
                        t && n !== i) {
                            if ("reset" === s)
                                return void this.emit("slideResetTransitionEnd");
                            this.emit("slideChangeTransitionEnd"),
                            "next" === s ? this.emit("slideNextTransitionEnd") : this.emit("slidePrevTransitionEnd")
                        }
                    }
                }
            },
            slide: {
                slideTo: function(t, e, n, i) {
                    if (void 0 === t && (t = 0),
                    void 0 === e && (e = this.params.speed),
                    void 0 === n && (n = !0),
                    "number" != typeof t && "string" != typeof t)
                        throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [" + typeof t + "] given.");
                    if ("string" == typeof t) {
                        var r = parseInt(t, 10);
                        if (!isFinite(r))
                            throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [" + t + "] given.");
                        t = r
                    }
                    var s = this
                      , a = t;
                    a < 0 && (a = 0);
                    var o = s.params
                      , l = s.snapGrid
                      , c = s.slidesGrid
                      , h = s.previousIndex
                      , u = s.activeIndex
                      , d = s.rtlTranslate
                      , p = s.wrapperEl;
                    if (s.animating && o.preventInteractionOnTransition)
                        return !1;
                    var f = Math.min(s.params.slidesPerGroupSkip, a)
                      , m = f + Math.floor((a - f) / s.params.slidesPerGroup);
                    m >= l.length && (m = l.length - 1),
                    (u || o.initialSlide || 0) === (h || 0) && n && s.emit("beforeSlideChangeStart");
                    var g, v = -l[m];
                    if (s.updateProgress(v),
                    o.normalizeSlideIndex)
                        for (var y = 0; y < c.length; y += 1) {
                            var x = -Math.floor(100 * v)
                              , _ = Math.floor(100 * c[y])
                              , w = Math.floor(100 * c[y + 1]);
                            void 0 !== c[y + 1] ? x >= _ && x < w - (w - _) / 2 ? a = y : x >= _ && x < w && (a = y + 1) : x >= _ && (a = y)
                        }
                    if (s.initialized && a !== u) {
                        if (!s.allowSlideNext && v < s.translate && v < s.minTranslate())
                            return !1;
                        if (!s.allowSlidePrev && v > s.translate && v > s.maxTranslate() && (u || 0) !== a)
                            return !1
                    }
                    if (g = a > u ? "next" : a < u ? "prev" : "reset",
                    d && -v === s.translate || !d && v === s.translate)
                        return s.updateActiveIndex(a),
                        o.autoHeight && s.updateAutoHeight(),
                        s.updateSlidesClasses(),
                        "slide" !== o.effect && s.setTranslate(v),
                        "reset" !== g && (s.transitionStart(n, g),
                        s.transitionEnd(n, g)),
                        !1;
                    if (o.cssMode) {
                        var b, M = s.isHorizontal(), S = -v;
                        if (d && (S = p.scrollWidth - p.offsetWidth - S),
                        0 === e)
                            p[M ? "scrollLeft" : "scrollTop"] = S;
                        else if (p.scrollTo)
                            p.scrollTo(((b = {})[M ? "left" : "top"] = S,
                            b.behavior = "smooth",
                            b));
                        else
                            p[M ? "scrollLeft" : "scrollTop"] = S;
                        return !0
                    }
                    return 0 === e ? (s.setTransition(0),
                    s.setTranslate(v),
                    s.updateActiveIndex(a),
                    s.updateSlidesClasses(),
                    s.emit("beforeTransitionStart", e, i),
                    s.transitionStart(n, g),
                    s.transitionEnd(n, g)) : (s.setTransition(e),
                    s.setTranslate(v),
                    s.updateActiveIndex(a),
                    s.updateSlidesClasses(),
                    s.emit("beforeTransitionStart", e, i),
                    s.transitionStart(n, g),
                    s.animating || (s.animating = !0,
                    s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function(t) {
                        s && !s.destroyed && t.target === this && (s.$wrapperEl[0].removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd),
                        s.$wrapperEl[0].removeEventListener("webkitTransitionEnd", s.onSlideToWrapperTransitionEnd),
                        s.onSlideToWrapperTransitionEnd = null,
                        delete s.onSlideToWrapperTransitionEnd,
                        s.transitionEnd(n, g))
                    }
                    ),
                    s.$wrapperEl[0].addEventListener("transitionend", s.onSlideToWrapperTransitionEnd),
                    s.$wrapperEl[0].addEventListener("webkitTransitionEnd", s.onSlideToWrapperTransitionEnd))),
                    !0
                },
                slideToLoop: function(t, e, n, i) {
                    void 0 === t && (t = 0),
                    void 0 === e && (e = this.params.speed),
                    void 0 === n && (n = !0);
                    var r = t;
                    return this.params.loop && (r += this.loopedSlides),
                    this.slideTo(r, e, n, i)
                },
                slideNext: function(t, e, n) {
                    void 0 === t && (t = this.params.speed),
                    void 0 === e && (e = !0);
                    var i = this.params
                      , r = this.animating
                      , s = this.activeIndex < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup;
                    if (i.loop) {
                        if (r && i.loopPreventsSlide)
                            return !1;
                        this.loopFix(),
                        this._clientLeft = this.$wrapperEl[0].clientLeft
                    }
                    return this.slideTo(this.activeIndex + s, t, e, n)
                },
                slidePrev: function(t, e, n) {
                    void 0 === t && (t = this.params.speed),
                    void 0 === e && (e = !0);
                    var i = this.params
                      , r = this.animating
                      , s = this.snapGrid
                      , a = this.slidesGrid
                      , o = this.rtlTranslate;
                    if (i.loop) {
                        if (r && i.loopPreventsSlide)
                            return !1;
                        this.loopFix(),
                        this._clientLeft = this.$wrapperEl[0].clientLeft
                    }
                    function l(t) {
                        return t < 0 ? -Math.floor(Math.abs(t)) : Math.floor(t)
                    }
                    var c, h = l(o ? this.translate : -this.translate), u = s.map((function(t) {
                        return l(t)
                    }
                    )), d = (s[u.indexOf(h)],
                    s[u.indexOf(h) - 1]);
                    return void 0 === d && i.cssMode && s.forEach((function(t) {
                        !d && h >= t && (d = t)
                    }
                    )),
                    void 0 !== d && (c = a.indexOf(d)) < 0 && (c = this.activeIndex - 1),
                    this.slideTo(c, t, e, n)
                },
                slideReset: function(t, e, n) {
                    return void 0 === t && (t = this.params.speed),
                    void 0 === e && (e = !0),
                    this.slideTo(this.activeIndex, t, e, n)
                },
                slideToClosest: function(t, e, n, i) {
                    void 0 === t && (t = this.params.speed),
                    void 0 === e && (e = !0),
                    void 0 === i && (i = .5);
                    var r = this.activeIndex
                      , s = Math.min(this.params.slidesPerGroupSkip, r)
                      , a = s + Math.floor((r - s) / this.params.slidesPerGroup)
                      , o = this.rtlTranslate ? this.translate : -this.translate;
                    if (o >= this.snapGrid[a]) {
                        var l = this.snapGrid[a];
                        o - l > (this.snapGrid[a + 1] - l) * i && (r += this.params.slidesPerGroup)
                    } else {
                        var c = this.snapGrid[a - 1];
                        o - c <= (this.snapGrid[a] - c) * i && (r -= this.params.slidesPerGroup)
                    }
                    return r = Math.max(r, 0),
                    r = Math.min(r, this.slidesGrid.length - 1),
                    this.slideTo(r, t, e, n)
                },
                slideToClickedSlide: function() {
                    var t, e = this, n = e.params, i = e.$wrapperEl, r = "auto" === n.slidesPerView ? e.slidesPerViewDynamic() : n.slidesPerView, s = e.clickedIndex;
                    if (n.loop) {
                        if (e.animating)
                            return;
                        t = parseInt(E(e.clickedSlide).attr("data-swiper-slide-index"), 10),
                        n.centeredSlides ? s < e.loopedSlides - r / 2 || s > e.slides.length - e.loopedSlides + r / 2 ? (e.loopFix(),
                        s = i.children("." + n.slideClass + '[data-swiper-slide-index="' + t + '"]:not(.' + n.slideDuplicateClass + ")").eq(0).index(),
                        L((function() {
                            e.slideTo(s)
                        }
                        ))) : e.slideTo(s) : s > e.slides.length - r ? (e.loopFix(),
                        s = i.children("." + n.slideClass + '[data-swiper-slide-index="' + t + '"]:not(.' + n.slideDuplicateClass + ")").eq(0).index(),
                        L((function() {
                            e.slideTo(s)
                        }
                        ))) : e.slideTo(s)
                    } else
                        e.slideTo(s)
                }
            },
            loop: {
                loopCreate: function() {
                    var t = this
                      , e = l()
                      , n = t.params
                      , i = t.$wrapperEl;
                    i.children("." + n.slideClass + "." + n.slideDuplicateClass).remove();
                    var r = i.children("." + n.slideClass);
                    if (n.loopFillGroupWithBlank) {
                        var s = n.slidesPerGroup - r.length % n.slidesPerGroup;
                        if (s !== n.slidesPerGroup) {
                            for (var a = 0; a < s; a += 1) {
                                var o = E(e.createElement("div")).addClass(n.slideClass + " " + n.slideBlankClass);
                                i.append(o)
                            }
                            r = i.children("." + n.slideClass)
                        }
                    }
                    "auto" !== n.slidesPerView || n.loopedSlides || (n.loopedSlides = r.length),
                    t.loopedSlides = Math.ceil(parseFloat(n.loopedSlides || n.slidesPerView, 10)),
                    t.loopedSlides += n.loopAdditionalSlides,
                    t.loopedSlides > r.length && (t.loopedSlides = r.length);
                    var c = []
                      , h = [];
                    r.each((function(e, n) {
                        var i = E(e);
                        n < t.loopedSlides && h.push(e),
                        n < r.length && n >= r.length - t.loopedSlides && c.push(e),
                        i.attr("data-swiper-slide-index", n)
                    }
                    ));
                    for (var u = 0; u < h.length; u += 1)
                        i.append(E(h[u].cloneNode(!0)).addClass(n.slideDuplicateClass));
                    for (var d = c.length - 1; d >= 0; d -= 1)
                        i.prepend(E(c[d].cloneNode(!0)).addClass(n.slideDuplicateClass))
                },
                loopFix: function() {
                    this.emit("beforeLoopFix");
                    var t, e = this.activeIndex, n = this.slides, i = this.loopedSlides, r = this.allowSlidePrev, s = this.allowSlideNext, a = this.snapGrid, o = this.rtlTranslate;
                    this.allowSlidePrev = !0,
                    this.allowSlideNext = !0;
                    var l = -a[e] - this.getTranslate();
                    if (e < i)
                        t = n.length - 3 * i + e,
                        t += i,
                        this.slideTo(t, 0, !1, !0) && 0 !== l && this.setTranslate((o ? -this.translate : this.translate) - l);
                    else if (e >= n.length - i) {
                        t = -n.length + e + i,
                        t += i,
                        this.slideTo(t, 0, !1, !0) && 0 !== l && this.setTranslate((o ? -this.translate : this.translate) - l)
                    }
                    this.allowSlidePrev = r,
                    this.allowSlideNext = s,
                    this.emit("loopFix")
                },
                loopDestroy: function() {
                    var t = this.$wrapperEl
                      , e = this.params
                      , n = this.slides;
                    t.children("." + e.slideClass + "." + e.slideDuplicateClass + ",." + e.slideClass + "." + e.slideBlankClass).remove(),
                    n.removeAttr("data-swiper-slide-index")
                }
            },
            grabCursor: {
                setGrabCursor: function(t) {
                    if (!(this.support.touch || !this.params.simulateTouch || this.params.watchOverflow && this.isLocked || this.params.cssMode)) {
                        var e = this.el;
                        e.style.cursor = "move",
                        e.style.cursor = t ? "-webkit-grabbing" : "-webkit-grab",
                        e.style.cursor = t ? "-moz-grabbin" : "-moz-grab",
                        e.style.cursor = t ? "grabbing" : "grab"
                    }
                },
                unsetGrabCursor: function() {
                    this.support.touch || this.params.watchOverflow && this.isLocked || this.params.cssMode || (this.el.style.cursor = "")
                }
            },
            manipulation: {
                appendSlide: function(t) {
                    var e = this.$wrapperEl
                      , n = this.params;
                    if (n.loop && this.loopDestroy(),
                    "object" == typeof t && "length"in t)
                        for (var i = 0; i < t.length; i += 1)
                            t[i] && e.append(t[i]);
                    else
                        e.append(t);
                    n.loop && this.loopCreate(),
                    n.observer && this.support.observer || this.update()
                },
                prependSlide: function(t) {
                    var e = this.params
                      , n = this.$wrapperEl
                      , i = this.activeIndex;
                    e.loop && this.loopDestroy();
                    var r = i + 1;
                    if ("object" == typeof t && "length"in t) {
                        for (var s = 0; s < t.length; s += 1)
                            t[s] && n.prepend(t[s]);
                        r = i + t.length
                    } else
                        n.prepend(t);
                    e.loop && this.loopCreate(),
                    e.observer && this.support.observer || this.update(),
                    this.slideTo(r, 0, !1)
                },
                addSlide: function(t, e) {
                    var n = this.$wrapperEl
                      , i = this.params
                      , r = this.activeIndex;
                    i.loop && (r -= this.loopedSlides,
                    this.loopDestroy(),
                    this.slides = n.children("." + i.slideClass));
                    var s = this.slides.length;
                    if (t <= 0)
                        this.prependSlide(e);
                    else if (t >= s)
                        this.appendSlide(e);
                    else {
                        for (var a = r > t ? r + 1 : r, o = [], l = s - 1; l >= t; l -= 1) {
                            var c = this.slides.eq(l);
                            c.remove(),
                            o.unshift(c)
                        }
                        if ("object" == typeof e && "length"in e) {
                            for (var h = 0; h < e.length; h += 1)
                                e[h] && n.append(e[h]);
                            a = r > t ? r + e.length : r
                        } else
                            n.append(e);
                        for (var u = 0; u < o.length; u += 1)
                            n.append(o[u]);
                        i.loop && this.loopCreate(),
                        i.observer && this.support.observer || this.update(),
                        i.loop ? this.slideTo(a + this.loopedSlides, 0, !1) : this.slideTo(a, 0, !1)
                    }
                },
                removeSlide: function(t) {
                    var e = this.params
                      , n = this.$wrapperEl
                      , i = this.activeIndex;
                    e.loop && (i -= this.loopedSlides,
                    this.loopDestroy(),
                    this.slides = n.children("." + e.slideClass));
                    var r, s = i;
                    if ("object" == typeof t && "length"in t) {
                        for (var a = 0; a < t.length; a += 1)
                            r = t[a],
                            this.slides[r] && this.slides.eq(r).remove(),
                            r < s && (s -= 1);
                        s = Math.max(s, 0)
                    } else
                        r = t,
                        this.slides[r] && this.slides.eq(r).remove(),
                        r < s && (s -= 1),
                        s = Math.max(s, 0);
                    e.loop && this.loopCreate(),
                    e.observer && this.support.observer || this.update(),
                    e.loop ? this.slideTo(s + this.loopedSlides, 0, !1) : this.slideTo(s, 0, !1)
                },
                removeAllSlides: function() {
                    for (var t = [], e = 0; e < this.slides.length; e += 1)
                        t.push(e);
                    this.removeSlide(t)
                }
            },
            events: {
                attachEvents: function() {
                    var t = l()
                      , e = this.params
                      , n = this.touchEvents
                      , i = this.el
                      , r = this.wrapperEl
                      , s = this.device
                      , a = this.support;
                    this.onTouchStart = H.bind(this),
                    this.onTouchMove = U.bind(this),
                    this.onTouchEnd = G.bind(this),
                    e.cssMode && (this.onScroll = j.bind(this)),
                    this.onClick = W.bind(this);
                    var o = !!e.nested;
                    if (!a.touch && a.pointerEvents)
                        i.addEventListener(n.start, this.onTouchStart, !1),
                        t.addEventListener(n.move, this.onTouchMove, o),
                        t.addEventListener(n.end, this.onTouchEnd, !1);
                    else {
                        if (a.touch) {
                            var c = !("touchstart" !== n.start || !a.passiveListener || !e.passiveListeners) && {
                                passive: !0,
                                capture: !1
                            };
                            i.addEventListener(n.start, this.onTouchStart, c),
                            i.addEventListener(n.move, this.onTouchMove, a.passiveListener ? {
                                passive: !1,
                                capture: o
                            } : o),
                            i.addEventListener(n.end, this.onTouchEnd, c),
                            n.cancel && i.addEventListener(n.cancel, this.onTouchEnd, c),
                            q || (t.addEventListener("touchstart", X),
                            q = !0)
                        }
                        (e.simulateTouch && !s.ios && !s.android || e.simulateTouch && !a.touch && s.ios) && (i.addEventListener("mousedown", this.onTouchStart, !1),
                        t.addEventListener("mousemove", this.onTouchMove, o),
                        t.addEventListener("mouseup", this.onTouchEnd, !1))
                    }
                    (e.preventClicks || e.preventClicksPropagation) && i.addEventListener("click", this.onClick, !0),
                    e.cssMode && r.addEventListener("scroll", this.onScroll),
                    e.updateOnWindowResize ? this.on(s.ios || s.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", V, !0) : this.on("observerUpdate", V, !0)
                },
                detachEvents: function() {
                    var t = l()
                      , e = this.params
                      , n = this.touchEvents
                      , i = this.el
                      , r = this.wrapperEl
                      , s = this.device
                      , a = this.support
                      , o = !!e.nested;
                    if (!a.touch && a.pointerEvents)
                        i.removeEventListener(n.start, this.onTouchStart, !1),
                        t.removeEventListener(n.move, this.onTouchMove, o),
                        t.removeEventListener(n.end, this.onTouchEnd, !1);
                    else {
                        if (a.touch) {
                            var c = !("onTouchStart" !== n.start || !a.passiveListener || !e.passiveListeners) && {
                                passive: !0,
                                capture: !1
                            };
                            i.removeEventListener(n.start, this.onTouchStart, c),
                            i.removeEventListener(n.move, this.onTouchMove, o),
                            i.removeEventListener(n.end, this.onTouchEnd, c),
                            n.cancel && i.removeEventListener(n.cancel, this.onTouchEnd, c)
                        }
                        (e.simulateTouch && !s.ios && !s.android || e.simulateTouch && !a.touch && s.ios) && (i.removeEventListener("mousedown", this.onTouchStart, !1),
                        t.removeEventListener("mousemove", this.onTouchMove, o),
                        t.removeEventListener("mouseup", this.onTouchEnd, !1))
                    }
                    (e.preventClicks || e.preventClicksPropagation) && i.removeEventListener("click", this.onClick, !0),
                    e.cssMode && r.removeEventListener("scroll", this.onScroll),
                    this.off(s.ios || s.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", V)
                }
            },
            breakpoints: {
                setBreakpoint: function() {
                    var t = this.activeIndex
                      , e = this.initialized
                      , n = this.loopedSlides
                      , i = void 0 === n ? 0 : n
                      , r = this.params
                      , s = this.$el
                      , a = r.breakpoints;
                    if (a && (!a || 0 !== Object.keys(a).length)) {
                        var o = this.getBreakpoint(a, this.params.breakpointsBase, this.el);
                        if (o && this.currentBreakpoint !== o) {
                            var l = o in a ? a[o] : void 0;
                            l && ["slidesPerView", "spaceBetween", "slidesPerGroup", "slidesPerGroupSkip", "slidesPerColumn"].forEach((function(t) {
                                var e = l[t];
                                void 0 !== e && (l[t] = "slidesPerView" !== t || "AUTO" !== e && "auto" !== e ? "slidesPerView" === t ? parseFloat(e) : parseInt(e, 10) : "auto")
                            }
                            ));
                            var c = l || this.originalParams
                              , h = r.slidesPerColumn > 1
                              , u = c.slidesPerColumn > 1;
                            h && !u ? (s.removeClass(r.containerModifierClass + "multirow " + r.containerModifierClass + "multirow-column"),
                            this.emitContainerClasses()) : !h && u && (s.addClass(r.containerModifierClass + "multirow"),
                            "column" === c.slidesPerColumnFill && s.addClass(r.containerModifierClass + "multirow-column"),
                            this.emitContainerClasses());
                            var d = c.direction && c.direction !== r.direction
                              , p = r.loop && (c.slidesPerView !== r.slidesPerView || d);
                            d && e && this.changeDirection(),
                            R(this.params, c),
                            R(this, {
                                allowTouchMove: this.params.allowTouchMove,
                                allowSlideNext: this.params.allowSlideNext,
                                allowSlidePrev: this.params.allowSlidePrev
                            }),
                            this.currentBreakpoint = o,
                            this.emit("_beforeBreakpoint", c),
                            p && e && (this.loopDestroy(),
                            this.loopCreate(),
                            this.updateSlides(),
                            this.slideTo(t - i + this.loopedSlides, 0, !1)),
                            this.emit("breakpoint", c)
                        }
                    }
                },
                getBreakpoint: function(t, e, n) {
                    if (void 0 === e && (e = "window"),
                    t && ("container" !== e || n)) {
                        var i = !1
                          , r = h()
                          , s = "window" === e ? r.innerWidth : n.clientWidth
                          , a = "window" === e ? r.innerHeight : n.clientHeight
                          , o = Object.keys(t).map((function(t) {
                            if ("string" == typeof t && 0 === t.indexOf("@")) {
                                var e = parseFloat(t.substr(1));
                                return {
                                    value: a * e,
                                    point: t
                                }
                            }
                            return {
                                value: t,
                                point: t
                            }
                        }
                        ));
                        o.sort((function(t, e) {
                            return parseInt(t.value, 10) - parseInt(e.value, 10)
                        }
                        ));
                        for (var l = 0; l < o.length; l += 1) {
                            var c = o[l]
                              , u = c.point;
                            c.value <= s && (i = u)
                        }
                        return i || "max"
                    }
                }
            },
            checkOverflow: {
                checkOverflow: function() {
                    var t = this.params
                      , e = this.isLocked
                      , n = this.slides.length > 0 && t.slidesOffsetBefore + t.spaceBetween * (this.slides.length - 1) + this.slides[0].offsetWidth * this.slides.length;
                    t.slidesOffsetBefore && t.slidesOffsetAfter && n ? this.isLocked = n <= this.size : this.isLocked = 1 === this.snapGrid.length,
                    this.allowSlideNext = !this.isLocked,
                    this.allowSlidePrev = !this.isLocked,
                    e !== this.isLocked && this.emit(this.isLocked ? "lock" : "unlock"),
                    e && e !== this.isLocked && (this.isEnd = !1,
                    this.navigation && this.navigation.update())
                }
            },
            classes: {
                addClasses: function() {
                    var t, e, n, i = this.classNames, r = this.params, s = this.rtl, a = this.$el, o = this.device, l = this.support, c = (t = ["initialized", r.direction, {
                        "pointer-events": l.pointerEvents && !l.touch
                    }, {
                        "free-mode": r.freeMode
                    }, {
                        autoheight: r.autoHeight
                    }, {
                        rtl: s
                    }, {
                        multirow: r.slidesPerColumn > 1
                    }, {
                        "multirow-column": r.slidesPerColumn > 1 && "column" === r.slidesPerColumnFill
                    }, {
                        android: o.android
                    }, {
                        ios: o.ios
                    }, {
                        "css-mode": r.cssMode
                    }],
                    e = r.containerModifierClass,
                    n = [],
                    t.forEach((function(t) {
                        "object" == typeof t ? Object.keys(t).forEach((function(i) {
                            t[i] && n.push(e + i)
                        }
                        )) : "string" == typeof t && n.push(e + t)
                    }
                    )),
                    n);
                    i.push.apply(i, c),
                    a.addClass([].concat(i).join(" ")),
                    this.emitContainerClasses()
                },
                removeClasses: function() {
                    var t = this.$el
                      , e = this.classNames;
                    t.removeClass(e.join(" ")),
                    this.emitContainerClasses()
                }
            },
            images: {
                loadImage: function(t, e, n, i, r, s) {
                    var a, o = h();
                    function l() {
                        s && s()
                    }
                    E(t).parent("picture")[0] || t.complete && r ? l() : e ? ((a = new o.Image).onload = l,
                    a.onerror = l,
                    i && (a.sizes = i),
                    n && (a.srcset = n),
                    e && (a.src = e)) : l()
                },
                preloadImages: function() {
                    var t = this;
                    function e() {
                        null != t && t && !t.destroyed && (void 0 !== t.imagesLoaded && (t.imagesLoaded += 1),
                        t.imagesLoaded === t.imagesToLoad.length && (t.params.updateOnImagesReady && t.update(),
                        t.emit("imagesReady")))
                    }
                    t.imagesToLoad = t.$el.find("img");
                    for (var n = 0; n < t.imagesToLoad.length; n += 1) {
                        var i = t.imagesToLoad[n];
                        t.loadImage(i, i.currentSrc || i.getAttribute("src"), i.srcset || i.getAttribute("srcset"), i.sizes || i.getAttribute("sizes"), !0, e)
                    }
                }
            }
        }
          , $ = {}
          , K = function() {
            function t() {
                for (var e, n, i = arguments.length, r = new Array(i), s = 0; s < i; s++)
                    r[s] = arguments[s];
                if (1 === r.length && r[0].constructor && "Object" === Object.prototype.toString.call(r[0]).slice(8, -1) ? n = r[0] : (e = r[0],
                n = r[1]),
                n || (n = {}),
                n = R({}, n),
                e && !n.el && (n.el = e),
                n.el && E(n.el).length > 1) {
                    var a = [];
                    return E(n.el).each((function(e) {
                        var i = R({}, n, {
                            el: e
                        });
                        a.push(new t(i))
                    }
                    )),
                    a
                }
                var o = this;
                o.__swiper__ = !0,
                o.support = D(),
                o.device = N({
                    userAgent: n.userAgent
                }),
                o.browser = O(),
                o.eventsListeners = {},
                o.eventsAnyListeners = [],
                void 0 === o.modules && (o.modules = {}),
                Object.keys(o.modules).forEach((function(t) {
                    var e = o.modules[t];
                    if (e.params) {
                        var i = Object.keys(e.params)[0]
                          , r = e.params[i];
                        if ("object" != typeof r || null === r)
                            return;
                        if (!(i in n) || !("enabled"in r))
                            return;
                        !0 === n[i] && (n[i] = {
                            enabled: !0
                        }),
                        "object" != typeof n[i] || "enabled"in n[i] || (n[i].enabled = !0),
                        n[i] || (n[i] = {
                            enabled: !1
                        })
                    }
                }
                ));
                var l, c, h = R({}, Y);
                return o.useParams(h),
                o.params = R({}, h, $, n),
                o.originalParams = R({}, o.params),
                o.passedParams = R({}, n),
                o.params && o.params.on && Object.keys(o.params.on).forEach((function(t) {
                    o.on(t, o.params.on[t])
                }
                )),
                o.params && o.params.onAny && o.onAny(o.params.onAny),
                o.$ = E,
                R(o, {
                    el: e,
                    classNames: [],
                    slides: E(),
                    slidesGrid: [],
                    snapGrid: [],
                    slidesSizesGrid: [],
                    isHorizontal: function() {
                        return "horizontal" === o.params.direction
                    },
                    isVertical: function() {
                        return "vertical" === o.params.direction
                    },
                    activeIndex: 0,
                    realIndex: 0,
                    isBeginning: !0,
                    isEnd: !1,
                    translate: 0,
                    previousTranslate: 0,
                    progress: 0,
                    velocity: 0,
                    animating: !1,
                    allowSlideNext: o.params.allowSlideNext,
                    allowSlidePrev: o.params.allowSlidePrev,
                    touchEvents: (l = ["touchstart", "touchmove", "touchend", "touchcancel"],
                    c = ["mousedown", "mousemove", "mouseup"],
                    o.support.pointerEvents && (c = ["pointerdown", "pointermove", "pointerup"]),
                    o.touchEventsTouch = {
                        start: l[0],
                        move: l[1],
                        end: l[2],
                        cancel: l[3]
                    },
                    o.touchEventsDesktop = {
                        start: c[0],
                        move: c[1],
                        end: c[2]
                    },
                    o.support.touch || !o.params.simulateTouch ? o.touchEventsTouch : o.touchEventsDesktop),
                    touchEventsData: {
                        isTouched: void 0,
                        isMoved: void 0,
                        allowTouchCallbacks: void 0,
                        touchStartTime: void 0,
                        isScrolling: void 0,
                        currentTranslate: void 0,
                        startTranslate: void 0,
                        allowThresholdMove: void 0,
                        formElements: "input, select, option, textarea, button, video, label",
                        lastClickTime: A(),
                        clickTimeout: void 0,
                        velocities: [],
                        allowMomentumBounce: void 0,
                        isTouchEvent: void 0,
                        startMoving: void 0
                    },
                    allowClick: !0,
                    allowTouchMove: o.params.allowTouchMove,
                    touches: {
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0,
                        diff: 0
                    },
                    imagesToLoad: [],
                    imagesLoaded: 0
                }),
                o.useModules(),
                o.emit("_swiper"),
                o.params.init && o.init(),
                o
            }
            var e, n, i, r = t.prototype;
            return r.setProgress = function(t, e) {
                t = Math.min(Math.max(t, 0), 1);
                var n = this.minTranslate()
                  , i = (this.maxTranslate() - n) * t + n;
                this.translateTo(i, void 0 === e ? 0 : e),
                this.updateActiveIndex(),
                this.updateSlidesClasses()
            }
            ,
            r.emitContainerClasses = function() {
                var t = this;
                if (t.params._emitClasses && t.el) {
                    var e = t.el.className.split(" ").filter((function(e) {
                        return 0 === e.indexOf("swiper-container") || 0 === e.indexOf(t.params.containerModifierClass)
                    }
                    ));
                    t.emit("_containerClasses", e.join(" "))
                }
            }
            ,
            r.getSlideClasses = function(t) {
                var e = this;
                return t.className.split(" ").filter((function(t) {
                    return 0 === t.indexOf("swiper-slide") || 0 === t.indexOf(e.params.slideClass)
                }
                )).join(" ")
            }
            ,
            r.emitSlidesClasses = function() {
                var t = this;
                if (t.params._emitClasses && t.el) {
                    var e = [];
                    t.slides.each((function(n) {
                        var i = t.getSlideClasses(n);
                        e.push({
                            slideEl: n,
                            classNames: i
                        }),
                        t.emit("_slideClass", n, i)
                    }
                    )),
                    t.emit("_slideClasses", e)
                }
            }
            ,
            r.slidesPerViewDynamic = function() {
                var t = this.params
                  , e = this.slides
                  , n = this.slidesGrid
                  , i = this.size
                  , r = this.activeIndex
                  , s = 1;
                if (t.centeredSlides) {
                    for (var a, o = e[r].swiperSlideSize, l = r + 1; l < e.length; l += 1)
                        e[l] && !a && (s += 1,
                        (o += e[l].swiperSlideSize) > i && (a = !0));
                    for (var c = r - 1; c >= 0; c -= 1)
                        e[c] && !a && (s += 1,
                        (o += e[c].swiperSlideSize) > i && (a = !0))
                } else
                    for (var h = r + 1; h < e.length; h += 1)
                        n[h] - n[r] < i && (s += 1);
                return s
            }
            ,
            r.update = function() {
                var t = this;
                if (t && !t.destroyed) {
                    var e = t.snapGrid
                      , n = t.params;
                    n.breakpoints && t.setBreakpoint(),
                    t.updateSize(),
                    t.updateSlides(),
                    t.updateProgress(),
                    t.updateSlidesClasses(),
                    t.params.freeMode ? (i(),
                    t.params.autoHeight && t.updateAutoHeight()) : (("auto" === t.params.slidesPerView || t.params.slidesPerView > 1) && t.isEnd && !t.params.centeredSlides ? t.slideTo(t.slides.length - 1, 0, !1, !0) : t.slideTo(t.activeIndex, 0, !1, !0)) || i(),
                    n.watchOverflow && e !== t.snapGrid && t.checkOverflow(),
                    t.emit("update")
                }
                function i() {
                    var e = t.rtlTranslate ? -1 * t.translate : t.translate
                      , n = Math.min(Math.max(e, t.maxTranslate()), t.minTranslate());
                    t.setTranslate(n),
                    t.updateActiveIndex(),
                    t.updateSlidesClasses()
                }
            }
            ,
            r.changeDirection = function(t, e) {
                void 0 === e && (e = !0);
                var n = this.params.direction;
                return t || (t = "horizontal" === n ? "vertical" : "horizontal"),
                t === n || "horizontal" !== t && "vertical" !== t || (this.$el.removeClass("" + this.params.containerModifierClass + n).addClass("" + this.params.containerModifierClass + t),
                this.emitContainerClasses(),
                this.params.direction = t,
                this.slides.each((function(e) {
                    "vertical" === t ? e.style.width = "" : e.style.height = ""
                }
                )),
                this.emit("changeDirection"),
                e && this.update()),
                this
            }
            ,
            r.mount = function(t) {
                if (this.mounted)
                    return !0;
                var e, n = E(t || this.params.el);
                return !!(t = n[0]) && (t.swiper = this,
                t && t.shadowRoot && t.shadowRoot.querySelector ? (e = E(t.shadowRoot.querySelector("." + this.params.wrapperClass))).children = function(t) {
                    return n.children(t)
                }
                : e = n.children("." + this.params.wrapperClass),
                R(this, {
                    $el: n,
                    el: t,
                    $wrapperEl: e,
                    wrapperEl: e[0],
                    mounted: !0,
                    rtl: "rtl" === t.dir.toLowerCase() || "rtl" === n.css("direction"),
                    rtlTranslate: "horizontal" === this.params.direction && ("rtl" === t.dir.toLowerCase() || "rtl" === n.css("direction")),
                    wrongRTL: "-webkit-box" === e.css("display")
                }),
                !0)
            }
            ,
            r.init = function(t) {
                return this.initialized || !1 === this.mount(t) || (this.emit("beforeInit"),
                this.params.breakpoints && this.setBreakpoint(),
                this.addClasses(),
                this.params.loop && this.loopCreate(),
                this.updateSize(),
                this.updateSlides(),
                this.params.watchOverflow && this.checkOverflow(),
                this.params.grabCursor && this.setGrabCursor(),
                this.params.preloadImages && this.preloadImages(),
                this.params.loop ? this.slideTo(this.params.initialSlide + this.loopedSlides, 0, this.params.runCallbacksOnInit) : this.slideTo(this.params.initialSlide, 0, this.params.runCallbacksOnInit),
                this.attachEvents(),
                this.initialized = !0,
                this.emit("init"),
                this.emit("afterInit")),
                this
            }
            ,
            r.destroy = function(t, e) {
                void 0 === t && (t = !0),
                void 0 === e && (e = !0);
                var n, i = this, r = i.params, s = i.$el, a = i.$wrapperEl, o = i.slides;
                return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"),
                i.initialized = !1,
                i.detachEvents(),
                r.loop && i.loopDestroy(),
                e && (i.removeClasses(),
                s.removeAttr("style"),
                a.removeAttr("style"),
                o && o.length && o.removeClass([r.slideVisibleClass, r.slideActiveClass, r.slideNextClass, r.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")),
                i.emit("destroy"),
                Object.keys(i.eventsListeners).forEach((function(t) {
                    i.off(t)
                }
                )),
                !1 !== t && (i.$el[0].swiper = null,
                n = i,
                Object.keys(n).forEach((function(t) {
                    try {
                        n[t] = null
                    } catch (t) {}
                    try {
                        delete n[t]
                    } catch (t) {}
                }
                ))),
                i.destroyed = !0),
                null
            }
            ,
            t.extendDefaults = function(t) {
                R($, t)
            }
            ,
            t.installModule = function(e) {
                t.prototype.modules || (t.prototype.modules = {});
                var n = e.name || Object.keys(t.prototype.modules).length + "_" + A();
                t.prototype.modules[n] = e
            }
            ,
            t.use = function(e) {
                return Array.isArray(e) ? (e.forEach((function(e) {
                    return t.installModule(e)
                }
                )),
                t) : (t.installModule(e),
                t)
            }
            ,
            e = t,
            i = [{
                key: "extendedDefaults",
                get: function() {
                    return $
                }
            }, {
                key: "defaults",
                get: function() {
                    return Y
                }
            }],
            (n = null) && Z(e.prototype, n),
            i && Z(e, i),
            t
        }();
        Object.keys(J).forEach((function(t) {
            Object.keys(J[t]).forEach((function(e) {
                K.prototype[e] = J[t][e]
            }
            ))
        }
        )),
        K.use([z, F]);
        var Q = K;
        function tt() {
            return (tt = Object.assign || function(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var n = arguments[e];
                    for (var i in n)
                        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
                }
                return t
            }
            ).apply(this, arguments)
        }
        var et = {
            toggleEl: function(t, e) {
                t[e ? "addClass" : "removeClass"](this.params.navigation.disabledClass),
                t[0] && "BUTTON" === t[0].tagName && (t[0].disabled = e)
            },
            update: function() {
                var t = this.params.navigation
                  , e = this.navigation.toggleEl;
                if (!this.params.loop) {
                    var n = this.navigation
                      , i = n.$nextEl
                      , r = n.$prevEl;
                    r && r.length > 0 && (this.isBeginning ? e(r, !0) : e(r, !1),
                    r[this.params.watchOverflow && this.isLocked ? "addClass" : "removeClass"](t.lockClass)),
                    i && i.length > 0 && (this.isEnd ? e(i, !0) : e(i, !1),
                    i[this.params.watchOverflow && this.isLocked ? "addClass" : "removeClass"](t.lockClass))
                }
            },
            onPrevClick: function(t) {
                t.preventDefault(),
                this.isBeginning && !this.params.loop || this.slidePrev()
            },
            onNextClick: function(t) {
                t.preventDefault(),
                this.isEnd && !this.params.loop || this.slideNext()
            },
            init: function() {
                var t, e, n = this.params.navigation;
                (n.nextEl || n.prevEl) && (n.nextEl && (t = E(n.nextEl),
                this.params.uniqueNavElements && "string" == typeof n.nextEl && t.length > 1 && 1 === this.$el.find(n.nextEl).length && (t = this.$el.find(n.nextEl))),
                n.prevEl && (e = E(n.prevEl),
                this.params.uniqueNavElements && "string" == typeof n.prevEl && e.length > 1 && 1 === this.$el.find(n.prevEl).length && (e = this.$el.find(n.prevEl))),
                t && t.length > 0 && t.on("click", this.navigation.onNextClick),
                e && e.length > 0 && e.on("click", this.navigation.onPrevClick),
                R(this.navigation, {
                    $nextEl: t,
                    nextEl: t && t[0],
                    $prevEl: e,
                    prevEl: e && e[0]
                }))
            },
            destroy: function() {
                var t = this.navigation
                  , e = t.$nextEl
                  , n = t.$prevEl;
                e && e.length && (e.off("click", this.navigation.onNextClick),
                e.removeClass(this.params.navigation.disabledClass)),
                n && n.length && (n.off("click", this.navigation.onPrevClick),
                n.removeClass(this.params.navigation.disabledClass))
            }
        }
          , nt = {
            name: "navigation",
            params: {
                navigation: {
                    nextEl: null,
                    prevEl: null,
                    hideOnClick: !1,
                    disabledClass: "swiper-button-disabled",
                    hiddenClass: "swiper-button-hidden",
                    lockClass: "swiper-button-lock"
                }
            },
            create: function() {
                I(this, {
                    navigation: tt({}, et)
                })
            },
            on: {
                init: function(t) {
                    t.navigation.init(),
                    t.navigation.update()
                },
                toEdge: function(t) {
                    t.navigation.update()
                },
                fromEdge: function(t) {
                    t.navigation.update()
                },
                destroy: function(t) {
                    t.navigation.destroy()
                },
                click: function(t, e) {
                    var n = t.navigation
                      , i = n.$nextEl
                      , r = n.$prevEl
                      , s = e.target;
                    if (t.params.navigation.hideOnClick && !E(s).is(r) && !E(s).is(i)) {
                        if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === s || t.pagination.el.contains(s)))
                            return;
                        var a;
                        i ? a = i.hasClass(t.params.navigation.hiddenClass) : r && (a = r.hasClass(t.params.navigation.hiddenClass)),
                        !0 === a ? t.emit("navigationShow") : t.emit("navigationHide"),
                        i && i.toggleClass(t.params.navigation.hiddenClass),
                        r && r.toggleClass(t.params.navigation.hiddenClass)
                    }
                }
            }
        };
        Q.use(nt);
        var it = document.querySelector("#js-swiper-button--prev")
          , rt = document.querySelector("#js-swiper-button--next")
          , st = null
          , at = 0
          , ot = function() {
            if (window.innerWidth > window.BREAKPOINT)
                st = new Q(".swiper-container",{
                    slidesPerView: 3.08,
                    spaceBetween: 40,
                    slidesPerGroup: 1,
                    centeredSlides: !0,
                    initialSlide: 1,
                    loop: !0,
                    speed: 400,
                    threshold: 50,
                    grabCursor: !0,
                    touchRatio: .5,
                    breakpoints: {
                        1200: {
                            slidesPerView: 3,
                            spaceBetween: 45
                        }
                    },
                    navigation: {
                        prevEl: it,
                        nextEl: rt
                    }
                });
            else {
                st = new Q(".swiper-container",{
                    slidesPerView: "auto",
                    slidesPerGroup: 1,
                    spaceBetween: 25,
                    loop: !1,
                    speed: 400,
                    threshold: 50,
                    grabCursor: !0,
                    touchRatio: .5,
                    on: {
                        transitionStart: function() {
                            t()
                        }
                    },
                    navigation: {
                        prevEl: it,
                        nextEl: rt
                    }
                });
                var t = function() {
                    window.innerWidth > window.BREAKPOINT || (0 === st.realIndex ? it.classList.add("is-hide-sp") : it.classList.remove("is-hide-sp"),
                    st.realIndex == st.slides.length - 2 && st.realIndex == at && (rt.classList.contains("is-hide-sp") ? rt.classList.remove("is-hide-sp") : rt.classList.add("is-hide-sp")),
                    at = st.realIndex)
                };
                t()
            }
        };
        window.matchMedia("(max-width: ".concat(window.BREAKPOINT, "px)")).addEventListener("change", (function() {
            it.classList.remove("is-hide-sp"),
            rt.classList.remove("is-hide-sp"),
            st.destroy(),
            st = null,
            ot()
        }
        ));
        n("rE2o"),
        n("ioFf"),
        n("rGqo");
        function lt(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        var ct = []
          , ht = window.innerWidth < window.BREAKPOINT
          , ut = function() {
            function t() {
                !function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }(this, t),
                this.$element = null,
                this.$inner = null,
                this.width = 0,
                this.isMoving = !1,
                this.isAnimating = !1,
                this.startPointX = 0,
                this.endPointX = 0,
                this.currentRotationVal = 0
            }
            var e, n, i;
            return e = t,
            (n = [{
                key: "init",
                value: function(t) {
                    var e = this;
                    this.$element = t,
                    this.$inner = t.querySelector(".js-flip-inner"),
                    this.width = t.clientWidth,
                    this.$element.addEventListener("touchstart", this.touchStartHandler.bind(this)),
                    this.$element.addEventListener("touchmove", this.touchMoveHandler.bind(this)),
                    this.$element.addEventListener("touchend", this.touchEndHandler.bind(this)),
                    this.$element.addEventListener("mouseover", (function() {
                        e.$element.classList.contains("is-pc") && e.$element.classList.add("is-hover")
                    }
                    )),
                    this.$element.addEventListener("mouseout", (function() {
                        e.$element.classList.contains("is-pc") && e.$element.classList.remove("is-hover")
                    }
                    ))
                }
            }, {
                key: "roll",
                value: function(t) {
                    this.$inner.style.transform = "rotateY(".concat(t, "deg)")
                }
            }, {
                key: "touchStartHandler",
                value: function(t) {
                    if (ht && !this.isMoving) {
                        var e = t.touches[0];
                        this.startPointX = e.clientX
                    }
                }
            }, {
                key: "touchMoveHandler",
                value: function(t) {
                    if (ht && !this.isAnimating) {
                        this.isMoving = !0;
                        var e = t.touches[0]
                          , n = 180 / this.width;
                        this.endPointX = (e.clientX - this.startPointX) * n,
                        this.endPointX > 180 || this.endPointX < -180 || this.roll(this.currentRotationVal + this.endPointX)
                    }
                }
            }, {
                key: "touchEndHandler",
                value: function() {
                    var t = this;
                    ht && this.isMoving && !this.isAnimating && (this.isMoving = !1,
                    this.currentRotationVal + this.endPointX > this.currentRotationVal + 90 && (this.currentRotationVal = this.currentRotationVal + 180),
                    this.currentRotationVal + this.endPointX < this.currentRotationVal - 90 && (this.currentRotationVal = this.currentRotationVal - 180),
                    this.$element.classList.add("is-animating"),
                    this.$inner.style.transform = "rotateY(".concat(this.currentRotationVal, "deg)"),
                    this.isAnimating = !0,
                    setTimeout((function() {
                        t.$element.classList.remove("is-animating"),
                        t.isAnimating = !1
                    }
                    ), 800),
                    this.startPointX = 0)
                }
            }, {
                key: "resize",
                value: function() {
                    ht ? this.$element.classList.remove("is-pc") : this.$element.classList.add("is-pc"),
                    this.$inner.style.transform = ""
                }
            }]) && lt(e.prototype, n),
            i && lt(e, i),
            t
        }()
          , dt = (n("XfO3"),
        n("HEwt"),
        n("a1Th"),
        n("Btvt"),
        n("Z2Ku"),
        n("L9s1"),
        n("KKXr"),
        n("Haw6"));
        function pt(t) {
            return function(t) {
                if (Array.isArray(t)) {
                    for (var e = 0, n = new Array(t.length); e < t.length; e++)
                        n[e] = t[e];
                    return n
                }
            }(t) || function(t) {
                if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t))
                    return Array.from(t)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance")
            }()
        }
        gsap.registerPlugin(dt.a);
        var ft = function() {
            var t = pt(document.querySelectorAll(".js-heading-animation"))
              , e = !0
              , n = !1
              , i = void 0;
            try {
                for (var r, s = function() {
                    var t, e, n = r.value;
                    n.innerHTML.includes("span") || (n.innerHTML = (t = pt(n.childNodes),
                    e = "",
                    t.forEach((function(t) {
                        var n = t.textContent;
                        e += n.split("").reduce((function(t, e) {
                            return t + "<span>".concat(e, "</span>")
                        }
                        ), "")
                    }
                    )),
                    e));
                    var i = n.getAttribute("data-fade-trigger");
                    gsap.to(n, {
                        onComplete: function() {
                            n.classList.add("is-active"),
                            i && function(t) {
                                gsap.to('[data-fade-id="'.concat(t, '"]'), {
                                    ease: "power0",
                                    duration: .6,
                                    delay: .4,
                                    opacity: 1
                                })
                            }(i)
                        },
                        scrollTrigger: {
                            trigger: n,
                            start: "top bottom",
                            end: "top bottom"
                        }
                    })
                }, a = t[Symbol.iterator](); !(e = (r = a.next()).done); e = !0)
                    s()
            } catch (t) {
                n = !0,
                i = t
            } finally {
                try {
                    e || null == a.return || a.return()
                } finally {
                    if (n)
                        throw i
                }
            }
        };
        gsap.registerPlugin(dt.a);
        var mt = "#88ddcf"
          , gt = "#47baa2";
        function vt(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        var yt = function() {
            function t() {
                !function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }(this, t),
                this.$element = null,
                this.rect = null,
                this.defaultPosition = {
                    x: 0,
                    y: 0
                },
                this.offsetPosition = {
                    x: 0,
                    y: 0
                },
                this.velocity = {
                    x: 0,
                    y: 0
                },
                this.acceleration = {
                    x: 0,
                    y: 0
                },
                this.moveSpeed = 60,
                this.maxSpeed = 10,
                this.friction = .9,
                this.defaultFloatValue = .08,
                this.defaultFloatSpeed = .025,
                this.defaultFloatStart = 0,
                this.count = 0
            }
            var e, n, i;
            return e = t,
            (n = [{
                key: "init",
                value: function(t) {
                    this.$element = t,
                    this.rect = t.getBoundingClientRect(),
                    this.defaultPosition.x = this.rect.left,
                    this.defaultPosition.y = this.rect.top + window.pageYOffset,
                    this.defaultFloatStart = 10 * Math.random()
                }
            }, {
                key: "update",
                value: function(t, e) {
                    if (window.innerWidth > window.BREAKPOINT) {
                        var n = this.offsetPosition.x + this.defaultPosition.x
                          , i = this.offsetPosition.y + this.defaultPosition.y
                          , r = Math.sqrt(Math.pow(t.x - n, 2) + Math.pow(t.y - i, 2));
                        r < 300 && (r = Math.max(Math.min(r, 50), 20),
                        this.acceleration.x = e.x * (this.moveSpeed / (r * r)),
                        this.acceleration.y = e.y * (this.moveSpeed / (r * r)));
                        var s = {
                            x: -this.offsetPosition.x,
                            y: -this.offsetPosition.y
                        }
                          , a = Math.sqrt(Math.pow(s.x, 2) + Math.pow(s.y, 2))
                          , o = Math.sqrt(Math.pow(s.x, 2) + Math.pow(s.y, 2));
                        s.x /= o > 0 ? o : 1,
                        s.y /= o > 0 ? o : 1;
                        var l = this.moveSpeed * a * 2e-4;
                        this.acceleration.x += s.x * l,
                        this.acceleration.y += s.y * l,
                        this.velocity.x += this.acceleration.x,
                        this.velocity.y += this.acceleration.y,
                        this.velocity.y += Math.sin(this.count * this.defaultFloatSpeed + this.defaultFloatStart) * this.defaultFloatValue,
                        this.velocity.x *= this.friction,
                        this.velocity.y *= this.friction
                    } else
                        this.velocity.y = Math.sin(this.count * this.defaultFloatSpeed + this.defaultFloatStart) * this.defaultFloatValue * 1.5;
                    this.offsetPosition.x += this.velocity.x,
                    this.offsetPosition.y += this.velocity.y,
                    this.acceleration.x = 0,
                    this.acceleration.y = 0,
                    this.count++
                }
            }, {
                key: "draw",
                value: function() {
                    var t = this.offsetPosition.x
                      , e = this.offsetPosition.y;
                    this.$element.style.transform = "translate(".concat(t, "px, ").concat(e, "px)")
                }
            }, {
                key: "resetPosition",
                value: function() {
                    this.rect = this.$element.getBoundingClientRect(),
                    this.defaultPosition.x = this.rect.left,
                    this.defaultPosition.y = this.rect.top + window.pageYOffset
                }
            }, {
                key: "loop",
                value: function(t, e) {
                    this.update(t, e),
                    this.draw()
                }
            }]) && vt(e.prototype, n),
            i && vt(e, i),
            t
        }();
        function xt(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        var _t = new (function() {
            function t() {
                !function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }(this, t);
                var e = navigator.userAgent.toLowerCase();
                this.sp = -1 !== e.indexOf("iphone") || -1 !== e.indexOf("android") && -1 !== e.indexOf("mobile"),
                this.ipad = -1 !== e.indexOf("ipad") || -1 !== e.indexOf("macintosh") && "ontouchend"in document,
                this.tab = !this.sp && (this.ipad || -1 !== e.indexOf("android")),
                this.touch = "ontouchend"in document,
                this.msie = -1 !== e.indexOf("msie") || -1 !== e.indexOf("trident"),
                this.edge = -1 !== e.indexOf("edge"),
                this.safari = -1 !== e.indexOf("safari") && -1 === e.indexOf("chrome"),
                this.firefox = -1 !== e.indexOf("firefox"),
                this.android = -1 !== e.indexOf("android"),
                this.chrome = -1 !== e.indexOf("chrome")
            }
            var e, n, i;
            return e = t,
            (n = [{
                key: "isSp",
                value: function() {
                    return !!this.sp
                }
            }, {
                key: "isAndroid",
                value: function() {
                    return !!this.android
                }
            }, {
                key: "isTab",
                value: function() {
                    return !!this.tab
                }
            }, {
                key: "isTouch",
                value: function() {
                    return !!this.touch
                }
            }, {
                key: "isMSIE",
                value: function() {
                    return !!this.msie
                }
            }, {
                key: "isEdge",
                value: function() {
                    return !!this.edge
                }
            }, {
                key: "isSafari",
                value: function() {
                    return !!this.safari
                }
            }, {
                key: "isFirefox",
                value: function() {
                    return !!this.firefox
                }
            }, {
                key: "isChrome",
                value: function() {
                    return !!this.chrome
                }
            }]) && xt(e.prototype, n),
            i && xt(e, i),
            t
        }());
        function wt(t) {
            return function(t) {
                if (Array.isArray(t)) {
                    for (var e = 0, n = new Array(t.length); e < t.length; e++)
                        n[e] = t[e];
                    return n
                }
            }(t) || function(t) {
                if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t))
                    return Array.from(t)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance")
            }()
        }
        var bt = null
          , Mt = []
          , St = []
          , Tt = !1;
        class Et {
            addEventListener(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []),
                -1 === n[t].indexOf(e) && n[t].push(e)
            }
            hasEventListener(t, e) {
                if (void 0 === this._listeners)
                    return !1;
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            }
            removeEventListener(t, e) {
                if (void 0 === this._listeners)
                    return;
                const n = this._listeners[t];
                if (void 0 !== n) {
                    const t = n.indexOf(e);
                    -1 !== t && n.splice(t, 1)
                }
            }
            dispatchEvent(t) {
                if (void 0 === this._listeners)
                    return;
                const e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    const n = e.slice(0);
                    for (let e = 0, i = n.length; e < i; e++)
                        n[e].call(this, t);
                    t.target = null
                }
            }
        }
        const Lt = [];
        for (let t = 0; t < 256; t++)
            Lt[t] = (t < 16 ? "0" : "") + t.toString(16);
        const At = Math.PI / 180
          , Ct = 180 / Math.PI;
        function Pt() {
            const t = 4294967295 * Math.random() | 0
              , e = 4294967295 * Math.random() | 0
              , n = 4294967295 * Math.random() | 0
              , i = 4294967295 * Math.random() | 0;
            return (Lt[255 & t] + Lt[t >> 8 & 255] + Lt[t >> 16 & 255] + Lt[t >> 24 & 255] + "-" + Lt[255 & e] + Lt[e >> 8 & 255] + "-" + Lt[e >> 16 & 15 | 64] + Lt[e >> 24 & 255] + "-" + Lt[63 & n | 128] + Lt[n >> 8 & 255] + "-" + Lt[n >> 16 & 255] + Lt[n >> 24 & 255] + Lt[255 & i] + Lt[i >> 8 & 255] + Lt[i >> 16 & 255] + Lt[i >> 24 & 255]).toUpperCase()
        }
        function Rt(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }
        function It(t, e) {
            return (t % e + e) % e
        }
        function Dt(t, e, n) {
            return (1 - n) * t + n * e
        }
        function Nt(t) {
            return 0 == (t & t - 1) && 0 !== t
        }
        function Ot(t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        }
        function zt(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }
        class Bt {
            constructor(t=0, e=0) {
                this.x = t,
                this.y = e
            }
            get width() {
                return this.x
            }
            set width(t) {
                this.x = t
            }
            get height() {
                return this.y
            }
            set height(t) {
                this.y = t
            }
            set(t, e) {
                return this.x = t,
                this.y = e,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this)
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this)
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this
            }
            multiply(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this
            }
            divide(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            applyMatrix3(t) {
                const e = this.x
                  , n = this.y
                  , i = t.elements;
                return this.x = i[0] * e + i[3] * n + i[6],
                this.y = i[1] * e + i[4] * n + i[7],
                this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x
                  , n = this.y - t.y;
                return e * e + n * n
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
                this.x = t.getX(e),
                this.y = t.getY(e),
                this
            }
            rotateAround(t, e) {
                const n = Math.cos(e)
                  , i = Math.sin(e)
                  , r = this.x - t.x
                  , s = this.y - t.y;
                return this.x = r * n - s * i + t.x,
                this.y = r * i + s * n + t.y,
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this
            }
        }
        Bt.prototype.isVector2 = !0;
        class kt {
            constructor() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            set(t, e, n, i, r, s, a, o, l) {
                const c = this.elements;
                return c[0] = t,
                c[1] = i,
                c[2] = a,
                c[3] = e,
                c[4] = r,
                c[5] = o,
                c[6] = n,
                c[7] = s,
                c[8] = l,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                this
            }
            copy(t) {
                const e = this.elements
                  , n = t.elements;
                return e[0] = n[0],
                e[1] = n[1],
                e[2] = n[2],
                e[3] = n[3],
                e[4] = n[4],
                e[5] = n[5],
                e[6] = n[6],
                e[7] = n[7],
                e[8] = n[8],
                this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrix3Column(this, 0),
                e.setFromMatrix3Column(this, 1),
                n.setFromMatrix3Column(this, 2),
                this
            }
            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
                this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements
                  , i = e.elements
                  , r = this.elements
                  , s = n[0]
                  , a = n[3]
                  , o = n[6]
                  , l = n[1]
                  , c = n[4]
                  , h = n[7]
                  , u = n[2]
                  , d = n[5]
                  , p = n[8]
                  , f = i[0]
                  , m = i[3]
                  , g = i[6]
                  , v = i[1]
                  , y = i[4]
                  , x = i[7]
                  , _ = i[2]
                  , w = i[5]
                  , b = i[8];
                return r[0] = s * f + a * v + o * _,
                r[3] = s * m + a * y + o * w,
                r[6] = s * g + a * x + o * b,
                r[1] = l * f + c * v + h * _,
                r[4] = l * m + c * y + h * w,
                r[7] = l * g + c * x + h * b,
                r[2] = u * f + d * v + p * _,
                r[5] = u * m + d * y + p * w,
                r[8] = u * g + d * x + p * b,
                this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t,
                e[3] *= t,
                e[6] *= t,
                e[1] *= t,
                e[4] *= t,
                e[7] *= t,
                e[2] *= t,
                e[5] *= t,
                e[8] *= t,
                this
            }
            determinant() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , i = t[2]
                  , r = t[3]
                  , s = t[4]
                  , a = t[5]
                  , o = t[6]
                  , l = t[7]
                  , c = t[8];
                return e * s * c - e * a * l - n * r * c + n * a * o + i * r * l - i * s * o
            }
            invert() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , i = t[2]
                  , r = t[3]
                  , s = t[4]
                  , a = t[5]
                  , o = t[6]
                  , l = t[7]
                  , c = t[8]
                  , h = c * s - a * l
                  , u = a * o - c * r
                  , d = l * r - s * o
                  , p = e * h + n * u + i * d;
                if (0 === p)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return t[0] = h * f,
                t[1] = (i * l - c * n) * f,
                t[2] = (a * n - i * s) * f,
                t[3] = u * f,
                t[4] = (c * e - i * o) * f,
                t[5] = (i * r - a * e) * f,
                t[6] = d * f,
                t[7] = (n * o - l * e) * f,
                t[8] = (s * e - n * r) * f,
                this
            }
            transpose() {
                let t;
                const e = this.elements;
                return t = e[1],
                e[1] = e[3],
                e[3] = t,
                t = e[2],
                e[2] = e[6],
                e[6] = t,
                t = e[5],
                e[5] = e[7],
                e[7] = t,
                this
            }
            getNormalMatrix(t) {
                return this.setFromMatrix4(t).invert().transpose()
            }
            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0],
                t[1] = e[3],
                t[2] = e[6],
                t[3] = e[1],
                t[4] = e[4],
                t[5] = e[7],
                t[6] = e[2],
                t[7] = e[5],
                t[8] = e[8],
                this
            }
            setUvTransform(t, e, n, i, r, s, a) {
                const o = Math.cos(r)
                  , l = Math.sin(r);
                return this.set(n * o, n * l, -n * (o * s + l * a) + s + t, -i * l, i * o, -i * (-l * s + o * a) + a + e, 0, 0, 1),
                this
            }
            scale(t, e) {
                const n = this.elements;
                return n[0] *= t,
                n[3] *= t,
                n[6] *= t,
                n[1] *= e,
                n[4] *= e,
                n[7] *= e,
                this
            }
            rotate(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t)
                  , i = this.elements
                  , r = i[0]
                  , s = i[3]
                  , a = i[6]
                  , o = i[1]
                  , l = i[4]
                  , c = i[7];
                return i[0] = e * r + n * o,
                i[3] = e * s + n * l,
                i[6] = e * a + n * c,
                i[1] = -n * r + e * o,
                i[4] = -n * s + e * l,
                i[7] = -n * a + e * c,
                this
            }
            translate(t, e) {
                const n = this.elements;
                return n[0] += t * n[2],
                n[3] += t * n[5],
                n[6] += t * n[8],
                n[1] += e * n[2],
                n[4] += e * n[5],
                n[7] += e * n[8],
                this
            }
            equals(t) {
                const e = this.elements
                  , n = t.elements;
                for (let t = 0; t < 9; t++)
                    if (e[t] !== n[t])
                        return !1;
                return !0
            }
            fromArray(t, e=0) {
                for (let n = 0; n < 9; n++)
                    this.elements[n] = t[n + e];
                return this
            }
            toArray(t=[], e=0) {
                const n = this.elements;
                return t[e] = n[0],
                t[e + 1] = n[1],
                t[e + 2] = n[2],
                t[e + 3] = n[3],
                t[e + 4] = n[4],
                t[e + 5] = n[5],
                t[e + 6] = n[6],
                t[e + 7] = n[7],
                t[e + 8] = n[8],
                t
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        let Ft;
        kt.prototype.isMatrix3 = !0;
        class Ht {
            static getDataURL(t) {
                if (/^data:/i.test(t.src))
                    return t.src;
                if ("undefined" == typeof HTMLCanvasElement)
                    return t.src;
                let e;
                if (t instanceof HTMLCanvasElement)
                    e = t;
                else {
                    void 0 === Ft && (Ft = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                    Ft.width = t.width,
                    Ft.height = t.height;
                    const n = Ft.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height),
                    e = Ft
                }
                return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t),
                e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
            }
        }
        let Ut = 0;
        class Gt extends Et {
            constructor(t=Gt.DEFAULT_IMAGE, e=Gt.DEFAULT_MAPPING, n=1001, i=1001, r=1006, s=1008, a=1023, o=1009, l=1, c=3e3) {
                super(),
                Object.defineProperty(this, "id", {
                    value: Ut++
                }),
                this.uuid = Pt(),
                this.name = "",
                this.image = t,
                this.mipmaps = [],
                this.mapping = e,
                this.wrapS = n,
                this.wrapT = i,
                this.magFilter = r,
                this.minFilter = s,
                this.anisotropy = l,
                this.format = a,
                this.internalFormat = null,
                this.type = o,
                this.offset = new Bt(0,0),
                this.repeat = new Bt(1,1),
                this.center = new Bt(0,0),
                this.rotation = 0,
                this.matrixAutoUpdate = !0,
                this.matrix = new kt,
                this.generateMipmaps = !0,
                this.premultiplyAlpha = !1,
                this.flipY = !0,
                this.unpackAlignment = 4,
                this.encoding = c,
                this.version = 0,
                this.onUpdate = null
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.name = t.name,
                this.image = t.image,
                this.mipmaps = t.mipmaps.slice(0),
                this.mapping = t.mapping,
                this.wrapS = t.wrapS,
                this.wrapT = t.wrapT,
                this.magFilter = t.magFilter,
                this.minFilter = t.minFilter,
                this.anisotropy = t.anisotropy,
                this.format = t.format,
                this.internalFormat = t.internalFormat,
                this.type = t.type,
                this.offset.copy(t.offset),
                this.repeat.copy(t.repeat),
                this.center.copy(t.center),
                this.rotation = t.rotation,
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this.matrix.copy(t.matrix),
                this.generateMipmaps = t.generateMipmaps,
                this.premultiplyAlpha = t.premultiplyAlpha,
                this.flipY = t.flipY,
                this.unpackAlignment = t.unpackAlignment,
                this.encoding = t.encoding,
                this
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid])
                    return t.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (void 0 !== this.image) {
                    const i = this.image;
                    if (void 0 === i.uuid && (i.uuid = Pt()),
                    !e && void 0 === t.images[i.uuid]) {
                        let e;
                        if (Array.isArray(i)) {
                            e = [];
                            for (let t = 0, n = i.length; t < n; t++)
                                i[t].isDataTexture ? e.push(Vt(i[t].image)) : e.push(Vt(i[t]))
                        } else
                            e = Vt(i);
                        t.images[i.uuid] = {
                            uuid: i.uuid,
                            url: e
                        }
                    }
                    n.image = i.uuid
                }
                return e || (t.textures[this.uuid] = n),
                n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(t) {
                if (300 !== this.mapping)
                    return t;
                if (t.applyMatrix3(this.matrix),
                t.x < 0 || t.x > 1)
                    switch (this.wrapS) {
                    case 1e3:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case 1001:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case 1002:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                if (t.y < 0 || t.y > 1)
                    switch (this.wrapT) {
                    case 1e3:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case 1001:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case 1002:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                return this.flipY && (t.y = 1 - t.y),
                t
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        function Vt(t) {
            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? Ht.getDataURL(t) : t.data ? {
                data: Array.prototype.slice.call(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."),
            {})
        }
        Gt.DEFAULT_IMAGE = void 0,
        Gt.DEFAULT_MAPPING = 300,
        Gt.prototype.isTexture = !0;
        class Wt {
            constructor(t=0, e=0, n=0, i=1) {
                this.x = t,
                this.y = e,
                this.z = n,
                this.w = i
            }
            get width() {
                return this.z
            }
            set width(t) {
                this.z = t
            }
            get height() {
                return this.w
            }
            set height(t) {
                this.w = t
            }
            set(t, e, n, i) {
                return this.x = t,
                this.y = e,
                this.z = n,
                this.w = i,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this.z = t,
                this.w = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setZ(t) {
                return this.z = t,
                this
            }
            setW(t) {
                return this.w = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this.z = t.z,
                this.w = void 0 !== t.w ? t.w : 1,
                this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this.z += t.z,
                this.w += t.w,
                this)
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this.z += t,
                this.w += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this.z = t.z + e.z,
                this.w = t.w + e.w,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this.z += t.z * e,
                this.w += t.w * e,
                this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this.z -= t.z,
                this.w -= t.w,
                this)
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this.z -= t,
                this.w -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this.z = t.z - e.z,
                this.w = t.w - e.w,
                this
            }
            multiply(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this.z *= t.z,
                this.w *= t.w,
                this
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this.z *= t,
                this.w *= t,
                this
            }
            applyMatrix4(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = this.w
                  , s = t.elements;
                return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r,
                this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r,
                this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r,
                this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            setAxisAngleFromQuaternion(t) {
                this.w = 2 * Math.acos(t.w);
                const e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1,
                this.y = 0,
                this.z = 0) : (this.x = t.x / e,
                this.y = t.y / e,
                this.z = t.z / e),
                this
            }
            setAxisAngleFromRotationMatrix(t) {
                let e, n, i, r;
                const s = t.elements
                  , a = s[0]
                  , o = s[4]
                  , l = s[8]
                  , c = s[1]
                  , h = s[5]
                  , u = s[9]
                  , d = s[2]
                  , p = s[6]
                  , f = s[10];
                if (Math.abs(o - c) < .01 && Math.abs(l - d) < .01 && Math.abs(u - p) < .01) {
                    if (Math.abs(o + c) < .1 && Math.abs(l + d) < .1 && Math.abs(u + p) < .1 && Math.abs(a + h + f - 3) < .1)
                        return this.set(1, 0, 0, 0),
                        this;
                    e = Math.PI;
                    const t = (a + 1) / 2
                      , s = (h + 1) / 2
                      , m = (f + 1) / 2
                      , g = (o + c) / 4
                      , v = (l + d) / 4
                      , y = (u + p) / 4;
                    return t > s && t > m ? t < .01 ? (n = 0,
                    i = .707106781,
                    r = .707106781) : (n = Math.sqrt(t),
                    i = g / n,
                    r = v / n) : s > m ? s < .01 ? (n = .707106781,
                    i = 0,
                    r = .707106781) : (i = Math.sqrt(s),
                    n = g / i,
                    r = y / i) : m < .01 ? (n = .707106781,
                    i = .707106781,
                    r = 0) : (r = Math.sqrt(m),
                    n = v / r,
                    i = y / r),
                    this.set(n, i, r, e),
                    this
                }
                let m = Math.sqrt((p - u) * (p - u) + (l - d) * (l - d) + (c - o) * (c - o));
                return Math.abs(m) < .001 && (m = 1),
                this.x = (p - u) / m,
                this.y = (l - d) / m,
                this.z = (c - o) / m,
                this.w = Math.acos((a + h + f - 1) / 2),
                this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this.z = Math.min(this.z, t.z),
                this.w = Math.min(this.w, t.w),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this.z = Math.max(this.z, t.z),
                this.w = Math.max(this.w, t.w),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this.z = Math.max(t.z, Math.min(e.z, this.z)),
                this.w = Math.max(t.w, Math.min(e.w, this.w)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this.z = Math.max(t, Math.min(e, this.z)),
                this.w = Math.max(t, Math.min(e, this.w)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this.w = Math.floor(this.w),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this.w = Math.ceil(this.w),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this.w = Math.round(this.w),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this.w = -this.w,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this.z += (t.z - this.z) * e,
                this.w += (t.w - this.w) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this.z = t.z + (e.z - t.z) * n,
                this.w = t.w + (e.w - t.w) * n,
                this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this.z = t[e + 2],
                this.w = t[e + 3],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t[e + 2] = this.z,
                t[e + 3] = this.w,
                t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
                this.x = t.getX(e),
                this.y = t.getY(e),
                this.z = t.getZ(e),
                this.w = t.getW(e),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this.w = Math.random(),
                this
            }
        }
        Wt.prototype.isVector4 = !0;
        class jt extends Et {
            constructor(t, e, n) {
                super(),
                this.width = t,
                this.height = e,
                this.depth = 1,
                this.scissor = new Wt(0,0,t,e),
                this.scissorTest = !1,
                this.viewport = new Wt(0,0,t,e),
                n = n || {},
                this.texture = new Gt(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
                this.texture.image = {},
                this.texture.image.width = t,
                this.texture.image.height = e,
                this.texture.image.depth = 1,
                this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps,
                this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006,
                this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
                this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer,
                this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }
            setTexture(t) {
                t.image = {
                    width: this.width,
                    height: this.height,
                    depth: this.depth
                },
                this.texture = t
            }
            setSize(t, e, n=1) {
                this.width === t && this.height === e && this.depth === n || (this.width = t,
                this.height = e,
                this.depth = n,
                this.texture.image.width = t,
                this.texture.image.height = e,
                this.texture.image.depth = n,
                this.dispose()),
                this.viewport.set(0, 0, t, e),
                this.scissor.set(0, 0, t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.width = t.width,
                this.height = t.height,
                this.depth = t.depth,
                this.viewport.copy(t.viewport),
                this.texture = t.texture.clone(),
                this.depthBuffer = t.depthBuffer,
                this.stencilBuffer = t.stencilBuffer,
                this.depthTexture = t.depthTexture,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        jt.prototype.isWebGLRenderTarget = !0;
        (class extends jt {
            constructor(t, e, n) {
                super(t, e, n),
                this.samples = 4
            }
            copy(t) {
                return super.copy.call(this, t),
                this.samples = t.samples,
                this
            }
        }
        ).prototype.isWebGLMultisampleRenderTarget = !0;
        class qt {
            constructor(t=0, e=0, n=0, i=1) {
                this._x = t,
                this._y = e,
                this._z = n,
                this._w = i
            }
            static slerp(t, e, n, i) {
                return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),
                n.slerpQuaternions(t, e, i)
            }
            static slerpFlat(t, e, n, i, r, s, a) {
                let o = n[i + 0]
                  , l = n[i + 1]
                  , c = n[i + 2]
                  , h = n[i + 3];
                const u = r[s + 0]
                  , d = r[s + 1]
                  , p = r[s + 2]
                  , f = r[s + 3];
                if (0 === a)
                    return t[e + 0] = o,
                    t[e + 1] = l,
                    t[e + 2] = c,
                    void (t[e + 3] = h);
                if (1 === a)
                    return t[e + 0] = u,
                    t[e + 1] = d,
                    t[e + 2] = p,
                    void (t[e + 3] = f);
                if (h !== f || o !== u || l !== d || c !== p) {
                    let t = 1 - a;
                    const e = o * u + l * d + c * p + h * f
                      , n = e >= 0 ? 1 : -1
                      , i = 1 - e * e;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i)
                          , s = Math.atan2(r, e * n);
                        t = Math.sin(t * s) / r,
                        a = Math.sin(a * s) / r
                    }
                    const r = a * n;
                    if (o = o * t + u * r,
                    l = l * t + d * r,
                    c = c * t + p * r,
                    h = h * t + f * r,
                    t === 1 - a) {
                        const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                        o *= t,
                        l *= t,
                        c *= t,
                        h *= t
                    }
                }
                t[e] = o,
                t[e + 1] = l,
                t[e + 2] = c,
                t[e + 3] = h
            }
            static multiplyQuaternionsFlat(t, e, n, i, r, s) {
                const a = n[i]
                  , o = n[i + 1]
                  , l = n[i + 2]
                  , c = n[i + 3]
                  , h = r[s]
                  , u = r[s + 1]
                  , d = r[s + 2]
                  , p = r[s + 3];
                return t[e] = a * p + c * h + o * d - l * u,
                t[e + 1] = o * p + c * u + l * h - a * d,
                t[e + 2] = l * p + c * d + a * u - o * h,
                t[e + 3] = c * p - a * h - o * u - l * d,
                t
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t,
                this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(t) {
                this._w = t,
                this._onChangeCallback()
            }
            set(t, e, n, i) {
                return this._x = t,
                this._y = e,
                this._z = n,
                this._w = i,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copy(t) {
                return this._x = t.x,
                this._y = t.y,
                this._z = t.z,
                this._w = t.w,
                this._onChangeCallback(),
                this
            }
            setFromEuler(t, e) {
                if (!t || !t.isEuler)
                    throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                const n = t._x
                  , i = t._y
                  , r = t._z
                  , s = t._order
                  , a = Math.cos
                  , o = Math.sin
                  , l = a(n / 2)
                  , c = a(i / 2)
                  , h = a(r / 2)
                  , u = o(n / 2)
                  , d = o(i / 2)
                  , p = o(r / 2);
                switch (s) {
                case "XYZ":
                    this._x = u * c * h + l * d * p,
                    this._y = l * d * h - u * c * p,
                    this._z = l * c * p + u * d * h,
                    this._w = l * c * h - u * d * p;
                    break;
                case "YXZ":
                    this._x = u * c * h + l * d * p,
                    this._y = l * d * h - u * c * p,
                    this._z = l * c * p - u * d * h,
                    this._w = l * c * h + u * d * p;
                    break;
                case "ZXY":
                    this._x = u * c * h - l * d * p,
                    this._y = l * d * h + u * c * p,
                    this._z = l * c * p + u * d * h,
                    this._w = l * c * h - u * d * p;
                    break;
                case "ZYX":
                    this._x = u * c * h - l * d * p,
                    this._y = l * d * h + u * c * p,
                    this._z = l * c * p - u * d * h,
                    this._w = l * c * h + u * d * p;
                    break;
                case "YZX":
                    this._x = u * c * h + l * d * p,
                    this._y = l * d * h + u * c * p,
                    this._z = l * c * p - u * d * h,
                    this._w = l * c * h - u * d * p;
                    break;
                case "XZY":
                    this._x = u * c * h - l * d * p,
                    this._y = l * d * h - u * c * p,
                    this._z = l * c * p + u * d * h,
                    this._w = l * c * h + u * d * p;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                }
                return !1 !== e && this._onChangeCallback(),
                this
            }
            setFromAxisAngle(t, e) {
                const n = e / 2
                  , i = Math.sin(n);
                return this._x = t.x * i,
                this._y = t.y * i,
                this._z = t.z * i,
                this._w = Math.cos(n),
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(t) {
                const e = t.elements
                  , n = e[0]
                  , i = e[4]
                  , r = e[8]
                  , s = e[1]
                  , a = e[5]
                  , o = e[9]
                  , l = e[2]
                  , c = e[6]
                  , h = e[10]
                  , u = n + a + h;
                if (u > 0) {
                    const t = .5 / Math.sqrt(u + 1);
                    this._w = .25 / t,
                    this._x = (c - o) * t,
                    this._y = (r - l) * t,
                    this._z = (s - i) * t
                } else if (n > a && n > h) {
                    const t = 2 * Math.sqrt(1 + n - a - h);
                    this._w = (c - o) / t,
                    this._x = .25 * t,
                    this._y = (i + s) / t,
                    this._z = (r + l) / t
                } else if (a > h) {
                    const t = 2 * Math.sqrt(1 + a - n - h);
                    this._w = (r - l) / t,
                    this._x = (i + s) / t,
                    this._y = .25 * t,
                    this._z = (o + c) / t
                } else {
                    const t = 2 * Math.sqrt(1 + h - n - a);
                    this._w = (s - i) / t,
                    this._x = (r + l) / t,
                    this._y = (o + c) / t,
                    this._z = .25 * t
                }
                return this._onChangeCallback(),
                this
            }
            setFromUnitVectors(t, e) {
                let n = t.dot(e) + 1;
                return n < Number.EPSILON ? (n = 0,
                Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y,
                this._y = t.x,
                this._z = 0,
                this._w = n) : (this._x = 0,
                this._y = -t.z,
                this._z = t.y,
                this._w = n)) : (this._x = t.y * e.z - t.z * e.y,
                this._y = t.z * e.x - t.x * e.z,
                this._z = t.x * e.y - t.y * e.x,
                this._w = n),
                this.normalize()
            }
            angleTo(t) {
                return 2 * Math.acos(Math.abs(Rt(this.dot(t), -1, 1)))
            }
            rotateTowards(t, e) {
                const n = this.angleTo(t);
                if (0 === n)
                    return this;
                const i = Math.min(1, e / n);
                return this.slerp(t, i),
                this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._onChangeCallback(),
                this
            }
            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0,
                this._y = 0,
                this._z = 0,
                this._w = 1) : (t = 1 / t,
                this._x = this._x * t,
                this._y = this._y * t,
                this._z = this._z * t,
                this._w = this._w * t),
                this._onChangeCallback(),
                this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
                this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            }
            premultiply(t) {
                return this.multiplyQuaternions(t, this)
            }
            multiplyQuaternions(t, e) {
                const n = t._x
                  , i = t._y
                  , r = t._z
                  , s = t._w
                  , a = e._x
                  , o = e._y
                  , l = e._z
                  , c = e._w;
                return this._x = n * c + s * a + i * l - r * o,
                this._y = i * c + s * o + r * a - n * l,
                this._z = r * c + s * l + n * o - i * a,
                this._w = s * c - n * a - i * o - r * l,
                this._onChangeCallback(),
                this
            }
            slerp(t, e) {
                if (0 === e)
                    return this;
                if (1 === e)
                    return this.copy(t);
                const n = this._x
                  , i = this._y
                  , r = this._z
                  , s = this._w;
                let a = s * t._w + n * t._x + i * t._y + r * t._z;
                if (a < 0 ? (this._w = -t._w,
                this._x = -t._x,
                this._y = -t._y,
                this._z = -t._z,
                a = -a) : this.copy(t),
                a >= 1)
                    return this._w = s,
                    this._x = n,
                    this._y = i,
                    this._z = r,
                    this;
                const o = 1 - a * a;
                if (o <= Number.EPSILON) {
                    const t = 1 - e;
                    return this._w = t * s + e * this._w,
                    this._x = t * n + e * this._x,
                    this._y = t * i + e * this._y,
                    this._z = t * r + e * this._z,
                    this.normalize(),
                    this._onChangeCallback(),
                    this
                }
                const l = Math.sqrt(o)
                  , c = Math.atan2(l, a)
                  , h = Math.sin((1 - e) * c) / l
                  , u = Math.sin(e * c) / l;
                return this._w = s * h + this._w * u,
                this._x = n * h + this._x * u,
                this._y = i * h + this._y * u,
                this._z = r * h + this._z * u,
                this._onChangeCallback(),
                this
            }
            slerpQuaternions(t, e, n) {
                this.copy(t).slerp(e, n)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }
            fromArray(t, e=0) {
                return this._x = t[e],
                this._y = t[e + 1],
                this._z = t[e + 2],
                this._w = t[e + 3],
                this._onChangeCallback(),
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._w,
                t
            }
            fromBufferAttribute(t, e) {
                return this._x = t.getX(e),
                this._y = t.getY(e),
                this._z = t.getZ(e),
                this._w = t.getW(e),
                this
            }
            _onChange(t) {
                return this._onChangeCallback = t,
                this
            }
            _onChangeCallback() {}
        }
        qt.prototype.isQuaternion = !0;
        class Xt {
            constructor(t=0, e=0, n=0) {
                this.x = t,
                this.y = e,
                this.z = n
            }
            set(t, e, n) {
                return void 0 === n && (n = this.z),
                this.x = t,
                this.y = e,
                this.z = n,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this.z = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setZ(t) {
                return this.z = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this.z = t.z,
                this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this.z += t.z,
                this)
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this.z += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this.z = t.z + e.z,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this.z += t.z * e,
                this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this.z -= t.z,
                this)
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this.z -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this.z = t.z - e.z,
                this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
                this.multiplyVectors(t, e)) : (this.x *= t.x,
                this.y *= t.y,
                this.z *= t.z,
                this)
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this.z *= t,
                this
            }
            multiplyVectors(t, e) {
                return this.x = t.x * e.x,
                this.y = t.y * e.y,
                this.z = t.z * e.z,
                this
            }
            applyEuler(t) {
                return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
                this.applyQuaternion(Zt.setFromEuler(t))
            }
            applyAxisAngle(t, e) {
                return this.applyQuaternion(Zt.setFromAxisAngle(t, e))
            }
            applyMatrix3(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6] * i,
                this.y = r[1] * e + r[4] * n + r[7] * i,
                this.z = r[2] * e + r[5] * n + r[8] * i,
                this
            }
            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }
            applyMatrix4(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.elements
                  , s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s,
                this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s,
                this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s,
                this
            }
            applyQuaternion(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.x
                  , s = t.y
                  , a = t.z
                  , o = t.w
                  , l = o * e + s * i - a * n
                  , c = o * n + a * e - r * i
                  , h = o * i + r * n - s * e
                  , u = -r * e - s * n - a * i;
                return this.x = l * o + u * -r + c * -a - h * -s,
                this.y = c * o + u * -s + h * -r - l * -a,
                this.z = h * o + u * -a + l * -s - c * -r,
                this
            }
            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }
            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }
            transformDirection(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.elements;
                return this.x = r[0] * e + r[4] * n + r[8] * i,
                this.y = r[1] * e + r[5] * n + r[9] * i,
                this.z = r[2] * e + r[6] * n + r[10] * i,
                this.normalize()
            }
            divide(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this.z /= t.z,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this.z = Math.min(this.z, t.z),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this.z = Math.max(this.z, t.z),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this.z = Math.max(t.z, Math.min(e.z, this.z)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this.z = Math.max(t, Math.min(e, this.z)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this.z += (t.z - this.z) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this.z = t.z + (e.z - t.z) * n,
                this
            }
            cross(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
                this.crossVectors(t, e)) : this.crossVectors(this, t)
            }
            crossVectors(t, e) {
                const n = t.x
                  , i = t.y
                  , r = t.z
                  , s = e.x
                  , a = e.y
                  , o = e.z;
                return this.x = i * o - r * a,
                this.y = r * s - n * o,
                this.z = n * a - i * s,
                this
            }
            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e)
                    return this.set(0, 0, 0);
                const n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            }
            projectOnPlane(t) {
                return Yt.copy(this).projectOnVector(t),
                this.sub(Yt)
            }
            reflect(t) {
                return this.sub(Yt.copy(t).multiplyScalar(2 * this.dot(t)))
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e)
                    return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(Rt(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x
                  , n = this.y - t.y
                  , i = this.z - t.z;
                return e * e + n * n + i * i
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }
            setFromSpherical(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }
            setFromSphericalCoords(t, e, n) {
                const i = Math.sin(e) * t;
                return this.x = i * Math.sin(n),
                this.y = Math.cos(e) * t,
                this.z = i * Math.cos(n),
                this
            }
            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }
            setFromCylindricalCoords(t, e, n) {
                return this.x = t * Math.sin(e),
                this.y = n,
                this.z = t * Math.cos(e),
                this
            }
            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12],
                this.y = e[13],
                this.z = e[14],
                this
            }
            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length()
                  , n = this.setFromMatrixColumn(t, 1).length()
                  , i = this.setFromMatrixColumn(t, 2).length();
                return this.x = e,
                this.y = n,
                this.z = i,
                this
            }
            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }
            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this.z = t[e + 2],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t[e + 2] = this.z,
                t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
                this.x = t.getX(e),
                this.y = t.getY(e),
                this.z = t.getZ(e),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this
            }
        }
        Xt.prototype.isVector3 = !0;
        const Yt = new Xt
          , Zt = new qt;
        class Jt {
            constructor(t=new Xt(1 / 0,1 / 0,1 / 0), e=new Xt(-1 / 0,-1 / 0,-1 / 0)) {
                this.min = t,
                this.max = e
            }
            set(t, e) {
                return this.min.copy(t),
                this.max.copy(e),
                this
            }
            setFromArray(t) {
                let e = 1 / 0
                  , n = 1 / 0
                  , i = 1 / 0
                  , r = -1 / 0
                  , s = -1 / 0
                  , a = -1 / 0;
                for (let o = 0, l = t.length; o < l; o += 3) {
                    const l = t[o]
                      , c = t[o + 1]
                      , h = t[o + 2];
                    l < e && (e = l),
                    c < n && (n = c),
                    h < i && (i = h),
                    l > r && (r = l),
                    c > s && (s = c),
                    h > a && (a = h)
                }
                return this.min.set(e, n, i),
                this.max.set(r, s, a),
                this
            }
            setFromBufferAttribute(t) {
                let e = 1 / 0
                  , n = 1 / 0
                  , i = 1 / 0
                  , r = -1 / 0
                  , s = -1 / 0
                  , a = -1 / 0;
                for (let o = 0, l = t.count; o < l; o++) {
                    const l = t.getX(o)
                      , c = t.getY(o)
                      , h = t.getZ(o);
                    l < e && (e = l),
                    c < n && (n = c),
                    h < i && (i = h),
                    l > r && (r = l),
                    c > s && (s = c),
                    h > a && (a = h)
                }
                return this.min.set(e, n, i),
                this.max.set(r, s, a),
                this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++)
                    this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = Kt.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n),
                this.max.copy(t).add(n),
                this
            }
            setFromObject(t) {
                return this.makeEmpty(),
                this.expandByObject(t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min),
                this.max.copy(t.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                this.max.x = this.max.y = this.max.z = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(t) {
                return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"),
                t = new Xt),
                this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"),
                t = new Xt),
                this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t),
                this.max.max(t),
                this
            }
            expandByVector(t) {
                return this.min.sub(t),
                this.max.add(t),
                this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t),
                this.max.addScalar(t),
                this
            }
            expandByObject(t) {
                t.updateWorldMatrix(!1, !1);
                const e = t.geometry;
                void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(),
                Qt.copy(e.boundingBox),
                Qt.applyMatrix4(t.matrixWorld),
                this.union(Qt));
                const n = t.children;
                for (let t = 0, e = n.length; t < e; t++)
                    this.expandByObject(n[t]);
                return this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }
            getParameter(t, e) {
                return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"),
                e = new Xt),
                e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }
            intersectsSphere(t) {
                return this.clampPoint(t.center, Kt),
                Kt.distanceToSquared(t.center) <= t.radius * t.radius
            }
            intersectsPlane(t) {
                let e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
                n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
                n = t.normal.x * this.min.x),
                t.normal.y > 0 ? (e += t.normal.y * this.min.y,
                n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
                n += t.normal.y * this.min.y),
                t.normal.z > 0 ? (e += t.normal.z * this.min.z,
                n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
                n += t.normal.z * this.min.z),
                e <= -t.constant && n >= -t.constant
            }
            intersectsTriangle(t) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(ae),
                oe.subVectors(this.max, ae),
                te.subVectors(t.a, ae),
                ee.subVectors(t.b, ae),
                ne.subVectors(t.c, ae),
                ie.subVectors(ee, te),
                re.subVectors(ne, ee),
                se.subVectors(te, ne);
                let e = [0, -ie.z, ie.y, 0, -re.z, re.y, 0, -se.z, se.y, ie.z, 0, -ie.x, re.z, 0, -re.x, se.z, 0, -se.x, -ie.y, ie.x, 0, -re.y, re.x, 0, -se.y, se.x, 0];
                return !!he(e, te, ee, ne, oe) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                !!he(e, te, ee, ne, oe) && (le.crossVectors(ie, re),
                e = [le.x, le.y, le.z],
                he(e, te, ee, ne, oe)))
            }
            clampPoint(t, e) {
                return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"),
                e = new Xt),
                e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return Kt.copy(t).clamp(this.min, this.max).sub(t).length()
            }
            getBoundingSphere(t) {
                return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"),
                this.getCenter(t.center),
                t.radius = .5 * this.getSize(Kt).length(),
                t
            }
            intersect(t) {
                return this.min.max(t.min),
                this.max.min(t.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(t) {
                return this.min.min(t.min),
                this.max.max(t.max),
                this
            }
            applyMatrix4(t) {
                return this.isEmpty() || ($t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                $t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                $t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                $t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                $t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                $t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                $t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                $t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints($t)),
                this
            }
            translate(t) {
                return this.min.add(t),
                this.max.add(t),
                this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        Jt.prototype.isBox3 = !0;
        const $t = [new Xt, new Xt, new Xt, new Xt, new Xt, new Xt, new Xt, new Xt]
          , Kt = new Xt
          , Qt = new Jt
          , te = new Xt
          , ee = new Xt
          , ne = new Xt
          , ie = new Xt
          , re = new Xt
          , se = new Xt
          , ae = new Xt
          , oe = new Xt
          , le = new Xt
          , ce = new Xt;
        function he(t, e, n, i, r) {
            for (let s = 0, a = t.length - 3; s <= a; s += 3) {
                ce.fromArray(t, s);
                const a = r.x * Math.abs(ce.x) + r.y * Math.abs(ce.y) + r.z * Math.abs(ce.z)
                  , o = e.dot(ce)
                  , l = n.dot(ce)
                  , c = i.dot(ce);
                if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a)
                    return !1
            }
            return !0
        }
        const ue = new Jt
          , de = new Xt
          , pe = new Xt
          , fe = new Xt;
        class me {
            constructor(t=new Xt, e=-1) {
                this.center = t,
                this.radius = e
            }
            set(t, e) {
                return this.center.copy(t),
                this.radius = e,
                this
            }
            setFromPoints(t, e) {
                const n = this.center;
                void 0 !== e ? n.copy(e) : ue.setFromPoints(t).getCenter(n);
                let i = 0;
                for (let e = 0, r = t.length; e < r; e++)
                    i = Math.max(i, n.distanceToSquared(t[e]));
                return this.radius = Math.sqrt(i),
                this
            }
            copy(t) {
                return this.center.copy(t.center),
                this.radius = t.radius,
                this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0),
                this.radius = -1,
                this
            }
            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }
            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }
            intersectsBox(t) {
                return t.intersectsSphere(this)
            }
            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(t, e) {
                const n = this.center.distanceToSquared(t);
                return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"),
                e = new Xt),
                e.copy(t),
                n > this.radius * this.radius && (e.sub(this.center).normalize(),
                e.multiplyScalar(this.radius).add(this.center)),
                e
            }
            getBoundingBox(t) {
                return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
                t = new Jt),
                this.isEmpty() ? (t.makeEmpty(),
                t) : (t.set(this.center, this.center),
                t.expandByScalar(this.radius),
                t)
            }
            applyMatrix4(t) {
                return this.center.applyMatrix4(t),
                this.radius = this.radius * t.getMaxScaleOnAxis(),
                this
            }
            translate(t) {
                return this.center.add(t),
                this
            }
            expandByPoint(t) {
                fe.subVectors(t, this.center);
                const e = fe.lengthSq();
                if (e > this.radius * this.radius) {
                    const t = Math.sqrt(e)
                      , n = .5 * (t - this.radius);
                    this.center.add(fe.multiplyScalar(n / t)),
                    this.radius += n
                }
                return this
            }
            union(t) {
                return pe.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius),
                this.expandByPoint(de.copy(t.center).add(pe)),
                this.expandByPoint(de.copy(t.center).sub(pe)),
                this
            }
            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const ge = new Xt
          , ve = new Xt
          , ye = new Xt
          , xe = new Xt
          , _e = new Xt
          , we = new Xt
          , be = new Xt;
        class Me {
            constructor(t=new Xt, e=new Xt(0,0,-1)) {
                this.origin = t,
                this.direction = e
            }
            set(t, e) {
                return this.origin.copy(t),
                this.direction.copy(e),
                this
            }
            copy(t) {
                return this.origin.copy(t.origin),
                this.direction.copy(t.direction),
                this
            }
            at(t, e) {
                return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"),
                e = new Xt),
                e.copy(this.direction).multiplyScalar(t).add(this.origin)
            }
            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(),
                this
            }
            recast(t) {
                return this.origin.copy(this.at(t, ge)),
                this
            }
            closestPointToPoint(t, e) {
                void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
                e = new Xt),
                e.subVectors(t, this.origin);
                const n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
            }
            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }
            distanceSqToPoint(t) {
                const e = ge.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (ge.copy(this.direction).multiplyScalar(e).add(this.origin),
                ge.distanceToSquared(t))
            }
            distanceSqToSegment(t, e, n, i) {
                ve.copy(t).add(e).multiplyScalar(.5),
                ye.copy(e).sub(t).normalize(),
                xe.copy(this.origin).sub(ve);
                const r = .5 * t.distanceTo(e)
                  , s = -this.direction.dot(ye)
                  , a = xe.dot(this.direction)
                  , o = -xe.dot(ye)
                  , l = xe.lengthSq()
                  , c = Math.abs(1 - s * s);
                let h, u, d, p;
                if (c > 0)
                    if (h = s * o - a,
                    u = s * a - o,
                    p = r * c,
                    h >= 0)
                        if (u >= -p)
                            if (u <= p) {
                                const t = 1 / c;
                                h *= t,
                                u *= t,
                                d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l
                            } else
                                u = r,
                                h = Math.max(0, -(s * u + a)),
                                d = -h * h + u * (u + 2 * o) + l;
                        else
                            u = -r,
                            h = Math.max(0, -(s * u + a)),
                            d = -h * h + u * (u + 2 * o) + l;
                    else
                        u <= -p ? (h = Math.max(0, -(-s * r + a)),
                        u = h > 0 ? -r : Math.min(Math.max(-r, -o), r),
                        d = -h * h + u * (u + 2 * o) + l) : u <= p ? (h = 0,
                        u = Math.min(Math.max(-r, -o), r),
                        d = u * (u + 2 * o) + l) : (h = Math.max(0, -(s * r + a)),
                        u = h > 0 ? r : Math.min(Math.max(-r, -o), r),
                        d = -h * h + u * (u + 2 * o) + l);
                else
                    u = s > 0 ? -r : r,
                    h = Math.max(0, -(s * u + a)),
                    d = -h * h + u * (u + 2 * o) + l;
                return n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
                i && i.copy(ye).multiplyScalar(u).add(ve),
                d
            }
            intersectSphere(t, e) {
                ge.subVectors(t.center, this.origin);
                const n = ge.dot(this.direction)
                  , i = ge.dot(ge) - n * n
                  , r = t.radius * t.radius;
                if (i > r)
                    return null;
                const s = Math.sqrt(r - i)
                  , a = n - s
                  , o = n + s;
                return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
            }
            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }
            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e)
                    return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }
            intersectPlane(t, e) {
                const n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }
            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                if (0 === e)
                    return !0;
                return t.normal.dot(this.direction) * e < 0
            }
            intersectBox(t, e) {
                let n, i, r, s, a, o;
                const l = 1 / this.direction.x
                  , c = 1 / this.direction.y
                  , h = 1 / this.direction.z
                  , u = this.origin;
                return l >= 0 ? (n = (t.min.x - u.x) * l,
                i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l,
                i = (t.min.x - u.x) * l),
                c >= 0 ? (r = (t.min.y - u.y) * c,
                s = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c,
                s = (t.min.y - u.y) * c),
                n > s || r > i ? null : ((r > n || n != n) && (n = r),
                (s < i || i != i) && (i = s),
                h >= 0 ? (a = (t.min.z - u.z) * h,
                o = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h,
                o = (t.min.z - u.z) * h),
                n > o || a > i ? null : ((a > n || n != n) && (n = a),
                (o < i || i != i) && (i = o),
                i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            }
            intersectsBox(t) {
                return null !== this.intersectBox(t, ge)
            }
            intersectTriangle(t, e, n, i, r) {
                _e.subVectors(e, t),
                we.subVectors(n, t),
                be.crossVectors(_e, we);
                let s, a = this.direction.dot(be);
                if (a > 0) {
                    if (i)
                        return null;
                    s = 1
                } else {
                    if (!(a < 0))
                        return null;
                    s = -1,
                    a = -a
                }
                xe.subVectors(this.origin, t);
                const o = s * this.direction.dot(we.crossVectors(xe, we));
                if (o < 0)
                    return null;
                const l = s * this.direction.dot(_e.cross(xe));
                if (l < 0)
                    return null;
                if (o + l > a)
                    return null;
                const c = -s * xe.dot(be);
                return c < 0 ? null : this.at(c / a, r)
            }
            applyMatrix4(t) {
                return this.origin.applyMatrix4(t),
                this.direction.transformDirection(t),
                this
            }
            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Se {
            constructor() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m) {
                const g = this.elements;
                return g[0] = t,
                g[4] = e,
                g[8] = n,
                g[12] = i,
                g[1] = r,
                g[5] = s,
                g[9] = a,
                g[13] = o,
                g[2] = l,
                g[6] = c,
                g[10] = h,
                g[14] = u,
                g[3] = d,
                g[7] = p,
                g[11] = f,
                g[15] = m,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            clone() {
                return (new Se).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements
                  , n = t.elements;
                return e[0] = n[0],
                e[1] = n[1],
                e[2] = n[2],
                e[3] = n[3],
                e[4] = n[4],
                e[5] = n[5],
                e[6] = n[6],
                e[7] = n[7],
                e[8] = n[8],
                e[9] = n[9],
                e[10] = n[10],
                e[11] = n[11],
                e[12] = n[12],
                e[13] = n[13],
                e[14] = n[14],
                e[15] = n[15],
                this
            }
            copyPosition(t) {
                const e = this.elements
                  , n = t.elements;
                return e[12] = n[12],
                e[13] = n[13],
                e[14] = n[14],
                this
            }
            setFromMatrix3(t) {
                const e = t.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1),
                this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrixColumn(this, 0),
                e.setFromMatrixColumn(this, 1),
                n.setFromMatrixColumn(this, 2),
                this
            }
            makeBasis(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1),
                this
            }
            extractRotation(t) {
                const e = this.elements
                  , n = t.elements
                  , i = 1 / Te.setFromMatrixColumn(t, 0).length()
                  , r = 1 / Te.setFromMatrixColumn(t, 1).length()
                  , s = 1 / Te.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * i,
                e[1] = n[1] * i,
                e[2] = n[2] * i,
                e[3] = 0,
                e[4] = n[4] * r,
                e[5] = n[5] * r,
                e[6] = n[6] * r,
                e[7] = 0,
                e[8] = n[8] * s,
                e[9] = n[9] * s,
                e[10] = n[10] * s,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            }
            makeRotationFromEuler(t) {
                t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                const e = this.elements
                  , n = t.x
                  , i = t.y
                  , r = t.z
                  , s = Math.cos(n)
                  , a = Math.sin(n)
                  , o = Math.cos(i)
                  , l = Math.sin(i)
                  , c = Math.cos(r)
                  , h = Math.sin(r);
                if ("XYZ" === t.order) {
                    const t = s * c
                      , n = s * h
                      , i = a * c
                      , r = a * h;
                    e[0] = o * c,
                    e[4] = -o * h,
                    e[8] = l,
                    e[1] = n + i * l,
                    e[5] = t - r * l,
                    e[9] = -a * o,
                    e[2] = r - t * l,
                    e[6] = i + n * l,
                    e[10] = s * o
                } else if ("YXZ" === t.order) {
                    const t = o * c
                      , n = o * h
                      , i = l * c
                      , r = l * h;
                    e[0] = t + r * a,
                    e[4] = i * a - n,
                    e[8] = s * l,
                    e[1] = s * h,
                    e[5] = s * c,
                    e[9] = -a,
                    e[2] = n * a - i,
                    e[6] = r + t * a,
                    e[10] = s * o
                } else if ("ZXY" === t.order) {
                    const t = o * c
                      , n = o * h
                      , i = l * c
                      , r = l * h;
                    e[0] = t - r * a,
                    e[4] = -s * h,
                    e[8] = i + n * a,
                    e[1] = n + i * a,
                    e[5] = s * c,
                    e[9] = r - t * a,
                    e[2] = -s * l,
                    e[6] = a,
                    e[10] = s * o
                } else if ("ZYX" === t.order) {
                    const t = s * c
                      , n = s * h
                      , i = a * c
                      , r = a * h;
                    e[0] = o * c,
                    e[4] = i * l - n,
                    e[8] = t * l + r,
                    e[1] = o * h,
                    e[5] = r * l + t,
                    e[9] = n * l - i,
                    e[2] = -l,
                    e[6] = a * o,
                    e[10] = s * o
                } else if ("YZX" === t.order) {
                    const t = s * o
                      , n = s * l
                      , i = a * o
                      , r = a * l;
                    e[0] = o * c,
                    e[4] = r - t * h,
                    e[8] = i * h + n,
                    e[1] = h,
                    e[5] = s * c,
                    e[9] = -a * c,
                    e[2] = -l * c,
                    e[6] = n * h + i,
                    e[10] = t - r * h
                } else if ("XZY" === t.order) {
                    const t = s * o
                      , n = s * l
                      , i = a * o
                      , r = a * l;
                    e[0] = o * c,
                    e[4] = -h,
                    e[8] = l * c,
                    e[1] = t * h + r,
                    e[5] = s * c,
                    e[9] = n * h - i,
                    e[2] = i * h - n,
                    e[6] = a * c,
                    e[10] = r * h + t
                }
                return e[3] = 0,
                e[7] = 0,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            }
            makeRotationFromQuaternion(t) {
                return this.compose(Le, t, Ae)
            }
            lookAt(t, e, n) {
                const i = this.elements;
                return Re.subVectors(t, e),
                0 === Re.lengthSq() && (Re.z = 1),
                Re.normalize(),
                Ce.crossVectors(n, Re),
                0 === Ce.lengthSq() && (1 === Math.abs(n.z) ? Re.x += 1e-4 : Re.z += 1e-4,
                Re.normalize(),
                Ce.crossVectors(n, Re)),
                Ce.normalize(),
                Pe.crossVectors(Re, Ce),
                i[0] = Ce.x,
                i[4] = Pe.x,
                i[8] = Re.x,
                i[1] = Ce.y,
                i[5] = Pe.y,
                i[9] = Re.y,
                i[2] = Ce.z,
                i[6] = Pe.z,
                i[10] = Re.z,
                this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
                this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements
                  , i = e.elements
                  , r = this.elements
                  , s = n[0]
                  , a = n[4]
                  , o = n[8]
                  , l = n[12]
                  , c = n[1]
                  , h = n[5]
                  , u = n[9]
                  , d = n[13]
                  , p = n[2]
                  , f = n[6]
                  , m = n[10]
                  , g = n[14]
                  , v = n[3]
                  , y = n[7]
                  , x = n[11]
                  , _ = n[15]
                  , w = i[0]
                  , b = i[4]
                  , M = i[8]
                  , S = i[12]
                  , T = i[1]
                  , E = i[5]
                  , L = i[9]
                  , A = i[13]
                  , C = i[2]
                  , P = i[6]
                  , R = i[10]
                  , I = i[14]
                  , D = i[3]
                  , N = i[7]
                  , O = i[11]
                  , z = i[15];
                return r[0] = s * w + a * T + o * C + l * D,
                r[4] = s * b + a * E + o * P + l * N,
                r[8] = s * M + a * L + o * R + l * O,
                r[12] = s * S + a * A + o * I + l * z,
                r[1] = c * w + h * T + u * C + d * D,
                r[5] = c * b + h * E + u * P + d * N,
                r[9] = c * M + h * L + u * R + d * O,
                r[13] = c * S + h * A + u * I + d * z,
                r[2] = p * w + f * T + m * C + g * D,
                r[6] = p * b + f * E + m * P + g * N,
                r[10] = p * M + f * L + m * R + g * O,
                r[14] = p * S + f * A + m * I + g * z,
                r[3] = v * w + y * T + x * C + _ * D,
                r[7] = v * b + y * E + x * P + _ * N,
                r[11] = v * M + y * L + x * R + _ * O,
                r[15] = v * S + y * A + x * I + _ * z,
                this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t,
                e[4] *= t,
                e[8] *= t,
                e[12] *= t,
                e[1] *= t,
                e[5] *= t,
                e[9] *= t,
                e[13] *= t,
                e[2] *= t,
                e[6] *= t,
                e[10] *= t,
                e[14] *= t,
                e[3] *= t,
                e[7] *= t,
                e[11] *= t,
                e[15] *= t,
                this
            }
            determinant() {
                const t = this.elements
                  , e = t[0]
                  , n = t[4]
                  , i = t[8]
                  , r = t[12]
                  , s = t[1]
                  , a = t[5]
                  , o = t[9]
                  , l = t[13]
                  , c = t[2]
                  , h = t[6]
                  , u = t[10]
                  , d = t[14];
                return t[3] * (+r * o * h - i * l * h - r * a * u + n * l * u + i * a * d - n * o * d) + t[7] * (+e * o * d - e * l * u + r * s * u - i * s * d + i * l * c - r * o * c) + t[11] * (+e * l * h - e * a * d - r * s * h + n * s * d + r * a * c - n * l * c) + t[15] * (-i * a * c - e * o * h + e * a * u + i * s * h - n * s * u + n * o * c)
            }
            transpose() {
                const t = this.elements;
                let e;
                return e = t[1],
                t[1] = t[4],
                t[4] = e,
                e = t[2],
                t[2] = t[8],
                t[8] = e,
                e = t[6],
                t[6] = t[9],
                t[9] = e,
                e = t[3],
                t[3] = t[12],
                t[12] = e,
                e = t[7],
                t[7] = t[13],
                t[13] = e,
                e = t[11],
                t[11] = t[14],
                t[14] = e,
                this
            }
            setPosition(t, e, n) {
                const i = this.elements;
                return t.isVector3 ? (i[12] = t.x,
                i[13] = t.y,
                i[14] = t.z) : (i[12] = t,
                i[13] = e,
                i[14] = n),
                this
            }
            invert() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , i = t[2]
                  , r = t[3]
                  , s = t[4]
                  , a = t[5]
                  , o = t[6]
                  , l = t[7]
                  , c = t[8]
                  , h = t[9]
                  , u = t[10]
                  , d = t[11]
                  , p = t[12]
                  , f = t[13]
                  , m = t[14]
                  , g = t[15]
                  , v = h * m * l - f * u * l + f * o * d - a * m * d - h * o * g + a * u * g
                  , y = p * u * l - c * m * l - p * o * d + s * m * d + c * o * g - s * u * g
                  , x = c * f * l - p * h * l + p * a * d - s * f * d - c * a * g + s * h * g
                  , _ = p * h * o - c * f * o - p * a * u + s * f * u + c * a * m - s * h * m
                  , w = e * v + n * y + i * x + r * _;
                if (0 === w)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const b = 1 / w;
                return t[0] = v * b,
                t[1] = (f * u * r - h * m * r - f * i * d + n * m * d + h * i * g - n * u * g) * b,
                t[2] = (a * m * r - f * o * r + f * i * l - n * m * l - a * i * g + n * o * g) * b,
                t[3] = (h * o * r - a * u * r - h * i * l + n * u * l + a * i * d - n * o * d) * b,
                t[4] = y * b,
                t[5] = (c * m * r - p * u * r + p * i * d - e * m * d - c * i * g + e * u * g) * b,
                t[6] = (p * o * r - s * m * r - p * i * l + e * m * l + s * i * g - e * o * g) * b,
                t[7] = (s * u * r - c * o * r + c * i * l - e * u * l - s * i * d + e * o * d) * b,
                t[8] = x * b,
                t[9] = (p * h * r - c * f * r - p * n * d + e * f * d + c * n * g - e * h * g) * b,
                t[10] = (s * f * r - p * a * r + p * n * l - e * f * l - s * n * g + e * a * g) * b,
                t[11] = (c * a * r - s * h * r - c * n * l + e * h * l + s * n * d - e * a * d) * b,
                t[12] = _ * b,
                t[13] = (c * f * i - p * h * i + p * n * u - e * f * u - c * n * m + e * h * m) * b,
                t[14] = (p * a * i - s * f * i - p * n * o + e * f * o + s * n * m - e * a * m) * b,
                t[15] = (s * h * i - c * a * i + c * n * o - e * h * o - s * n * u + e * a * u) * b,
                this
            }
            scale(t) {
                const e = this.elements
                  , n = t.x
                  , i = t.y
                  , r = t.z;
                return e[0] *= n,
                e[4] *= i,
                e[8] *= r,
                e[1] *= n,
                e[5] *= i,
                e[9] *= r,
                e[2] *= n,
                e[6] *= i,
                e[10] *= r,
                e[3] *= n,
                e[7] *= i,
                e[11] *= r,
                this
            }
            getMaxScaleOnAxis() {
                const t = this.elements
                  , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
                  , n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
                  , i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, i))
            }
            makeTranslation(t, e, n) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
                this
            }
            makeRotationX(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
                this
            }
            makeRotationY(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
                this
            }
            makeRotationZ(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            makeRotationAxis(t, e) {
                const n = Math.cos(e)
                  , i = Math.sin(e)
                  , r = 1 - n
                  , s = t.x
                  , a = t.y
                  , o = t.z
                  , l = r * s
                  , c = r * a;
                return this.set(l * s + n, l * a - i * o, l * o + i * a, 0, l * a + i * o, c * a + n, c * o - i * s, 0, l * o - i * a, c * o + i * s, r * o * o + n, 0, 0, 0, 0, 1),
                this
            }
            makeScale(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                this
            }
            makeShear(t, e, n) {
                return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1),
                this
            }
            compose(t, e, n) {
                const i = this.elements
                  , r = e._x
                  , s = e._y
                  , a = e._z
                  , o = e._w
                  , l = r + r
                  , c = s + s
                  , h = a + a
                  , u = r * l
                  , d = r * c
                  , p = r * h
                  , f = s * c
                  , m = s * h
                  , g = a * h
                  , v = o * l
                  , y = o * c
                  , x = o * h
                  , _ = n.x
                  , w = n.y
                  , b = n.z;
                return i[0] = (1 - (f + g)) * _,
                i[1] = (d + x) * _,
                i[2] = (p - y) * _,
                i[3] = 0,
                i[4] = (d - x) * w,
                i[5] = (1 - (u + g)) * w,
                i[6] = (m + v) * w,
                i[7] = 0,
                i[8] = (p + y) * b,
                i[9] = (m - v) * b,
                i[10] = (1 - (u + f)) * b,
                i[11] = 0,
                i[12] = t.x,
                i[13] = t.y,
                i[14] = t.z,
                i[15] = 1,
                this
            }
            decompose(t, e, n) {
                const i = this.elements;
                let r = Te.set(i[0], i[1], i[2]).length();
                const s = Te.set(i[4], i[5], i[6]).length()
                  , a = Te.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r),
                t.x = i[12],
                t.y = i[13],
                t.z = i[14],
                Ee.copy(this);
                const o = 1 / r
                  , l = 1 / s
                  , c = 1 / a;
                return Ee.elements[0] *= o,
                Ee.elements[1] *= o,
                Ee.elements[2] *= o,
                Ee.elements[4] *= l,
                Ee.elements[5] *= l,
                Ee.elements[6] *= l,
                Ee.elements[8] *= c,
                Ee.elements[9] *= c,
                Ee.elements[10] *= c,
                e.setFromRotationMatrix(Ee),
                n.x = r,
                n.y = s,
                n.z = a,
                this
            }
            makePerspective(t, e, n, i, r, s) {
                void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                const a = this.elements
                  , o = 2 * r / (e - t)
                  , l = 2 * r / (n - i)
                  , c = (e + t) / (e - t)
                  , h = (n + i) / (n - i)
                  , u = -(s + r) / (s - r)
                  , d = -2 * s * r / (s - r);
                return a[0] = o,
                a[4] = 0,
                a[8] = c,
                a[12] = 0,
                a[1] = 0,
                a[5] = l,
                a[9] = h,
                a[13] = 0,
                a[2] = 0,
                a[6] = 0,
                a[10] = u,
                a[14] = d,
                a[3] = 0,
                a[7] = 0,
                a[11] = -1,
                a[15] = 0,
                this
            }
            makeOrthographic(t, e, n, i, r, s) {
                const a = this.elements
                  , o = 1 / (e - t)
                  , l = 1 / (n - i)
                  , c = 1 / (s - r)
                  , h = (e + t) * o
                  , u = (n + i) * l
                  , d = (s + r) * c;
                return a[0] = 2 * o,
                a[4] = 0,
                a[8] = 0,
                a[12] = -h,
                a[1] = 0,
                a[5] = 2 * l,
                a[9] = 0,
                a[13] = -u,
                a[2] = 0,
                a[6] = 0,
                a[10] = -2 * c,
                a[14] = -d,
                a[3] = 0,
                a[7] = 0,
                a[11] = 0,
                a[15] = 1,
                this
            }
            equals(t) {
                const e = this.elements
                  , n = t.elements;
                for (let t = 0; t < 16; t++)
                    if (e[t] !== n[t])
                        return !1;
                return !0
            }
            fromArray(t, e=0) {
                for (let n = 0; n < 16; n++)
                    this.elements[n] = t[n + e];
                return this
            }
            toArray(t=[], e=0) {
                const n = this.elements;
                return t[e] = n[0],
                t[e + 1] = n[1],
                t[e + 2] = n[2],
                t[e + 3] = n[3],
                t[e + 4] = n[4],
                t[e + 5] = n[5],
                t[e + 6] = n[6],
                t[e + 7] = n[7],
                t[e + 8] = n[8],
                t[e + 9] = n[9],
                t[e + 10] = n[10],
                t[e + 11] = n[11],
                t[e + 12] = n[12],
                t[e + 13] = n[13],
                t[e + 14] = n[14],
                t[e + 15] = n[15],
                t
            }
        }
        Se.prototype.isMatrix4 = !0;
        const Te = new Xt
          , Ee = new Se
          , Le = new Xt(0,0,0)
          , Ae = new Xt(1,1,1)
          , Ce = new Xt
          , Pe = new Xt
          , Re = new Xt
          , Ie = new Se
          , De = new qt;
        class Ne {
            constructor(t=0, e=0, n=0, i=Ne.DefaultOrder) {
                this._x = t,
                this._y = e,
                this._z = n,
                this._order = i
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t,
                this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(t) {
                this._order = t,
                this._onChangeCallback()
            }
            set(t, e, n, i) {
                return this._x = t,
                this._y = e,
                this._z = n,
                this._order = i || this._order,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            }
            copy(t) {
                return this._x = t._x,
                this._y = t._y,
                this._z = t._z,
                this._order = t._order,
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(t, e, n) {
                const i = t.elements
                  , r = i[0]
                  , s = i[4]
                  , a = i[8]
                  , o = i[1]
                  , l = i[5]
                  , c = i[9]
                  , h = i[2]
                  , u = i[6]
                  , d = i[10];
                switch (e = e || this._order) {
                case "XYZ":
                    this._y = Math.asin(Rt(a, -1, 1)),
                    Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d),
                    this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l),
                    this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-Rt(c, -1, 1)),
                    Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d),
                    this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r),
                    this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(Rt(u, -1, 1)),
                    Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d),
                    this._z = Math.atan2(-s, l)) : (this._y = 0,
                    this._z = Math.atan2(o, r));
                    break;
                case "ZYX":
                    this._y = Math.asin(-Rt(h, -1, 1)),
                    Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d),
                    this._z = Math.atan2(o, r)) : (this._x = 0,
                    this._z = Math.atan2(-s, l));
                    break;
                case "YZX":
                    this._z = Math.asin(Rt(o, -1, 1)),
                    Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l),
                    this._y = Math.atan2(-h, r)) : (this._x = 0,
                    this._y = Math.atan2(a, d));
                    break;
                case "XZY":
                    this._z = Math.asin(-Rt(s, -1, 1)),
                    Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l),
                    this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d),
                    this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e,
                !1 !== n && this._onChangeCallback(),
                this
            }
            setFromQuaternion(t, e, n) {
                return Ie.makeRotationFromQuaternion(t),
                this.setFromRotationMatrix(Ie, e, n)
            }
            setFromVector3(t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            }
            reorder(t) {
                return De.setFromEuler(this),
                this.setFromQuaternion(De, t)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }
            fromArray(t) {
                return this._x = t[0],
                this._y = t[1],
                this._z = t[2],
                void 0 !== t[3] && (this._order = t[3]),
                this._onChangeCallback(),
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._order,
                t
            }
            toVector3(t) {
                return t ? t.set(this._x, this._y, this._z) : new Xt(this._x,this._y,this._z)
            }
            _onChange(t) {
                return this._onChangeCallback = t,
                this
            }
            _onChangeCallback() {}
        }
        Ne.prototype.isEuler = !0,
        Ne.DefaultOrder = "XYZ",
        Ne.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
        class Oe {
            constructor() {
                this.mask = 1
            }
            set(t) {
                this.mask = 1 << t | 0
            }
            enable(t) {
                this.mask |= 1 << t | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(t) {
                this.mask ^= 1 << t | 0
            }
            disable(t) {
                this.mask &= ~(1 << t | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(t) {
                return 0 != (this.mask & t.mask)
            }
        }
        let ze = 0;
        const Be = new Xt
          , ke = new qt
          , Fe = new Se
          , He = new Xt
          , Ue = new Xt
          , Ge = new Xt
          , Ve = new qt
          , We = new Xt(1,0,0)
          , je = new Xt(0,1,0)
          , qe = new Xt(0,0,1)
          , Xe = {
            type: "added"
        }
          , Ye = {
            type: "removed"
        };
        class Ze extends Et {
            constructor() {
                super(),
                Object.defineProperty(this, "id", {
                    value: ze++
                }),
                this.uuid = Pt(),
                this.name = "",
                this.type = "Object3D",
                this.parent = null,
                this.children = [],
                this.up = Ze.DefaultUp.clone();
                const t = new Xt
                  , e = new Ne
                  , n = new qt
                  , i = new Xt(1,1,1);
                e._onChange((function() {
                    n.setFromEuler(e, !1)
                }
                )),
                n._onChange((function() {
                    e.setFromQuaternion(n, void 0, !1)
                }
                )),
                Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Se
                    },
                    normalMatrix: {
                        value: new kt
                    }
                }),
                this.matrix = new Se,
                this.matrixWorld = new Se,
                this.matrixAutoUpdate = Ze.DefaultMatrixAutoUpdate,
                this.matrixWorldNeedsUpdate = !1,
                this.layers = new Oe,
                this.visible = !0,
                this.castShadow = !1,
                this.receiveShadow = !1,
                this.frustumCulled = !0,
                this.renderOrder = 0,
                this.animations = [],
                this.userData = {}
            }
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(t) {
                this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(t),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(t) {
                return this.quaternion.premultiply(t),
                this
            }
            setRotationFromAxisAngle(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            }
            setRotationFromEuler(t) {
                this.quaternion.setFromEuler(t, !0)
            }
            setRotationFromMatrix(t) {
                this.quaternion.setFromRotationMatrix(t)
            }
            setRotationFromQuaternion(t) {
                this.quaternion.copy(t)
            }
            rotateOnAxis(t, e) {
                return ke.setFromAxisAngle(t, e),
                this.quaternion.multiply(ke),
                this
            }
            rotateOnWorldAxis(t, e) {
                return ke.setFromAxisAngle(t, e),
                this.quaternion.premultiply(ke),
                this
            }
            rotateX(t) {
                return this.rotateOnAxis(We, t)
            }
            rotateY(t) {
                return this.rotateOnAxis(je, t)
            }
            rotateZ(t) {
                return this.rotateOnAxis(qe, t)
            }
            translateOnAxis(t, e) {
                return Be.copy(t).applyQuaternion(this.quaternion),
                this.position.add(Be.multiplyScalar(e)),
                this
            }
            translateX(t) {
                return this.translateOnAxis(We, t)
            }
            translateY(t) {
                return this.translateOnAxis(je, t)
            }
            translateZ(t) {
                return this.translateOnAxis(qe, t)
            }
            localToWorld(t) {
                return t.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(t) {
                return t.applyMatrix4(Fe.copy(this.matrixWorld).invert())
            }
            lookAt(t, e, n) {
                t.isVector3 ? He.copy(t) : He.set(t, e, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1),
                Ue.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? Fe.lookAt(Ue, He, this.up) : Fe.lookAt(He, Ue, this.up),
                this.quaternion.setFromRotationMatrix(Fe),
                i && (Fe.extractRotation(i.matrixWorld),
                ke.setFromRotationMatrix(Fe),
                this.quaternion.premultiply(ke.invert()))
            }
            add(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++)
                        this.add(arguments[t]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
                this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
                t.parent = this,
                this.children.push(t),
                t.dispatchEvent(Xe)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
                this)
            }
            remove(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++)
                        this.remove(arguments[t]);
                    return this
                }
                const e = this.children.indexOf(t);
                return -1 !== e && (t.parent = null,
                this.children.splice(e, 1),
                t.dispatchEvent(Ye)),
                this
            }
            clear() {
                for (let t = 0; t < this.children.length; t++) {
                    const e = this.children[t];
                    e.parent = null,
                    e.dispatchEvent(Ye)
                }
                return this.children.length = 0,
                this
            }
            attach(t) {
                return this.updateWorldMatrix(!0, !1),
                Fe.copy(this.matrixWorld).invert(),
                null !== t.parent && (t.parent.updateWorldMatrix(!0, !1),
                Fe.multiply(t.parent.matrixWorld)),
                t.applyMatrix4(Fe),
                this.add(t),
                t.updateWorldMatrix(!1, !0),
                this
            }
            getObjectById(t) {
                return this.getObjectByProperty("id", t)
            }
            getObjectByName(t) {
                return this.getObjectByProperty("name", t)
            }
            getObjectByProperty(t, e) {
                if (this[t] === e)
                    return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n].getObjectByProperty(t, e);
                    if (void 0 !== i)
                        return i
                }
            }
            getWorldPosition(t) {
                return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"),
                t = new Xt),
                this.updateWorldMatrix(!0, !1),
                t.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(t) {
                return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),
                t = new qt),
                this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(Ue, t, Ge),
                t
            }
            getWorldScale(t) {
                return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"),
                t = new Xt),
                this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(Ue, Ve, t),
                t
            }
            getWorldDirection(t) {
                void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"),
                t = new Xt),
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            }
            raycast() {}
            traverse(t) {
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++)
                    e[n].traverse(t)
            }
            traverseVisible(t) {
                if (!1 === this.visible)
                    return;
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++)
                    e[n].traverseVisible(t)
            }
            traverseAncestors(t) {
                const e = this.parent;
                null !== e && (t(e),
                e.traverseAncestors(t))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(t) {
                this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                this.matrixWorldNeedsUpdate = !1,
                t = !0);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++)
                    e[n].updateMatrixWorld(t)
            }
            updateWorldMatrix(t, e) {
                const n = this.parent;
                if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                !0 === e) {
                    const t = this.children;
                    for (let e = 0, n = t.length; e < n; e++)
                        t[e].updateWorldMatrix(!1, !0)
                }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t
                  , n = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {}
                },
                n.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const i = {};
                function r(e, n) {
                    return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
                    n.uuid
                }
                if (i.uuid = this.uuid,
                i.type = this.type,
                "" !== this.name && (i.name = this.name),
                !0 === this.castShadow && (i.castShadow = !0),
                !0 === this.receiveShadow && (i.receiveShadow = !0),
                !1 === this.visible && (i.visible = !1),
                !1 === this.frustumCulled && (i.frustumCulled = !1),
                0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
                "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
                i.layers = this.layers.mask,
                i.matrix = this.matrix.toArray(),
                !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
                this.isInstancedMesh && (i.type = "InstancedMesh",
                i.count = this.count,
                i.instanceMatrix = this.instanceMatrix.toJSON(),
                null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
                this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(t.geometries, this.geometry);
                    const e = this.geometry.parameters;
                    if (void 0 !== e && void 0 !== e.shapes) {
                        const n = e.shapes;
                        if (Array.isArray(n))
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                r(t.shapes, i)
                            }
                        else
                            r(t.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
                i.bindMatrix = this.bindMatrix.toArray(),
                void 0 !== this.skeleton && (r(t.skeletons, this.skeleton),
                i.skeleton = this.skeleton.uuid)),
                void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const e = [];
                        for (let n = 0, i = this.material.length; n < i; n++)
                            e.push(r(t.materials, this.material[n]));
                        i.material = e
                    } else
                        i.material = r(t.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let e = 0; e < this.children.length; e++)
                        i.children.push(this.children[e].toJSON(t).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let e = 0; e < this.animations.length; e++) {
                        const n = this.animations[e];
                        i.animations.push(r(t.animations, n))
                    }
                }
                if (e) {
                    const e = s(t.geometries)
                      , i = s(t.materials)
                      , r = s(t.textures)
                      , a = s(t.images)
                      , o = s(t.shapes)
                      , l = s(t.skeletons)
                      , c = s(t.animations);
                    e.length > 0 && (n.geometries = e),
                    i.length > 0 && (n.materials = i),
                    r.length > 0 && (n.textures = r),
                    a.length > 0 && (n.images = a),
                    o.length > 0 && (n.shapes = o),
                    l.length > 0 && (n.skeletons = l),
                    c.length > 0 && (n.animations = c)
                }
                return n.object = i,
                n;
                function s(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata,
                        e.push(i)
                    }
                    return e
                }
            }
            clone(t) {
                return (new this.constructor).copy(this, t)
            }
            copy(t, e=!0) {
                if (this.name = t.name,
                this.up.copy(t.up),
                this.position.copy(t.position),
                this.rotation.order = t.rotation.order,
                this.quaternion.copy(t.quaternion),
                this.scale.copy(t.scale),
                this.matrix.copy(t.matrix),
                this.matrixWorld.copy(t.matrixWorld),
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
                this.layers.mask = t.layers.mask,
                this.visible = t.visible,
                this.castShadow = t.castShadow,
                this.receiveShadow = t.receiveShadow,
                this.frustumCulled = t.frustumCulled,
                this.renderOrder = t.renderOrder,
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                !0 === e)
                    for (let e = 0; e < t.children.length; e++) {
                        const n = t.children[e];
                        this.add(n.clone())
                    }
                return this
            }
        }
        Ze.DefaultUp = new Xt(0,1,0),
        Ze.DefaultMatrixAutoUpdate = !0,
        Ze.prototype.isObject3D = !0;
        const Je = new Xt
          , $e = new Xt
          , Ke = new kt;
        class Qe {
            constructor(t=new Xt(1,0,0), e=0) {
                this.normal = t,
                this.constant = e
            }
            set(t, e) {
                return this.normal.copy(t),
                this.constant = e,
                this
            }
            setComponents(t, e, n, i) {
                return this.normal.set(t, e, n),
                this.constant = i,
                this
            }
            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t),
                this.constant = -e.dot(this.normal),
                this
            }
            setFromCoplanarPoints(t, e, n) {
                const i = Je.subVectors(n, e).cross($e.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, t),
                this
            }
            copy(t) {
                return this.normal.copy(t.normal),
                this.constant = t.constant,
                this
            }
            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t),
                this.constant *= t,
                this
            }
            negate() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            }
            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }
            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }
            projectPoint(t, e) {
                return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"),
                e = new Xt),
                e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            }
            intersectLine(t, e) {
                void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"),
                e = new Xt);
                const n = t.delta(Je)
                  , i = this.normal.dot(n);
                if (0 === i)
                    return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                const r = -(t.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
            }
            intersectsLine(t) {
                const e = this.distanceToPoint(t.start)
                  , n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            }
            intersectsBox(t) {
                return t.intersectsPlane(this)
            }
            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }
            coplanarPoint(t) {
                return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
                t = new Xt),
                t.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(t, e) {
                const n = e || Ke.getNormalMatrix(t)
                  , i = this.coplanarPoint(Je).applyMatrix4(t)
                  , r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r),
                this
            }
            translate(t) {
                return this.constant -= t.dot(this.normal),
                this
            }
            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        Qe.prototype.isPlane = !0;
        const tn = new Xt
          , en = new Xt
          , nn = new Xt
          , rn = new Xt
          , sn = new Xt
          , an = new Xt
          , on = new Xt
          , ln = new Xt
          , cn = new Xt
          , hn = new Xt;
        class un {
            constructor(t=new Xt, e=new Xt, n=new Xt) {
                this.a = t,
                this.b = e,
                this.c = n
            }
            static getNormal(t, e, n, i) {
                void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"),
                i = new Xt),
                i.subVectors(n, e),
                tn.subVectors(t, e),
                i.cross(tn);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(t, e, n, i, r) {
                tn.subVectors(i, e),
                en.subVectors(n, e),
                nn.subVectors(t, e);
                const s = tn.dot(tn)
                  , a = tn.dot(en)
                  , o = tn.dot(nn)
                  , l = en.dot(en)
                  , c = en.dot(nn)
                  , h = s * l - a * a;
                if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
                r = new Xt),
                0 === h)
                    return r.set(-2, -1, -1);
                const u = 1 / h
                  , d = (l * o - a * c) * u
                  , p = (s * c - a * o) * u;
                return r.set(1 - d - p, p, d)
            }
            static containsPoint(t, e, n, i) {
                return this.getBarycoord(t, e, n, i, rn),
                rn.x >= 0 && rn.y >= 0 && rn.x + rn.y <= 1
            }
            static getUV(t, e, n, i, r, s, a, o) {
                return this.getBarycoord(t, e, n, i, rn),
                o.set(0, 0),
                o.addScaledVector(r, rn.x),
                o.addScaledVector(s, rn.y),
                o.addScaledVector(a, rn.z),
                o
            }
            static isFrontFacing(t, e, n, i) {
                return tn.subVectors(n, e),
                en.subVectors(t, e),
                tn.cross(en).dot(i) < 0
            }
            set(t, e, n) {
                return this.a.copy(t),
                this.b.copy(e),
                this.c.copy(n),
                this
            }
            setFromPointsAndIndices(t, e, n, i) {
                return this.a.copy(t[e]),
                this.b.copy(t[n]),
                this.c.copy(t[i]),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.a.copy(t.a),
                this.b.copy(t.b),
                this.c.copy(t.c),
                this
            }
            getArea() {
                return tn.subVectors(this.c, this.b),
                en.subVectors(this.a, this.b),
                .5 * tn.cross(en).length()
            }
            getMidpoint(t) {
                return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
                t = new Xt),
                t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(t) {
                return un.getNormal(this.a, this.b, this.c, t)
            }
            getPlane(t) {
                return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"),
                t = new Qe),
                t.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(t, e) {
                return un.getBarycoord(t, this.a, this.b, this.c, e)
            }
            getUV(t, e, n, i, r) {
                return un.getUV(t, this.a, this.b, this.c, e, n, i, r)
            }
            containsPoint(t) {
                return un.containsPoint(t, this.a, this.b, this.c)
            }
            isFrontFacing(t) {
                return un.isFrontFacing(this.a, this.b, this.c, t)
            }
            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }
            closestPointToPoint(t, e) {
                void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
                e = new Xt);
                const n = this.a
                  , i = this.b
                  , r = this.c;
                let s, a;
                sn.subVectors(i, n),
                an.subVectors(r, n),
                ln.subVectors(t, n);
                const o = sn.dot(ln)
                  , l = an.dot(ln);
                if (o <= 0 && l <= 0)
                    return e.copy(n);
                cn.subVectors(t, i);
                const c = sn.dot(cn)
                  , h = an.dot(cn);
                if (c >= 0 && h <= c)
                    return e.copy(i);
                const u = o * h - c * l;
                if (u <= 0 && o >= 0 && c <= 0)
                    return s = o / (o - c),
                    e.copy(n).addScaledVector(sn, s);
                hn.subVectors(t, r);
                const d = sn.dot(hn)
                  , p = an.dot(hn);
                if (p >= 0 && d <= p)
                    return e.copy(r);
                const f = d * l - o * p;
                if (f <= 0 && l >= 0 && p <= 0)
                    return a = l / (l - p),
                    e.copy(n).addScaledVector(an, a);
                const m = c * p - d * h;
                if (m <= 0 && h - c >= 0 && d - p >= 0)
                    return on.subVectors(r, i),
                    a = (h - c) / (h - c + (d - p)),
                    e.copy(i).addScaledVector(on, a);
                const g = 1 / (m + f + u);
                return s = f * g,
                a = u * g,
                e.copy(n).addScaledVector(sn, s).addScaledVector(an, a)
            }
            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }
        let dn = 0;
        function pn() {
            Object.defineProperty(this, "id", {
                value: dn++
            }),
            this.uuid = Pt(),
            this.name = "",
            this.type = "Material",
            this.fog = !0,
            this.blending = 1,
            this.side = 0,
            this.vertexColors = !1,
            this.opacity = 1,
            this.transparent = !1,
            this.blendSrc = 204,
            this.blendDst = 205,
            this.blendEquation = 100,
            this.blendSrcAlpha = null,
            this.blendDstAlpha = null,
            this.blendEquationAlpha = null,
            this.depthFunc = 3,
            this.depthTest = !0,
            this.depthWrite = !0,
            this.stencilWriteMask = 255,
            this.stencilFunc = 519,
            this.stencilRef = 0,
            this.stencilFuncMask = 255,
            this.stencilFail = 7680,
            this.stencilZFail = 7680,
            this.stencilZPass = 7680,
            this.stencilWrite = !1,
            this.clippingPlanes = null,
            this.clipIntersection = !1,
            this.clipShadows = !1,
            this.shadowSide = null,
            this.colorWrite = !0,
            this.precision = null,
            this.polygonOffset = !1,
            this.polygonOffsetFactor = 0,
            this.polygonOffsetUnits = 0,
            this.dithering = !1,
            this.alphaTest = 0,
            this.alphaToCoverage = !1,
            this.premultipliedAlpha = !1,
            this.visible = !0,
            this.toneMapped = !0,
            this.userData = {},
            this.version = 0
        }
        pn.prototype = Object.assign(Object.create(Et.prototype), {
            constructor: pn,
            isMaterial: !0,
            onBuild: function() {},
            onBeforeCompile: function() {},
            customProgramCacheKey: function() {
                return this.onBeforeCompile.toString()
            },
            setValues: function(t) {
                if (void 0 !== t)
                    for (const e in t) {
                        const n = t[e];
                        if (void 0 === n) {
                            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                            continue
                        }
                        if ("shading" === e) {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                            this.flatShading = 1 === n;
                            continue
                        }
                        const i = this[e];
                        void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                    }
            },
            toJSON: function(t) {
                const e = void 0 === t || "string" == typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                function i(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata,
                        e.push(i)
                    }
                    return e
                }
                if (n.uuid = this.uuid,
                n.type = this.type,
                "" !== this.name && (n.name = this.name),
                this.color && this.color.isColor && (n.color = this.color.getHex()),
                void 0 !== this.roughness && (n.roughness = this.roughness),
                void 0 !== this.metalness && (n.metalness = this.metalness),
                this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
                this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                void 0 !== this.shininess && (n.shininess = this.shininess),
                void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
                this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
                this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid,
                n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
                this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
                this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
                this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid,
                n.lightMapIntensity = this.lightMapIntensity),
                this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid,
                n.aoMapIntensity = this.aoMapIntensity),
                this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid,
                n.bumpScale = this.bumpScale),
                this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid,
                n.normalMapType = this.normalMapType,
                n.normalScale = this.normalScale.toArray()),
                this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid,
                n.displacementScale = this.displacementScale,
                n.displacementBias = this.displacementBias),
                this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
                this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid,
                void 0 !== this.combine && (n.combine = this.combine)),
                void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
                void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
                void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
                this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
                void 0 !== this.size && (n.size = this.size),
                null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                1 !== this.blending && (n.blending = this.blending),
                0 !== this.side && (n.side = this.side),
                this.vertexColors && (n.vertexColors = !0),
                this.opacity < 1 && (n.opacity = this.opacity),
                !0 === this.transparent && (n.transparent = this.transparent),
                n.depthFunc = this.depthFunc,
                n.depthTest = this.depthTest,
                n.depthWrite = this.depthWrite,
                n.colorWrite = this.colorWrite,
                n.stencilWrite = this.stencilWrite,
                n.stencilWriteMask = this.stencilWriteMask,
                n.stencilFunc = this.stencilFunc,
                n.stencilRef = this.stencilRef,
                n.stencilFuncMask = this.stencilFuncMask,
                n.stencilFail = this.stencilFail,
                n.stencilZFail = this.stencilZFail,
                n.stencilZPass = this.stencilZPass,
                this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                !0 === this.polygonOffset && (n.polygonOffset = !0),
                0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                void 0 !== this.scale && (n.scale = this.scale),
                !0 === this.dithering && (n.dithering = !0),
                this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage),
                !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
                !0 === this.wireframe && (n.wireframe = this.wireframe),
                this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                !0 === this.morphTargets && (n.morphTargets = !0),
                !0 === this.morphNormals && (n.morphNormals = !0),
                !0 === this.skinning && (n.skinning = !0),
                !0 === this.flatShading && (n.flatShading = this.flatShading),
                !1 === this.visible && (n.visible = !1),
                !1 === this.toneMapped && (n.toneMapped = !1),
                "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
                e) {
                    const e = i(t.textures)
                      , r = i(t.images);
                    e.length > 0 && (n.textures = e),
                    r.length > 0 && (n.images = r)
                }
                return n
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.name = t.name,
                this.fog = t.fog,
                this.blending = t.blending,
                this.side = t.side,
                this.vertexColors = t.vertexColors,
                this.opacity = t.opacity,
                this.transparent = t.transparent,
                this.blendSrc = t.blendSrc,
                this.blendDst = t.blendDst,
                this.blendEquation = t.blendEquation,
                this.blendSrcAlpha = t.blendSrcAlpha,
                this.blendDstAlpha = t.blendDstAlpha,
                this.blendEquationAlpha = t.blendEquationAlpha,
                this.depthFunc = t.depthFunc,
                this.depthTest = t.depthTest,
                this.depthWrite = t.depthWrite,
                this.stencilWriteMask = t.stencilWriteMask,
                this.stencilFunc = t.stencilFunc,
                this.stencilRef = t.stencilRef,
                this.stencilFuncMask = t.stencilFuncMask,
                this.stencilFail = t.stencilFail,
                this.stencilZFail = t.stencilZFail,
                this.stencilZPass = t.stencilZPass,
                this.stencilWrite = t.stencilWrite;
                const e = t.clippingPlanes;
                let n = null;
                if (null !== e) {
                    const t = e.length;
                    n = new Array(t);
                    for (let i = 0; i !== t; ++i)
                        n[i] = e[i].clone()
                }
                return this.clippingPlanes = n,
                this.clipIntersection = t.clipIntersection,
                this.clipShadows = t.clipShadows,
                this.shadowSide = t.shadowSide,
                this.colorWrite = t.colorWrite,
                this.precision = t.precision,
                this.polygonOffset = t.polygonOffset,
                this.polygonOffsetFactor = t.polygonOffsetFactor,
                this.polygonOffsetUnits = t.polygonOffsetUnits,
                this.dithering = t.dithering,
                this.alphaTest = t.alphaTest,
                this.alphaToCoverage = t.alphaToCoverage,
                this.premultipliedAlpha = t.premultipliedAlpha,
                this.visible = t.visible,
                this.toneMapped = t.toneMapped,
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }),
        Object.defineProperty(pn.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        });
        const fn = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }
          , mn = {
            h: 0,
            s: 0,
            l: 0
        }
          , gn = {
            h: 0,
            s: 0,
            l: 0
        };
        function vn(t, e, n) {
            return n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
        }
        function yn(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }
        function xn(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        class _n {
            constructor(t, e, n) {
                return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
            }
            set(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
                this
            }
            setScalar(t) {
                return this.r = t,
                this.g = t,
                this.b = t,
                this
            }
            setHex(t) {
                return t = Math.floor(t),
                this.r = (t >> 16 & 255) / 255,
                this.g = (t >> 8 & 255) / 255,
                this.b = (255 & t) / 255,
                this
            }
            setRGB(t, e, n) {
                return this.r = t,
                this.g = e,
                this.b = n,
                this
            }
            setHSL(t, e, n) {
                if (t = It(t, 1),
                e = Rt(e, 0, 1),
                n = Rt(n, 0, 1),
                0 === e)
                    this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + e) : n + e - n * e
                      , r = 2 * n - i;
                    this.r = vn(r, i, t + 1 / 3),
                    this.g = vn(r, i, t),
                    this.b = vn(r, i, t - 1 / 3)
                }
                return this
            }
            setStyle(t) {
                function e(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                let n;
                if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                    let t;
                    const i = n[1]
                      , r = n[2];
                    switch (i) {
                    case "rgb":
                    case "rgba":
                        if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
                            return this.r = Math.min(255, parseInt(t[1], 10)) / 255,
                            this.g = Math.min(255, parseInt(t[2], 10)) / 255,
                            this.b = Math.min(255, parseInt(t[3], 10)) / 255,
                            e(t[4]),
                            this;
                        if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
                            return this.r = Math.min(100, parseInt(t[1], 10)) / 100,
                            this.g = Math.min(100, parseInt(t[2], 10)) / 100,
                            this.b = Math.min(100, parseInt(t[3], 10)) / 100,
                            e(t[4]),
                            this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                            const n = parseFloat(t[1]) / 360
                              , i = parseInt(t[2], 10) / 100
                              , r = parseInt(t[3], 10) / 100;
                            return e(t[4]),
                            this.setHSL(n, i, r)
                        }
                    }
                } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                    const t = n[1]
                      , e = t.length;
                    if (3 === e)
                        return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255,
                        this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255,
                        this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255,
                        this;
                    if (6 === e)
                        return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255,
                        this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255,
                        this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255,
                        this
                }
                return t && t.length > 0 ? this.setColorName(t) : this
            }
            setColorName(t) {
                const e = fn[t.toLowerCase()];
                return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t),
                this
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copy(t) {
                return this.r = t.r,
                this.g = t.g,
                this.b = t.b,
                this
            }
            copyGammaToLinear(t, e=2) {
                return this.r = Math.pow(t.r, e),
                this.g = Math.pow(t.g, e),
                this.b = Math.pow(t.b, e),
                this
            }
            copyLinearToGamma(t, e=2) {
                const n = e > 0 ? 1 / e : 1;
                return this.r = Math.pow(t.r, n),
                this.g = Math.pow(t.g, n),
                this.b = Math.pow(t.b, n),
                this
            }
            convertGammaToLinear(t) {
                return this.copyGammaToLinear(this, t),
                this
            }
            convertLinearToGamma(t) {
                return this.copyLinearToGamma(this, t),
                this
            }
            copySRGBToLinear(t) {
                return this.r = yn(t.r),
                this.g = yn(t.g),
                this.b = yn(t.b),
                this
            }
            copyLinearToSRGB(t) {
                return this.r = xn(t.r),
                this.g = xn(t.g),
                this.b = xn(t.b),
                this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this),
                this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this),
                this
            }
            getHex() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }
            getHexString() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }
            getHSL(t) {
                void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"),
                t = {
                    h: 0,
                    s: 0,
                    l: 0
                });
                const e = this.r
                  , n = this.g
                  , i = this.b
                  , r = Math.max(e, n, i)
                  , s = Math.min(e, n, i);
                let a, o;
                const l = (s + r) / 2;
                if (s === r)
                    a = 0,
                    o = 0;
                else {
                    const t = r - s;
                    switch (o = l <= .5 ? t / (r + s) : t / (2 - r - s),
                    r) {
                    case e:
                        a = (n - i) / t + (n < i ? 6 : 0);
                        break;
                    case n:
                        a = (i - e) / t + 2;
                        break;
                    case i:
                        a = (e - n) / t + 4
                    }
                    a /= 6
                }
                return t.h = a,
                t.s = o,
                t.l = l,
                t
            }
            getStyle() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            }
            offsetHSL(t, e, n) {
                return this.getHSL(mn),
                mn.h += t,
                mn.s += e,
                mn.l += n,
                this.setHSL(mn.h, mn.s, mn.l),
                this
            }
            add(t) {
                return this.r += t.r,
                this.g += t.g,
                this.b += t.b,
                this
            }
            addColors(t, e) {
                return this.r = t.r + e.r,
                this.g = t.g + e.g,
                this.b = t.b + e.b,
                this
            }
            addScalar(t) {
                return this.r += t,
                this.g += t,
                this.b += t,
                this
            }
            sub(t) {
                return this.r = Math.max(0, this.r - t.r),
                this.g = Math.max(0, this.g - t.g),
                this.b = Math.max(0, this.b - t.b),
                this
            }
            multiply(t) {
                return this.r *= t.r,
                this.g *= t.g,
                this.b *= t.b,
                this
            }
            multiplyScalar(t) {
                return this.r *= t,
                this.g *= t,
                this.b *= t,
                this
            }
            lerp(t, e) {
                return this.r += (t.r - this.r) * e,
                this.g += (t.g - this.g) * e,
                this.b += (t.b - this.b) * e,
                this
            }
            lerpColors(t, e, n) {
                return this.r = t.r + (e.r - t.r) * n,
                this.g = t.g + (e.g - t.g) * n,
                this.b = t.b + (e.b - t.b) * n,
                this
            }
            lerpHSL(t, e) {
                this.getHSL(mn),
                t.getHSL(gn);
                const n = Dt(mn.h, gn.h, e)
                  , i = Dt(mn.s, gn.s, e)
                  , r = Dt(mn.l, gn.l, e);
                return this.setHSL(n, i, r),
                this
            }
            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }
            fromArray(t, e=0) {
                return this.r = t[e],
                this.g = t[e + 1],
                this.b = t[e + 2],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.r,
                t[e + 1] = this.g,
                t[e + 2] = this.b,
                t
            }
            fromBufferAttribute(t, e) {
                return this.r = t.getX(e),
                this.g = t.getY(e),
                this.b = t.getZ(e),
                !0 === t.normalized && (this.r /= 255,
                this.g /= 255,
                this.b /= 255),
                this
            }
            toJSON() {
                return this.getHex()
            }
        }
        _n.NAMES = fn,
        _n.prototype.isColor = !0,
        _n.prototype.r = 1,
        _n.prototype.g = 1,
        _n.prototype.b = 1;
        class wn extends pn {
            constructor(t) {
                super(),
                this.type = "MeshBasicMaterial",
                this.color = new _n(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = 0,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.skinning = !1,
                this.morphTargets = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this
            }
        }
        wn.prototype.isMeshBasicMaterial = !0;
        const bn = new Xt
          , Mn = new Bt;
        class Sn {
            constructor(t, e, n) {
                if (Array.isArray(t))
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "",
                this.array = t,
                this.itemSize = e,
                this.count = void 0 !== t ? t.length / e : 0,
                this.normalized = !0 === n,
                this.usage = 35044,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0,
                this.onUploadCallback = function() {}
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t,
                this
            }
            copy(t) {
                return this.name = t.name,
                this.array = new t.array.constructor(t.array),
                this.itemSize = t.itemSize,
                this.count = t.count,
                this.normalized = t.normalized,
                this.usage = t.usage,
                this
            }
            copyAt(t, e, n) {
                t *= this.itemSize,
                n *= e.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++)
                    this.array[t + i] = e.array[n + i];
                return this
            }
            copyArray(t) {
                return this.array.set(t),
                this
            }
            copyColorsArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i),
                    r = new _n),
                    e[n++] = r.r,
                    e[n++] = r.g,
                    e[n++] = r.b
                }
                return this
            }
            copyVector2sArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i),
                    r = new Bt),
                    e[n++] = r.x,
                    e[n++] = r.y
                }
                return this
            }
            copyVector3sArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i),
                    r = new Xt),
                    e[n++] = r.x,
                    e[n++] = r.y,
                    e[n++] = r.z
                }
                return this
            }
            copyVector4sArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i),
                    r = new Wt),
                    e[n++] = r.x,
                    e[n++] = r.y,
                    e[n++] = r.z,
                    e[n++] = r.w
                }
                return this
            }
            applyMatrix3(t) {
                if (2 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++)
                        Mn.fromBufferAttribute(this, e),
                        Mn.applyMatrix3(t),
                        this.setXY(e, Mn.x, Mn.y);
                else if (3 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++)
                        bn.fromBufferAttribute(this, e),
                        bn.applyMatrix3(t),
                        this.setXYZ(e, bn.x, bn.y, bn.z);
                return this
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    bn.x = this.getX(e),
                    bn.y = this.getY(e),
                    bn.z = this.getZ(e),
                    bn.applyMatrix4(t),
                    this.setXYZ(e, bn.x, bn.y, bn.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    bn.x = this.getX(e),
                    bn.y = this.getY(e),
                    bn.z = this.getZ(e),
                    bn.applyNormalMatrix(t),
                    this.setXYZ(e, bn.x, bn.y, bn.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    bn.x = this.getX(e),
                    bn.y = this.getY(e),
                    bn.z = this.getZ(e),
                    bn.transformDirection(t),
                    this.setXYZ(e, bn.x, bn.y, bn.z);
                return this
            }
            set(t, e=0) {
                return this.array.set(t, e),
                this
            }
            getX(t) {
                return this.array[t * this.itemSize]
            }
            setX(t, e) {
                return this.array[t * this.itemSize] = e,
                this
            }
            getY(t) {
                return this.array[t * this.itemSize + 1]
            }
            setY(t, e) {
                return this.array[t * this.itemSize + 1] = e,
                this
            }
            getZ(t) {
                return this.array[t * this.itemSize + 2]
            }
            setZ(t, e) {
                return this.array[t * this.itemSize + 2] = e,
                this
            }
            getW(t) {
                return this.array[t * this.itemSize + 3]
            }
            setW(t, e) {
                return this.array[t * this.itemSize + 3] = e,
                this
            }
            setXY(t, e, n) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this
            }
            setXYZ(t, e, n, i) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this.array[t + 2] = i,
                this
            }
            setXYZW(t, e, n, i, r) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this.array[t + 2] = i,
                this.array[t + 3] = r,
                this
            }
            onUpload(t) {
                return this.onUploadCallback = t,
                this
            }
            clone() {
                return new this.constructor(this.array,this.itemSize).copy(this)
            }
            toJSON() {
                const t = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (t.name = this.name),
                35044 !== this.usage && (t.usage = this.usage),
                0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange),
                t
            }
        }
        Sn.prototype.isBufferAttribute = !0;
        class Tn extends Sn {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }
        class En extends Sn {
            constructor(t, e, n) {
                super(new Uint32Array(t), e, n)
            }
        }
        (class extends Sn {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }
        ).prototype.isFloat16BufferAttribute = !0;
        class Ln extends Sn {
            constructor(t, e, n) {
                super(new Float32Array(t), e, n)
            }
        }
        function An(t) {
            if (0 === t.length)
                return -1 / 0;
            let e = t[0];
            for (let n = 1, i = t.length; n < i; ++n)
                t[n] > e && (e = t[n]);
            return e
        }
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array;
        let Cn = 0;
        const Pn = new Se
          , Rn = new Ze
          , In = new Xt
          , Dn = new Jt
          , Nn = new Jt
          , On = new Xt;
        class zn extends Et {
            constructor() {
                super(),
                Object.defineProperty(this, "id", {
                    value: Cn++
                }),
                this.uuid = Pt(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.morphTargetsRelative = !1,
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                },
                this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(t) {
                return Array.isArray(t) ? this.index = new (An(t) > 65535 ? En : Tn)(t,1) : this.index = t,
                this
            }
            getAttribute(t) {
                return this.attributes[t]
            }
            setAttribute(t, e) {
                return this.attributes[t] = e,
                this
            }
            deleteAttribute(t) {
                return delete this.attributes[t],
                this
            }
            hasAttribute(t) {
                return void 0 !== this.attributes[t]
            }
            addGroup(t, e, n=0) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(t, e) {
                this.drawRange.start = t,
                this.drawRange.count = e
            }
            applyMatrix4(t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t),
                e.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const e = (new kt).getNormalMatrix(t);
                    n.applyNormalMatrix(e),
                    n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(t),
                i.needsUpdate = !0),
                null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                this
            }
            rotateX(t) {
                return Pn.makeRotationX(t),
                this.applyMatrix4(Pn),
                this
            }
            rotateY(t) {
                return Pn.makeRotationY(t),
                this.applyMatrix4(Pn),
                this
            }
            rotateZ(t) {
                return Pn.makeRotationZ(t),
                this.applyMatrix4(Pn),
                this
            }
            translate(t, e, n) {
                return Pn.makeTranslation(t, e, n),
                this.applyMatrix4(Pn),
                this
            }
            scale(t, e, n) {
                return Pn.makeScale(t, e, n),
                this.applyMatrix4(Pn),
                this
            }
            lookAt(t) {
                return Rn.lookAt(t),
                Rn.updateMatrix(),
                this.applyMatrix4(Rn.matrix),
                this
            }
            center() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(In).negate(),
                this.translate(In.x, In.y, In.z),
                this
            }
            setFromPoints(t) {
                const e = [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    e.push(i.x, i.y, i.z || 0)
                }
                return this.setAttribute("position", new Ln(e,3)),
                this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new Jt);
                const t = this.attributes.position
                  , e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingBox.set(new Xt(-1 / 0,-1 / 0,-1 / 0), new Xt(1 / 0,1 / 0,1 / 0));
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t),
                    e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            Dn.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (On.addVectors(this.boundingBox.min, Dn.min),
                            this.boundingBox.expandByPoint(On),
                            On.addVectors(this.boundingBox.max, Dn.max),
                            this.boundingBox.expandByPoint(On)) : (this.boundingBox.expandByPoint(Dn.min),
                            this.boundingBox.expandByPoint(Dn.max))
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new me);
                const t = this.attributes.position
                  , e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingSphere.set(new Xt, 1 / 0);
                if (t) {
                    const n = this.boundingSphere.center;
                    if (Dn.setFromBufferAttribute(t),
                    e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            Nn.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (On.addVectors(Dn.min, Nn.min),
                            Dn.expandByPoint(On),
                            On.addVectors(Dn.max, Nn.max),
                            Dn.expandByPoint(On)) : (Dn.expandByPoint(Nn.min),
                            Dn.expandByPoint(Nn.max))
                        }
                    Dn.getCenter(n);
                    let i = 0;
                    for (let e = 0, r = t.count; e < r; e++)
                        On.fromBufferAttribute(t, e),
                        i = Math.max(i, n.distanceToSquared(On));
                    if (e)
                        for (let r = 0, s = e.length; r < s; r++) {
                            const s = e[r]
                              , a = this.morphTargetsRelative;
                            for (let e = 0, r = s.count; e < r; e++)
                                On.fromBufferAttribute(s, e),
                                a && (In.fromBufferAttribute(t, e),
                                On.add(In)),
                                i = Math.max(i, n.distanceToSquared(On))
                        }
                    this.boundingSphere.radius = Math.sqrt(i),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeFaceNormals() {}
            computeTangents() {
                const t = this.index
                  , e = this.attributes;
                if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
                    return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = t.array
                  , i = e.position.array
                  , r = e.normal.array
                  , s = e.uv.array
                  , a = i.length / 3;
                void 0 === e.tangent && this.setAttribute("tangent", new Sn(new Float32Array(4 * a),4));
                const o = e.tangent.array
                  , l = []
                  , c = [];
                for (let t = 0; t < a; t++)
                    l[t] = new Xt,
                    c[t] = new Xt;
                const h = new Xt
                  , u = new Xt
                  , d = new Xt
                  , p = new Bt
                  , f = new Bt
                  , m = new Bt
                  , g = new Xt
                  , v = new Xt;
                function y(t, e, n) {
                    h.fromArray(i, 3 * t),
                    u.fromArray(i, 3 * e),
                    d.fromArray(i, 3 * n),
                    p.fromArray(s, 2 * t),
                    f.fromArray(s, 2 * e),
                    m.fromArray(s, 2 * n),
                    u.sub(h),
                    d.sub(h),
                    f.sub(p),
                    m.sub(p);
                    const r = 1 / (f.x * m.y - m.x * f.y);
                    isFinite(r) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r),
                    v.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r),
                    l[t].add(g),
                    l[e].add(g),
                    l[n].add(g),
                    c[t].add(v),
                    c[e].add(v),
                    c[n].add(v))
                }
                let x = this.groups;
                0 === x.length && (x = [{
                    start: 0,
                    count: n.length
                }]);
                for (let t = 0, e = x.length; t < e; ++t) {
                    const e = x[t]
                      , i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3)
                        y(n[t + 0], n[t + 1], n[t + 2])
                }
                const _ = new Xt
                  , w = new Xt
                  , b = new Xt
                  , M = new Xt;
                function S(t) {
                    b.fromArray(r, 3 * t),
                    M.copy(b);
                    const e = l[t];
                    _.copy(e),
                    _.sub(b.multiplyScalar(b.dot(e))).normalize(),
                    w.crossVectors(M, e);
                    const n = w.dot(c[t]) < 0 ? -1 : 1;
                    o[4 * t] = _.x,
                    o[4 * t + 1] = _.y,
                    o[4 * t + 2] = _.z,
                    o[4 * t + 3] = n
                }
                for (let t = 0, e = x.length; t < e; ++t) {
                    const e = x[t]
                      , i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3)
                        S(n[t + 0]),
                        S(n[t + 1]),
                        S(n[t + 2])
                }
            }
            computeVertexNormals() {
                const t = this.index
                  , e = this.getAttribute("position");
                if (void 0 !== e) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n)
                        n = new Sn(new Float32Array(3 * e.count),3),
                        this.setAttribute("normal", n);
                    else
                        for (let t = 0, e = n.count; t < e; t++)
                            n.setXYZ(t, 0, 0, 0);
                    const i = new Xt
                      , r = new Xt
                      , s = new Xt
                      , a = new Xt
                      , o = new Xt
                      , l = new Xt
                      , c = new Xt
                      , h = new Xt;
                    if (t)
                        for (let u = 0, d = t.count; u < d; u += 3) {
                            const d = t.getX(u + 0)
                              , p = t.getX(u + 1)
                              , f = t.getX(u + 2);
                            i.fromBufferAttribute(e, d),
                            r.fromBufferAttribute(e, p),
                            s.fromBufferAttribute(e, f),
                            c.subVectors(s, r),
                            h.subVectors(i, r),
                            c.cross(h),
                            a.fromBufferAttribute(n, d),
                            o.fromBufferAttribute(n, p),
                            l.fromBufferAttribute(n, f),
                            a.add(c),
                            o.add(c),
                            l.add(c),
                            n.setXYZ(d, a.x, a.y, a.z),
                            n.setXYZ(p, o.x, o.y, o.z),
                            n.setXYZ(f, l.x, l.y, l.z)
                        }
                    else
                        for (let t = 0, a = e.count; t < a; t += 3)
                            i.fromBufferAttribute(e, t + 0),
                            r.fromBufferAttribute(e, t + 1),
                            s.fromBufferAttribute(e, t + 2),
                            c.subVectors(s, r),
                            h.subVectors(i, r),
                            c.cross(h),
                            n.setXYZ(t + 0, c.x, c.y, c.z),
                            n.setXYZ(t + 1, c.x, c.y, c.z),
                            n.setXYZ(t + 2, c.x, c.y, c.z);
                    this.normalizeNormals(),
                    n.needsUpdate = !0
                }
            }
            merge(t, e) {
                if (!t || !t.isBufferGeometry)
                    return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                void 0 === e && (e = 0,
                console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                const n = this.attributes;
                for (const i in n) {
                    if (void 0 === t.attributes[i])
                        continue;
                    const r = n[i].array
                      , s = t.attributes[i]
                      , a = s.array
                      , o = s.itemSize * e
                      , l = Math.min(a.length, r.length - o);
                    for (let t = 0, e = o; t < l; t++,
                    e++)
                        r[e] = a[t]
                }
                return this
            }
            normalizeNormals() {
                const t = this.attributes.normal;
                for (let e = 0, n = t.count; e < n; e++)
                    On.fromBufferAttribute(t, e),
                    On.normalize(),
                    t.setXYZ(e, On.x, On.y, On.z)
            }
            toNonIndexed() {
                function t(t, e) {
                    const n = t.array
                      , i = t.itemSize
                      , r = t.normalized
                      , s = new n.constructor(e.length * i);
                    let a = 0
                      , o = 0;
                    for (let t = 0, r = e.length; t < r; t++) {
                        a = e[t] * i;
                        for (let t = 0; t < i; t++)
                            s[o++] = n[a++]
                    }
                    return new Sn(s,i,r)
                }
                if (null === this.index)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                    this;
                const e = new zn
                  , n = this.index.array
                  , i = this.attributes;
                for (const r in i) {
                    const s = t(i[r], n);
                    e.setAttribute(r, s)
                }
                const r = this.morphAttributes;
                for (const i in r) {
                    const s = []
                      , a = r[i];
                    for (let e = 0, i = a.length; e < i; e++) {
                        const i = t(a[e], n);
                        s.push(i)
                    }
                    e.morphAttributes[i] = s
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const s = this.groups;
                for (let t = 0, n = s.length; t < n; t++) {
                    const n = s[t];
                    e.addGroup(n.start, n.count, n.materialIndex)
                }
                return e
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid,
                t.type = this.type,
                "" !== this.name && (t.name = this.name),
                Object.keys(this.userData).length > 0 && (t.userData = this.userData),
                void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const n in e)
                        void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                const e = this.index;
                null !== e && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const n = this.attributes;
                for (const e in n) {
                    const i = n[e];
                    t.data.attributes[e] = i.toJSON(t.data)
                }
                const i = {};
                let r = !1;
                for (const e in this.morphAttributes) {
                    const n = this.morphAttributes[e]
                      , s = [];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        s.push(i.toJSON(t.data))
                    }
                    s.length > 0 && (i[e] = s,
                    r = !0)
                }
                r && (t.data.morphAttributes = i,
                t.data.morphTargetsRelative = this.morphTargetsRelative);
                const s = this.groups;
                s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                const a = this.boundingSphere;
                return null !== a && (t.data.boundingSphere = {
                    center: a.center.toArray(),
                    radius: a.radius
                }),
                t
            }
            clone() {
                return (new zn).copy(this)
            }
            copy(t) {
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null;
                const e = {};
                this.name = t.name;
                const n = t.index;
                null !== n && this.setIndex(n.clone(e));
                const i = t.attributes;
                for (const t in i) {
                    const n = i[t];
                    this.setAttribute(t, n.clone(e))
                }
                const r = t.morphAttributes;
                for (const t in r) {
                    const n = []
                      , i = r[t];
                    for (let t = 0, r = i.length; t < r; t++)
                        n.push(i[t].clone(e));
                    this.morphAttributes[t] = n
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                const s = t.groups;
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = s[t];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const a = t.boundingBox;
                null !== a && (this.boundingBox = a.clone());
                const o = t.boundingSphere;
                return null !== o && (this.boundingSphere = o.clone()),
                this.drawRange.start = t.drawRange.start,
                this.drawRange.count = t.drawRange.count,
                this.userData = t.userData,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        zn.prototype.isBufferGeometry = !0;
        const Bn = new Se
          , kn = new Me
          , Fn = new me
          , Hn = new Xt
          , Un = new Xt
          , Gn = new Xt
          , Vn = new Xt
          , Wn = new Xt
          , jn = new Xt
          , qn = new Xt
          , Xn = new Xt
          , Yn = new Xt
          , Zn = new Bt
          , Jn = new Bt
          , $n = new Bt
          , Kn = new Xt
          , Qn = new Xt;
        class ti extends Ze {
            constructor(t=new zn, e=new wn) {
                super(),
                this.type = "Mesh",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t) {
                return super.copy(t),
                void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
                void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
                this.material = t.material,
                this.geometry = t.geometry,
                this
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                      , n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
            raycast(t, e) {
                const n = this.geometry
                  , i = this.material
                  , r = this.matrixWorld;
                if (void 0 === i)
                    return;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                Fn.copy(n.boundingSphere),
                Fn.applyMatrix4(r),
                !1 === t.ray.intersectsSphere(Fn))
                    return;
                if (Bn.copy(r).invert(),
                kn.copy(t.ray).applyMatrix4(Bn),
                null !== n.boundingBox && !1 === kn.intersectsBox(n.boundingBox))
                    return;
                let s;
                if (n.isBufferGeometry) {
                    const r = n.index
                      , a = n.attributes.position
                      , o = n.morphAttributes.position
                      , l = n.morphTargetsRelative
                      , c = n.attributes.uv
                      , h = n.attributes.uv2
                      , u = n.groups
                      , d = n.drawRange;
                    if (null !== r)
                        if (Array.isArray(i))
                            for (let n = 0, p = u.length; n < p; n++) {
                                const p = u[n]
                                  , f = i[p.materialIndex];
                                for (let n = Math.max(p.start, d.start), i = Math.min(p.start + p.count, d.start + d.count); n < i; n += 3) {
                                    const i = r.getX(n)
                                      , u = r.getX(n + 1)
                                      , d = r.getX(n + 2);
                                    s = ei(this, f, t, kn, a, o, l, c, h, i, u, d),
                                    s && (s.faceIndex = Math.floor(n / 3),
                                    s.face.materialIndex = p.materialIndex,
                                    e.push(s))
                                }
                            }
                        else {
                            for (let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); n < u; n += 3) {
                                const u = r.getX(n)
                                  , d = r.getX(n + 1)
                                  , p = r.getX(n + 2);
                                s = ei(this, i, t, kn, a, o, l, c, h, u, d, p),
                                s && (s.faceIndex = Math.floor(n / 3),
                                e.push(s))
                            }
                        }
                    else if (void 0 !== a)
                        if (Array.isArray(i))
                            for (let n = 0, r = u.length; n < r; n++) {
                                const r = u[n]
                                  , p = i[r.materialIndex];
                                for (let n = Math.max(r.start, d.start), i = Math.min(r.start + r.count, d.start + d.count); n < i; n += 3) {
                                    s = ei(this, p, t, kn, a, o, l, c, h, n, n + 1, n + 2),
                                    s && (s.faceIndex = Math.floor(n / 3),
                                    s.face.materialIndex = r.materialIndex,
                                    e.push(s))
                                }
                            }
                        else {
                            for (let n = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); n < r; n += 3) {
                                s = ei(this, i, t, kn, a, o, l, c, h, n, n + 1, n + 2),
                                s && (s.faceIndex = Math.floor(n / 3),
                                e.push(s))
                            }
                        }
                } else
                    n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
        function ei(t, e, n, i, r, s, a, o, l, c, h, u) {
            Hn.fromBufferAttribute(r, c),
            Un.fromBufferAttribute(r, h),
            Gn.fromBufferAttribute(r, u);
            const d = t.morphTargetInfluences;
            if (e.morphTargets && s && d) {
                qn.set(0, 0, 0),
                Xn.set(0, 0, 0),
                Yn.set(0, 0, 0);
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = d[t]
                      , n = s[t];
                    0 !== e && (Vn.fromBufferAttribute(n, c),
                    Wn.fromBufferAttribute(n, h),
                    jn.fromBufferAttribute(n, u),
                    a ? (qn.addScaledVector(Vn, e),
                    Xn.addScaledVector(Wn, e),
                    Yn.addScaledVector(jn, e)) : (qn.addScaledVector(Vn.sub(Hn), e),
                    Xn.addScaledVector(Wn.sub(Un), e),
                    Yn.addScaledVector(jn.sub(Gn), e)))
                }
                Hn.add(qn),
                Un.add(Xn),
                Gn.add(Yn)
            }
            t.isSkinnedMesh && e.skinning && (t.boneTransform(c, Hn),
            t.boneTransform(h, Un),
            t.boneTransform(u, Gn));
            const p = function(t, e, n, i, r, s, a, o) {
                let l;
                if (l = 1 === e.side ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, 2 !== e.side, o),
                null === l)
                    return null;
                Qn.copy(o),
                Qn.applyMatrix4(t.matrixWorld);
                const c = n.ray.origin.distanceTo(Qn);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: Qn.clone(),
                    object: t
                }
            }(t, e, n, i, Hn, Un, Gn, Kn);
            if (p) {
                o && (Zn.fromBufferAttribute(o, c),
                Jn.fromBufferAttribute(o, h),
                $n.fromBufferAttribute(o, u),
                p.uv = un.getUV(Kn, Hn, Un, Gn, Zn, Jn, $n, new Bt)),
                l && (Zn.fromBufferAttribute(l, c),
                Jn.fromBufferAttribute(l, h),
                $n.fromBufferAttribute(l, u),
                p.uv2 = un.getUV(Kn, Hn, Un, Gn, Zn, Jn, $n, new Bt));
                const t = {
                    a: c,
                    b: h,
                    c: u,
                    normal: new Xt,
                    materialIndex: 0
                };
                un.getNormal(Hn, Un, Gn, t.normal),
                p.face = t
            }
            return p
        }
        ti.prototype.isMesh = !0;
        class ni extends zn {
            constructor(t=1, e=1, n=1, i=1, r=1, s=1) {
                super(),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: s
                };
                const a = this;
                i = Math.floor(i),
                r = Math.floor(r),
                s = Math.floor(s);
                const o = []
                  , l = []
                  , c = []
                  , h = [];
                let u = 0
                  , d = 0;
                function p(t, e, n, i, r, s, p, f, m, g, v) {
                    const y = s / m
                      , x = p / g
                      , _ = s / 2
                      , w = p / 2
                      , b = f / 2
                      , M = m + 1
                      , S = g + 1;
                    let T = 0
                      , E = 0;
                    const L = new Xt;
                    for (let s = 0; s < S; s++) {
                        const a = s * x - w;
                        for (let o = 0; o < M; o++) {
                            const u = o * y - _;
                            L[t] = u * i,
                            L[e] = a * r,
                            L[n] = b,
                            l.push(L.x, L.y, L.z),
                            L[t] = 0,
                            L[e] = 0,
                            L[n] = f > 0 ? 1 : -1,
                            c.push(L.x, L.y, L.z),
                            h.push(o / m),
                            h.push(1 - s / g),
                            T += 1
                        }
                    }
                    for (let t = 0; t < g; t++)
                        for (let e = 0; e < m; e++) {
                            const n = u + e + M * t
                              , i = u + e + M * (t + 1)
                              , r = u + (e + 1) + M * (t + 1)
                              , s = u + (e + 1) + M * t;
                            o.push(n, i, s),
                            o.push(i, r, s),
                            E += 6
                        }
                    a.addGroup(d, E, v),
                    d += E,
                    u += T
                }
                p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
                p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
                p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
                p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
                p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
                p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
                this.setIndex(o),
                this.setAttribute("position", new Ln(l,3)),
                this.setAttribute("normal", new Ln(c,3)),
                this.setAttribute("uv", new Ln(h,2))
            }
        }
        function ii(t) {
            const e = {};
            for (const n in t) {
                e[n] = {};
                for (const i in t[n]) {
                    const r = t[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                }
            }
            return e
        }
        function ri(t) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const i = ii(t[n]);
                for (const t in i)
                    e[t] = i[t]
            }
            return e
        }
        const si = {
            clone: ii,
            merge: ri
        };
        class ai extends pn {
            constructor(t) {
                super(),
                this.type = "ShaderMaterial",
                this.defines = {},
                this.uniforms = {},
                this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
                this.linewidth = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.clipping = !1,
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                },
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                },
                this.index0AttributeName = void 0,
                this.uniformsNeedUpdate = !1,
                this.glslVersion = null,
                void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
                this.setValues(t))
            }
            copy(t) {
                return super.copy(t),
                this.fragmentShader = t.fragmentShader,
                this.vertexShader = t.vertexShader,
                this.uniforms = ii(t.uniforms),
                this.defines = Object.assign({}, t.defines),
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.lights = t.lights,
                this.clipping = t.clipping,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this.extensions = Object.assign({}, t.extensions),
                this.glslVersion = t.glslVersion,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                e.glslVersion = this.glslVersion,
                e.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(t).uuid
                    } : i && i.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? e.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? e.uniforms[n] = {
                        type: "m4",
                        value: i.toArray()
                    } : e.uniforms[n] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines),
                e.vertexShader = this.vertexShader,
                e.fragmentShader = this.fragmentShader;
                const n = {};
                for (const t in this.extensions)
                    !0 === this.extensions[t] && (n[t] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n),
                e
            }
        }
        ai.prototype.isShaderMaterial = !0;
        class oi extends Ze {
            constructor() {
                super(),
                this.type = "Camera",
                this.matrixWorldInverse = new Se,
                this.projectionMatrix = new Se,
                this.projectionMatrixInverse = new Se
            }
            copy(t, e) {
                return super.copy(t, e),
                this.matrixWorldInverse.copy(t.matrixWorldInverse),
                this.projectionMatrix.copy(t.projectionMatrix),
                this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                this
            }
            getWorldDirection(t) {
                void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"),
                t = new Xt),
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(-e[8], -e[9], -e[10]).normalize()
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(t, e) {
                super.updateWorldMatrix(t, e),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        oi.prototype.isCamera = !0;
        class li extends oi {
            constructor(t=50, e=1, n=.1, i=2e3) {
                super(),
                this.type = "PerspectiveCamera",
                this.fov = t,
                this.zoom = 1,
                this.near = n,
                this.far = i,
                this.focus = 10,
                this.aspect = e,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.fov = t.fov,
                this.zoom = t.zoom,
                this.near = t.near,
                this.far = t.far,
                this.focus = t.focus,
                this.aspect = t.aspect,
                this.view = null === t.view ? null : Object.assign({}, t.view),
                this.filmGauge = t.filmGauge,
                this.filmOffset = t.filmOffset,
                this
            }
            setFocalLength(t) {
                const e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * Ct * Math.atan(e),
                this.updateProjectionMatrix()
            }
            getFocalLength() {
                const t = Math.tan(.5 * At * this.fov);
                return .5 * this.getFilmHeight() / t
            }
            getEffectiveFOV() {
                return 2 * Ct * Math.atan(Math.tan(.5 * At * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(t, e, n, i, r, s) {
                this.aspect = t / e,
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = t,
                this.view.fullHeight = e,
                this.view.offsetX = n,
                this.view.offsetY = i,
                this.view.width = r,
                this.view.height = s,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = this.near;
                let e = t * Math.tan(.5 * At * this.fov) / this.zoom
                  , n = 2 * e
                  , i = this.aspect * n
                  , r = -.5 * i;
                const s = this.view;
                if (null !== this.view && this.view.enabled) {
                    const t = s.fullWidth
                      , a = s.fullHeight;
                    r += s.offsetX * i / t,
                    e -= s.offsetY * n / a,
                    i *= s.width / t,
                    n *= s.height / a
                }
                const a = this.filmOffset;
                0 !== a && (r += t * a / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.fov = this.fov,
                e.object.zoom = this.zoom,
                e.object.near = this.near,
                e.object.far = this.far,
                e.object.focus = this.focus,
                e.object.aspect = this.aspect,
                null !== this.view && (e.object.view = Object.assign({}, this.view)),
                e.object.filmGauge = this.filmGauge,
                e.object.filmOffset = this.filmOffset,
                e
            }
        }
        li.prototype.isPerspectiveCamera = !0;
        class ci extends Ze {
            constructor(t, e, n) {
                if (super(),
                this.type = "CubeCamera",
                !0 !== n.isWebGLCubeRenderTarget)
                    return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                this.renderTarget = n;
                const i = new li(90,1,t,e);
                i.layers = this.layers,
                i.up.set(0, -1, 0),
                i.lookAt(new Xt(1,0,0)),
                this.add(i);
                const r = new li(90,1,t,e);
                r.layers = this.layers,
                r.up.set(0, -1, 0),
                r.lookAt(new Xt(-1,0,0)),
                this.add(r);
                const s = new li(90,1,t,e);
                s.layers = this.layers,
                s.up.set(0, 0, 1),
                s.lookAt(new Xt(0,1,0)),
                this.add(s);
                const a = new li(90,1,t,e);
                a.layers = this.layers,
                a.up.set(0, 0, -1),
                a.lookAt(new Xt(0,-1,0)),
                this.add(a);
                const o = new li(90,1,t,e);
                o.layers = this.layers,
                o.up.set(0, -1, 0),
                o.lookAt(new Xt(0,0,1)),
                this.add(o);
                const l = new li(90,1,t,e);
                l.layers = this.layers,
                l.up.set(0, -1, 0),
                l.lookAt(new Xt(0,0,-1)),
                this.add(l)
            }
            update(t, e) {
                null === this.parent && this.updateMatrixWorld();
                const n = this.renderTarget
                  , [i,r,s,a,o,l] = this.children
                  , c = t.xr.enabled
                  , h = t.getRenderTarget();
                t.xr.enabled = !1;
                const u = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1,
                t.setRenderTarget(n, 0),
                t.render(e, i),
                t.setRenderTarget(n, 1),
                t.render(e, r),
                t.setRenderTarget(n, 2),
                t.render(e, s),
                t.setRenderTarget(n, 3),
                t.render(e, a),
                t.setRenderTarget(n, 4),
                t.render(e, o),
                n.texture.generateMipmaps = u,
                t.setRenderTarget(n, 5),
                t.render(e, l),
                t.setRenderTarget(h),
                t.xr.enabled = c
            }
        }
        class hi extends Gt {
            constructor(t, e, n, i, r, s, a, o, l, c) {
                super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, n, i, r, s, a = void 0 !== a ? a : 1022, o, l, c),
                this._needsFlipEnvMap = !0,
                this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(t) {
                this.image = t
            }
        }
        hi.prototype.isCubeTexture = !0;
        class ui extends jt {
            constructor(t, e, n) {
                Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),
                e = n),
                super(t, t, e),
                e = e || {},
                this.texture = new hi(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),
                this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps,
                this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : 1006,
                this.texture._needsFlipEnvMap = !1
            }
            fromEquirectangularTexture(t, e) {
                this.texture.type = e.type,
                this.texture.format = 1023,
                this.texture.encoding = e.encoding,
                this.texture.generateMipmaps = e.generateMipmaps,
                this.texture.minFilter = e.minFilter,
                this.texture.magFilter = e.magFilter;
                const n = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                }
                  , i = new ni(5,5,5)
                  , r = new ai({
                    name: "CubemapFromEquirect",
                    uniforms: ii(n.uniforms),
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader,
                    side: 1,
                    blending: 0
                });
                r.uniforms.tEquirect.value = e;
                const s = new ti(i,r)
                  , a = e.minFilter;
                1008 === e.minFilter && (e.minFilter = 1006);
                return new ci(1,10,this).update(t, s),
                e.minFilter = a,
                s.geometry.dispose(),
                s.material.dispose(),
                this
            }
            clear(t, e, n, i) {
                const r = t.getRenderTarget();
                for (let r = 0; r < 6; r++)
                    t.setRenderTarget(this, r),
                    t.clear(e, n, i);
                t.setRenderTarget(r)
            }
        }
        ui.prototype.isWebGLCubeRenderTarget = !0;
        class di extends Gt {
            constructor(t, e, n, i, r, s, a, o, l, c, h, u) {
                super(null, s, a, o, l, c, i, r, h, u),
                this.image = {
                    data: t || null,
                    width: e || 1,
                    height: n || 1
                },
                this.magFilter = void 0 !== l ? l : 1003,
                this.minFilter = void 0 !== c ? c : 1003,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1,
                this.needsUpdate = !0
            }
        }
        di.prototype.isDataTexture = !0;
        const pi = new me
          , fi = new Xt;
        class mi {
            constructor(t=new Qe, e=new Qe, n=new Qe, i=new Qe, r=new Qe, s=new Qe) {
                this.planes = [t, e, n, i, r, s]
            }
            set(t, e, n, i, r, s) {
                const a = this.planes;
                return a[0].copy(t),
                a[1].copy(e),
                a[2].copy(n),
                a[3].copy(i),
                a[4].copy(r),
                a[5].copy(s),
                this
            }
            copy(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    e[n].copy(t.planes[n]);
                return this
            }
            setFromProjectionMatrix(t) {
                const e = this.planes
                  , n = t.elements
                  , i = n[0]
                  , r = n[1]
                  , s = n[2]
                  , a = n[3]
                  , o = n[4]
                  , l = n[5]
                  , c = n[6]
                  , h = n[7]
                  , u = n[8]
                  , d = n[9]
                  , p = n[10]
                  , f = n[11]
                  , m = n[12]
                  , g = n[13]
                  , v = n[14]
                  , y = n[15];
                return e[0].setComponents(a - i, h - o, f - u, y - m).normalize(),
                e[1].setComponents(a + i, h + o, f + u, y + m).normalize(),
                e[2].setComponents(a + r, h + l, f + d, y + g).normalize(),
                e[3].setComponents(a - r, h - l, f - d, y - g).normalize(),
                e[4].setComponents(a - s, h - c, f - p, y - v).normalize(),
                e[5].setComponents(a + s, h + c, f + p, y + v).normalize(),
                this
            }
            intersectsObject(t) {
                const e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(),
                pi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
                this.intersectsSphere(pi)
            }
            intersectsSprite(t) {
                return pi.center.set(0, 0, 0),
                pi.radius = .7071067811865476,
                pi.applyMatrix4(t.matrixWorld),
                this.intersectsSphere(pi)
            }
            intersectsSphere(t) {
                const e = this.planes
                  , n = t.center
                  , i = -t.radius;
                for (let t = 0; t < 6; t++) {
                    if (e[t].distanceToPoint(n) < i)
                        return !1
                }
                return !0
            }
            intersectsBox(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = e[n];
                    if (fi.x = i.normal.x > 0 ? t.max.x : t.min.x,
                    fi.y = i.normal.y > 0 ? t.max.y : t.min.y,
                    fi.z = i.normal.z > 0 ? t.max.z : t.min.z,
                    i.distanceToPoint(fi) < 0)
                        return !1
                }
                return !0
            }
            containsPoint(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0)
                        return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        function gi() {
            let t = null
              , e = !1
              , n = null
              , i = null;
            function r(e, s) {
                n(e, s),
                i = t.requestAnimationFrame(r)
            }
            return {
                start: function() {
                    !0 !== e && null !== n && (i = t.requestAnimationFrame(r),
                    e = !0)
                },
                stop: function() {
                    t.cancelAnimationFrame(i),
                    e = !1
                },
                setAnimationLoop: function(t) {
                    n = t
                },
                setContext: function(e) {
                    t = e
                }
            }
        }
        function vi(t, e) {
            const n = e.isWebGL2
              , i = new WeakMap;
            return {
                get: function(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data),
                    i.get(t)
                },
                remove: function(e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const n = i.get(e);
                    n && (t.deleteBuffer(n.buffer),
                    i.delete(e))
                },
                update: function(e, r) {
                    if (e.isGLBufferAttribute) {
                        const t = i.get(e);
                        return void ((!t || t.version < e.version) && i.set(e, {
                            buffer: e.buffer,
                            type: e.type,
                            bytesPerElement: e.elementSize,
                            version: e.version
                        }))
                    }
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const s = i.get(e);
                    void 0 === s ? i.set(e, function(e, i) {
                        const r = e.array
                          , s = e.usage
                          , a = t.createBuffer();
                        t.bindBuffer(i, a),
                        t.bufferData(i, r, s),
                        e.onUploadCallback();
                        let o = 5126;
                        return r instanceof Float32Array ? o = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? o = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : o = 5123 : r instanceof Int16Array ? o = 5122 : r instanceof Uint32Array ? o = 5125 : r instanceof Int32Array ? o = 5124 : r instanceof Int8Array ? o = 5120 : r instanceof Uint8Array && (o = 5121),
                        {
                            buffer: a,
                            type: o,
                            bytesPerElement: r.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(e, r)) : s.version < e.version && (!function(e, i, r) {
                        const s = i.array
                          , a = i.updateRange;
                        t.bindBuffer(r, e),
                        -1 === a.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)),
                        a.count = -1)
                    }(s.buffer, e, r),
                    s.version = e.version)
                }
            }
        }
        class yi extends zn {
            constructor(t=1, e=1, n=1, i=1) {
                super(),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = t / 2
                  , s = e / 2
                  , a = Math.floor(n)
                  , o = Math.floor(i)
                  , l = a + 1
                  , c = o + 1
                  , h = t / a
                  , u = e / o
                  , d = []
                  , p = []
                  , f = []
                  , m = [];
                for (let t = 0; t < c; t++) {
                    const e = t * u - s;
                    for (let n = 0; n < l; n++) {
                        const i = n * h - r;
                        p.push(i, -e, 0),
                        f.push(0, 0, 1),
                        m.push(n / a),
                        m.push(1 - t / o)
                    }
                }
                for (let t = 0; t < o; t++)
                    for (let e = 0; e < a; e++) {
                        const n = e + l * t
                          , i = e + l * (t + 1)
                          , r = e + 1 + l * (t + 1)
                          , s = e + 1 + l * t;
                        d.push(n, i, s),
                        d.push(i, r, s)
                    }
                this.setIndex(d),
                this.setAttribute("position", new Ln(p,3)),
                this.setAttribute("normal", new Ln(f,3)),
                this.setAttribute("uv", new Ln(m,2))
            }
        }
        const xi = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
            normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
            transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
            uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
        }
          , _i = {
            common: {
                diffuse: {
                    value: new _n(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new kt
                },
                uv2Transform: {
                    value: new kt
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new Bt(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new _n(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new _n(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new kt
                }
            },
            sprite: {
                diffuse: {
                    value: new _n(15658734)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new Bt(.5,.5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new kt
                }
            }
        }
          , wi = {
            basic: {
                uniforms: ri([_i.common, _i.specularmap, _i.envmap, _i.aomap, _i.lightmap, _i.fog]),
                vertexShader: xi.meshbasic_vert,
                fragmentShader: xi.meshbasic_frag
            },
            lambert: {
                uniforms: ri([_i.common, _i.specularmap, _i.envmap, _i.aomap, _i.lightmap, _i.emissivemap, _i.fog, _i.lights, {
                    emissive: {
                        value: new _n(0)
                    }
                }]),
                vertexShader: xi.meshlambert_vert,
                fragmentShader: xi.meshlambert_frag
            },
            phong: {
                uniforms: ri([_i.common, _i.specularmap, _i.envmap, _i.aomap, _i.lightmap, _i.emissivemap, _i.bumpmap, _i.normalmap, _i.displacementmap, _i.fog, _i.lights, {
                    emissive: {
                        value: new _n(0)
                    },
                    specular: {
                        value: new _n(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: xi.meshphong_vert,
                fragmentShader: xi.meshphong_frag
            },
            standard: {
                uniforms: ri([_i.common, _i.envmap, _i.aomap, _i.lightmap, _i.emissivemap, _i.bumpmap, _i.normalmap, _i.displacementmap, _i.roughnessmap, _i.metalnessmap, _i.fog, _i.lights, {
                    emissive: {
                        value: new _n(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: xi.meshphysical_vert,
                fragmentShader: xi.meshphysical_frag
            },
            toon: {
                uniforms: ri([_i.common, _i.aomap, _i.lightmap, _i.emissivemap, _i.bumpmap, _i.normalmap, _i.displacementmap, _i.gradientmap, _i.fog, _i.lights, {
                    emissive: {
                        value: new _n(0)
                    }
                }]),
                vertexShader: xi.meshtoon_vert,
                fragmentShader: xi.meshtoon_frag
            },
            matcap: {
                uniforms: ri([_i.common, _i.bumpmap, _i.normalmap, _i.displacementmap, _i.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: xi.meshmatcap_vert,
                fragmentShader: xi.meshmatcap_frag
            },
            points: {
                uniforms: ri([_i.points, _i.fog]),
                vertexShader: xi.points_vert,
                fragmentShader: xi.points_frag
            },
            dashed: {
                uniforms: ri([_i.common, _i.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: xi.linedashed_vert,
                fragmentShader: xi.linedashed_frag
            },
            depth: {
                uniforms: ri([_i.common, _i.displacementmap]),
                vertexShader: xi.depth_vert,
                fragmentShader: xi.depth_frag
            },
            normal: {
                uniforms: ri([_i.common, _i.bumpmap, _i.normalmap, _i.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: xi.normal_vert,
                fragmentShader: xi.normal_frag
            },
            sprite: {
                uniforms: ri([_i.sprite, _i.fog]),
                vertexShader: xi.sprite_vert,
                fragmentShader: xi.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new kt
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: xi.background_vert,
                fragmentShader: xi.background_frag
            },
            cube: {
                uniforms: ri([_i.envmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: xi.cube_vert,
                fragmentShader: xi.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: xi.equirect_vert,
                fragmentShader: xi.equirect_frag
            },
            distanceRGBA: {
                uniforms: ri([_i.common, _i.displacementmap, {
                    referencePosition: {
                        value: new Xt
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: xi.distanceRGBA_vert,
                fragmentShader: xi.distanceRGBA_frag
            },
            shadow: {
                uniforms: ri([_i.lights, _i.fog, {
                    color: {
                        value: new _n(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: xi.shadow_vert,
                fragmentShader: xi.shadow_frag
            }
        };
        function bi(t, e, n, i, r) {
            const s = new _n(0);
            let a, o, l = 0, c = null, h = 0, u = null;
            function d(t, e) {
                n.buffers.color.setClear(t.r, t.g, t.b, e, r)
            }
            return {
                getClearColor: function() {
                    return s
                },
                setClearColor: function(t, e=1) {
                    s.set(t),
                    l = e,
                    d(s, l)
                },
                getClearAlpha: function() {
                    return l
                },
                setClearAlpha: function(t) {
                    l = t,
                    d(s, l)
                },
                render: function(n, r, p, f) {
                    let m = !0 === r.isScene ? r.background : null;
                    m && m.isTexture && (m = e.get(m));
                    const g = t.xr
                      , v = g.getSession && g.getSession();
                    v && "additive" === v.environmentBlendMode && (m = null),
                    null === m ? d(s, l) : m && m.isColor && (d(m, 1),
                    f = !0),
                    (t.autoClear || f) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                    m && (m.isCubeTexture || 306 === m.mapping) ? (void 0 === o && (o = new ti(new ni(1,1,1),new ai({
                        name: "BackgroundCubeMaterial",
                        uniforms: ii(wi.cube.uniforms),
                        vertexShader: wi.cube.vertexShader,
                        fragmentShader: wi.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    o.geometry.deleteAttribute("normal"),
                    o.geometry.deleteAttribute("uv"),
                    o.onBeforeRender = function(t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }
                    ,
                    Object.defineProperty(o.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }),
                    i.update(o)),
                    o.material.uniforms.envMap.value = m,
                    o.material.uniforms.flipEnvMap.value = m.isCubeTexture && m._needsFlipEnvMap ? -1 : 1,
                    c === m && h === m.version && u === t.toneMapping || (o.material.needsUpdate = !0,
                    c = m,
                    h = m.version,
                    u = t.toneMapping),
                    n.unshift(o, o.geometry, o.material, 0, 0, null)) : m && m.isTexture && (void 0 === a && (a = new ti(new yi(2,2),new ai({
                        name: "BackgroundMaterial",
                        uniforms: ii(wi.background.uniforms),
                        vertexShader: wi.background.vertexShader,
                        fragmentShader: wi.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    a.geometry.deleteAttribute("normal"),
                    Object.defineProperty(a.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }),
                    i.update(a)),
                    a.material.uniforms.t2D.value = m,
                    !0 === m.matrixAutoUpdate && m.updateMatrix(),
                    a.material.uniforms.uvTransform.value.copy(m.matrix),
                    c === m && h === m.version && u === t.toneMapping || (a.material.needsUpdate = !0,
                    c = m,
                    h = m.version,
                    u = t.toneMapping),
                    n.unshift(a, a.geometry, a.material, 0, 0, null))
                }
            }
        }
        function Mi(t, e, n, i) {
            const r = t.getParameter(34921)
              , s = i.isWebGL2 ? null : e.get("OES_vertex_array_object")
              , a = i.isWebGL2 || null !== s
              , o = {}
              , l = d(null);
            let c = l;
            function h(e) {
                return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
            }
            function u(e) {
                return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
            }
            function d(t) {
                const e = []
                  , n = []
                  , i = [];
                for (let t = 0; t < r; t++)
                    e[t] = 0,
                    n[t] = 0,
                    i[t] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: n,
                    attributeDivisors: i,
                    object: t,
                    attributes: {},
                    index: null
                }
            }
            function p() {
                const t = c.newAttributes;
                for (let e = 0, n = t.length; e < n; e++)
                    t[e] = 0
            }
            function f(t) {
                m(t, 0)
            }
            function m(n, r) {
                const s = c.newAttributes
                  , a = c.enabledAttributes
                  , o = c.attributeDivisors;
                if (s[n] = 1,
                0 === a[n] && (t.enableVertexAttribArray(n),
                a[n] = 1),
                o[n] !== r) {
                    (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r),
                    o[n] = r
                }
            }
            function g() {
                const e = c.newAttributes
                  , n = c.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++)
                    n[i] !== e[i] && (t.disableVertexAttribArray(i),
                    n[i] = 0)
            }
            function v(e, n, r, s, a, o) {
                !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, s, a, o) : t.vertexAttribIPointer(e, n, r, a, o)
            }
            function y() {
                x(),
                c !== l && (c = l,
                h(c.object))
            }
            function x() {
                l.geometry = null,
                l.program = null,
                l.wireframe = !1
            }
            return {
                setup: function(r, l, u, y, x) {
                    let _ = !1;
                    if (a) {
                        const e = function(e, n, r) {
                            const a = !0 === r.wireframe;
                            let l = o[e.id];
                            void 0 === l && (l = {},
                            o[e.id] = l);
                            let c = l[n.id];
                            void 0 === c && (c = {},
                            l[n.id] = c);
                            let h = c[a];
                            void 0 === h && (h = d(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()),
                            c[a] = h);
                            return h
                        }(y, u, l);
                        c !== e && (c = e,
                        h(c.object)),
                        _ = function(t, e) {
                            const n = c.attributes
                              , i = t.attributes;
                            let r = 0;
                            for (const t in i) {
                                const e = n[t]
                                  , s = i[t];
                                if (void 0 === e)
                                    return !0;
                                if (e.attribute !== s)
                                    return !0;
                                if (e.data !== s.data)
                                    return !0;
                                r++
                            }
                            return c.attributesNum !== r || c.index !== e
                        }(y, x),
                        _ && function(t, e) {
                            const n = {}
                              , i = t.attributes;
                            let r = 0;
                            for (const t in i) {
                                const e = i[t]
                                  , s = {};
                                s.attribute = e,
                                e.data && (s.data = e.data),
                                n[t] = s,
                                r++
                            }
                            c.attributes = n,
                            c.attributesNum = r,
                            c.index = e
                        }(y, x)
                    } else {
                        const t = !0 === l.wireframe;
                        c.geometry === y.id && c.program === u.id && c.wireframe === t || (c.geometry = y.id,
                        c.program = u.id,
                        c.wireframe = t,
                        _ = !0)
                    }
                    !0 === r.isInstancedMesh && (_ = !0),
                    null !== x && n.update(x, 34963),
                    _ && (!function(r, s, a, o) {
                        if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays"))
                            return;
                        p();
                        const l = o.attributes
                          , c = a.getAttributes()
                          , h = s.defaultAttributeValues;
                        for (const e in c) {
                            const i = c[e];
                            if (i >= 0) {
                                const s = l[e];
                                if (void 0 !== s) {
                                    const e = s.normalized
                                      , r = s.itemSize
                                      , a = n.get(s);
                                    if (void 0 === a)
                                        continue;
                                    const l = a.buffer
                                      , c = a.type
                                      , h = a.bytesPerElement;
                                    if (s.isInterleavedBufferAttribute) {
                                        const n = s.data
                                          , a = n.stride
                                          , u = s.offset;
                                        n && n.isInstancedInterleavedBuffer ? (m(i, n.meshPerAttribute),
                                        void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count)) : f(i),
                                        t.bindBuffer(34962, l),
                                        v(i, r, c, e, a * h, u * h)
                                    } else
                                        s.isInstancedBufferAttribute ? (m(i, s.meshPerAttribute),
                                        void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)) : f(i),
                                        t.bindBuffer(34962, l),
                                        v(i, r, c, e, 0, 0)
                                } else if ("instanceMatrix" === e) {
                                    const e = n.get(r.instanceMatrix);
                                    if (void 0 === e)
                                        continue;
                                    const s = e.buffer
                                      , a = e.type;
                                    m(i + 0, 1),
                                    m(i + 1, 1),
                                    m(i + 2, 1),
                                    m(i + 3, 1),
                                    t.bindBuffer(34962, s),
                                    t.vertexAttribPointer(i + 0, 4, a, !1, 64, 0),
                                    t.vertexAttribPointer(i + 1, 4, a, !1, 64, 16),
                                    t.vertexAttribPointer(i + 2, 4, a, !1, 64, 32),
                                    t.vertexAttribPointer(i + 3, 4, a, !1, 64, 48)
                                } else if ("instanceColor" === e) {
                                    const e = n.get(r.instanceColor);
                                    if (void 0 === e)
                                        continue;
                                    const s = e.buffer
                                      , a = e.type;
                                    m(i, 1),
                                    t.bindBuffer(34962, s),
                                    t.vertexAttribPointer(i, 3, a, !1, 12, 0)
                                } else if (void 0 !== h) {
                                    const n = h[e];
                                    if (void 0 !== n)
                                        switch (n.length) {
                                        case 2:
                                            t.vertexAttrib2fv(i, n);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(i, n);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(i, n);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(i, n)
                                        }
                                }
                            }
                        }
                        g()
                    }(r, l, u, y),
                    null !== x && t.bindBuffer(34963, n.get(x).buffer))
                },
                reset: y,
                resetDefaultState: x,
                dispose: function() {
                    y();
                    for (const t in o) {
                        const e = o[t];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n)
                                u(n[t].object),
                                delete n[t];
                            delete e[t]
                        }
                        delete o[t]
                    }
                },
                releaseStatesOfGeometry: function(t) {
                    if (void 0 === o[t.id])
                        return;
                    const e = o[t.id];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n)
                            u(n[t].object),
                            delete n[t];
                        delete e[t]
                    }
                    delete o[t.id]
                },
                releaseStatesOfProgram: function(t) {
                    for (const e in o) {
                        const n = o[e];
                        if (void 0 === n[t.id])
                            continue;
                        const i = n[t.id];
                        for (const t in i)
                            u(i[t].object),
                            delete i[t];
                        delete n[t.id]
                    }
                },
                initAttributes: p,
                enableAttribute: f,
                disableUnusedAttributes: g
            }
        }
        function Si(t, e, n, i) {
            const r = i.isWebGL2;
            let s;
            this.setMode = function(t) {
                s = t
            }
            ,
            this.render = function(e, i) {
                t.drawArrays(s, e, i),
                n.update(i, s, 1)
            }
            ,
            this.renderInstances = function(i, a, o) {
                if (0 === o)
                    return;
                let l, c;
                if (r)
                    l = t,
                    c = "drawArraysInstanced";
                else if (l = e.get("ANGLE_instanced_arrays"),
                c = "drawArraysInstancedANGLE",
                null === l)
                    return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                l[c](s, i, a, o),
                n.update(a, s, o)
            }
        }
        function Ti(t, e, n) {
            let i;
            function r(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0)
                        return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
            }
            const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
            let a = void 0 !== n.precision ? n.precision : "highp";
            const o = r(a);
            o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."),
            a = o);
            const l = !0 === n.logarithmicDepthBuffer
              , c = t.getParameter(34930)
              , h = t.getParameter(35660)
              , u = t.getParameter(3379)
              , d = t.getParameter(34076)
              , p = t.getParameter(34921)
              , f = t.getParameter(36347)
              , m = t.getParameter(36348)
              , g = t.getParameter(36349)
              , v = h > 0
              , y = s || e.has("OES_texture_float");
            return {
                isWebGL2: s,
                getMaxAnisotropy: function() {
                    if (void 0 !== i)
                        return i;
                    if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                        const n = e.get("EXT_texture_filter_anisotropic");
                        i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else
                        i = 0;
                    return i
                },
                getMaxPrecision: r,
                precision: a,
                logarithmicDepthBuffer: l,
                maxTextures: c,
                maxVertexTextures: h,
                maxTextureSize: u,
                maxCubemapSize: d,
                maxAttributes: p,
                maxVertexUniforms: f,
                maxVaryings: m,
                maxFragmentUniforms: g,
                vertexTextures: v,
                floatFragmentTextures: y,
                floatVertexTextures: v && y,
                maxSamples: s ? t.getParameter(36183) : 0
            }
        }
        function Ei(t) {
            const e = this;
            let n = null
              , i = 0
              , r = !1
              , s = !1;
            const a = new Qe
              , o = new kt
              , l = {
                value: null,
                needsUpdate: !1
            };
            function c() {
                l.value !== n && (l.value = n,
                l.needsUpdate = i > 0),
                e.numPlanes = i,
                e.numIntersection = 0
            }
            function h(t, n, i, r) {
                const s = null !== t ? t.length : 0;
                let c = null;
                if (0 !== s) {
                    if (c = l.value,
                    !0 !== r || null === c) {
                        const e = i + 4 * s
                          , r = n.matrixWorldInverse;
                        o.getNormalMatrix(r),
                        (null === c || c.length < e) && (c = new Float32Array(e));
                        for (let e = 0, n = i; e !== s; ++e,
                        n += 4)
                            a.copy(t[e]).applyMatrix4(r, o),
                            a.normal.toArray(c, n),
                            c[n + 3] = a.constant
                    }
                    l.value = c,
                    l.needsUpdate = !0
                }
                return e.numPlanes = s,
                e.numIntersection = 0,
                c
            }
            this.uniform = l,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(t, e, s) {
                const a = 0 !== t.length || e || 0 !== i || r;
                return r = e,
                n = h(t, s, 0),
                i = t.length,
                a
            }
            ,
            this.beginShadows = function() {
                s = !0,
                h(null)
            }
            ,
            this.endShadows = function() {
                s = !1,
                c()
            }
            ,
            this.setState = function(e, a, o) {
                const u = e.clippingPlanes
                  , d = e.clipIntersection
                  , p = e.clipShadows
                  , f = t.get(e);
                if (!r || null === u || 0 === u.length || s && !p)
                    s ? h(null) : c();
                else {
                    const t = s ? 0 : i
                      , e = 4 * t;
                    let r = f.clippingState || null;
                    l.value = r,
                    r = h(u, a, e, o);
                    for (let t = 0; t !== e; ++t)
                        r[t] = n[t];
                    f.clippingState = r,
                    this.numIntersection = d ? this.numPlanes : 0,
                    this.numPlanes += t
                }
            }
        }
        function Li(t) {
            let e = new WeakMap;
            function n(t, e) {
                return 303 === e ? t.mapping = 301 : 304 === e && (t.mapping = 302),
                t
            }
            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n),
                r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture) {
                        const s = r.mapping;
                        if (303 === s || 304 === s) {
                            if (e.has(r)) {
                                return n(e.get(r).texture, r.mapping)
                            }
                            {
                                const s = r.image;
                                if (s && s.height > 0) {
                                    const a = t.getRenderTarget()
                                      , o = new ui(s.height / 2);
                                    return o.fromEquirectangularTexture(t, r),
                                    e.set(r, o),
                                    t.setRenderTarget(a),
                                    r.addEventListener("dispose", i),
                                    n(o.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        function Ai(t) {
            const e = {};
            function n(n) {
                if (void 0 !== e[n])
                    return e[n];
                let i;
                switch (n) {
                case "WEBGL_depth_texture":
                    i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = t.getExtension(n)
                }
                return e[n] = i,
                i
            }
            return {
                has: function(t) {
                    return null !== n(t)
                },
                init: function(t) {
                    t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"),
                    n("OES_texture_float"),
                    n("OES_texture_half_float"),
                    n("OES_texture_half_float_linear"),
                    n("OES_standard_derivatives"),
                    n("OES_element_index_uint"),
                    n("OES_vertex_array_object"),
                    n("ANGLE_instanced_arrays")),
                    n("OES_texture_float_linear"),
                    n("EXT_color_buffer_half_float")
                },
                get: function(t) {
                    const e = n(t);
                    return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."),
                    e
                }
            }
        }
        function Ci(t, e, n, i) {
            const r = {}
              , s = new WeakMap;
            function a(t) {
                const o = t.target;
                null !== o.index && e.remove(o.index);
                for (const t in o.attributes)
                    e.remove(o.attributes[t]);
                o.removeEventListener("dispose", a),
                delete r[o.id];
                const l = s.get(o);
                l && (e.remove(l),
                s.delete(o)),
                i.releaseStatesOfGeometry(o),
                !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
                n.memory.geometries--
            }
            function o(t) {
                const n = []
                  , i = t.index
                  , r = t.attributes.position;
                let a = 0;
                if (null !== i) {
                    const t = i.array;
                    a = i.version;
                    for (let e = 0, i = t.length; e < i; e += 3) {
                        const i = t[e + 0]
                          , r = t[e + 1]
                          , s = t[e + 2];
                        n.push(i, r, r, s, s, i)
                    }
                } else {
                    const t = r.array;
                    a = r.version;
                    for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                        const t = e + 0
                          , i = e + 1
                          , r = e + 2;
                        n.push(t, i, i, r, r, t)
                    }
                }
                const o = new (An(n) > 65535 ? En : Tn)(n,1);
                o.version = a;
                const l = s.get(t);
                l && e.remove(l),
                s.set(t, o)
            }
            return {
                get: function(t, e) {
                    return !0 === r[e.id] || (e.addEventListener("dispose", a),
                    r[e.id] = !0,
                    n.memory.geometries++),
                    e
                },
                update: function(t) {
                    const n = t.attributes;
                    for (const t in n)
                        e.update(n[t], 34962);
                    const i = t.morphAttributes;
                    for (const t in i) {
                        const n = i[t];
                        for (let t = 0, i = n.length; t < i; t++)
                            e.update(n[t], 34962)
                    }
                },
                getWireframeAttribute: function(t) {
                    const e = s.get(t);
                    if (e) {
                        const n = t.index;
                        null !== n && e.version < n.version && o(t)
                    } else
                        o(t);
                    return s.get(t)
                }
            }
        }
        function Pi(t, e, n, i) {
            const r = i.isWebGL2;
            let s, a, o;
            this.setMode = function(t) {
                s = t
            }
            ,
            this.setIndex = function(t) {
                a = t.type,
                o = t.bytesPerElement
            }
            ,
            this.render = function(e, i) {
                t.drawElements(s, i, a, e * o),
                n.update(i, s, 1)
            }
            ,
            this.renderInstances = function(i, l, c) {
                if (0 === c)
                    return;
                let h, u;
                if (r)
                    h = t,
                    u = "drawElementsInstanced";
                else if (h = e.get("ANGLE_instanced_arrays"),
                u = "drawElementsInstancedANGLE",
                null === h)
                    return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                h[u](s, l, a, i * o, c),
                n.update(l, s, c)
            }
        }
        function Ri(t) {
            const e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function() {
                    e.frame++,
                    e.calls = 0,
                    e.triangles = 0,
                    e.points = 0,
                    e.lines = 0
                },
                update: function(t, n, i) {
                    switch (e.calls++,
                    n) {
                    case 4:
                        e.triangles += i * (t / 3);
                        break;
                    case 1:
                        e.lines += i * (t / 2);
                        break;
                    case 3:
                        e.lines += i * (t - 1);
                        break;
                    case 2:
                        e.lines += i * t;
                        break;
                    case 0:
                        e.points += i * t;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                    }
                }
            }
        }
        function Ii(t, e) {
            return t[0] - e[0]
        }
        function Di(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }
        function Ni(t) {
            const e = {}
              , n = new Float32Array(8)
              , i = [];
            for (let t = 0; t < 8; t++)
                i[t] = [t, 0];
            return {
                update: function(r, s, a, o) {
                    const l = r.morphTargetInfluences
                      , c = void 0 === l ? 0 : l.length;
                    let h = e[s.id];
                    if (void 0 === h) {
                        h = [];
                        for (let t = 0; t < c; t++)
                            h[t] = [t, 0];
                        e[s.id] = h
                    }
                    for (let t = 0; t < c; t++) {
                        const e = h[t];
                        e[0] = t,
                        e[1] = l[t]
                    }
                    h.sort(Di);
                    for (let t = 0; t < 8; t++)
                        t < c && h[t][1] ? (i[t][0] = h[t][0],
                        i[t][1] = h[t][1]) : (i[t][0] = Number.MAX_SAFE_INTEGER,
                        i[t][1] = 0);
                    i.sort(Ii);
                    const u = a.morphTargets && s.morphAttributes.position
                      , d = a.morphNormals && s.morphAttributes.normal;
                    let p = 0;
                    for (let t = 0; t < 8; t++) {
                        const e = i[t]
                          , r = e[0]
                          , a = e[1];
                        r !== Number.MAX_SAFE_INTEGER && a ? (u && s.getAttribute("morphTarget" + t) !== u[r] && s.setAttribute("morphTarget" + t, u[r]),
                        d && s.getAttribute("morphNormal" + t) !== d[r] && s.setAttribute("morphNormal" + t, d[r]),
                        n[t] = a,
                        p += a) : (u && !0 === s.hasAttribute("morphTarget" + t) && s.deleteAttribute("morphTarget" + t),
                        d && !0 === s.hasAttribute("morphNormal" + t) && s.deleteAttribute("morphNormal" + t),
                        n[t] = 0)
                    }
                    const f = s.morphTargetsRelative ? 1 : 1 - p;
                    o.getUniforms().setValue(t, "morphTargetBaseInfluence", f),
                    o.getUniforms().setValue(t, "morphTargetInfluences", n)
                }
            }
        }
        function Oi(t, e, n, i) {
            let r = new WeakMap;
            function s(t) {
                const e = t.target;
                e.removeEventListener("dispose", s),
                n.remove(e.instanceMatrix),
                null !== e.instanceColor && n.remove(e.instanceColor)
            }
            return {
                update: function(t) {
                    const a = i.render.frame
                      , o = t.geometry
                      , l = e.get(t, o);
                    return r.get(l) !== a && (e.update(l),
                    r.set(l, a)),
                    t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s),
                    n.update(t.instanceMatrix, 34962),
                    null !== t.instanceColor && n.update(t.instanceColor, 34962)),
                    l
                },
                dispose: function() {
                    r = new WeakMap
                }
            }
        }
        wi.physical = {
            uniforms: ri([wi.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new Bt(1,1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheen: {
                    value: new _n(0)
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                }
            }]),
            vertexShader: xi.meshphysical_vert,
            fragmentShader: xi.meshphysical_frag
        };
        class zi extends Gt {
            constructor(t=null, e=1, n=1, i=1) {
                super(null),
                this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                },
                this.magFilter = 1003,
                this.minFilter = 1003,
                this.wrapR = 1001,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1,
                this.needsUpdate = !0
            }
        }
        zi.prototype.isDataTexture2DArray = !0;
        class Bi extends Gt {
            constructor(t=null, e=1, n=1, i=1) {
                super(null),
                this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                },
                this.magFilter = 1003,
                this.minFilter = 1003,
                this.wrapR = 1001,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1,
                this.needsUpdate = !0
            }
        }
        Bi.prototype.isDataTexture3D = !0;
        const ki = new Gt
          , Fi = new zi
          , Hi = new Bi
          , Ui = new hi
          , Gi = []
          , Vi = []
          , Wi = new Float32Array(16)
          , ji = new Float32Array(9)
          , qi = new Float32Array(4);
        function Xi(t, e, n) {
            const i = t[0];
            if (i <= 0 || i > 0)
                return t;
            const r = e * n;
            let s = Gi[r];
            if (void 0 === s && (s = new Float32Array(r),
            Gi[r] = s),
            0 !== e) {
                i.toArray(s, 0);
                for (let i = 1, r = 0; i !== e; ++i)
                    r += n,
                    t[i].toArray(s, r)
            }
            return s
        }
        function Yi(t, e) {
            if (t.length !== e.length)
                return !1;
            for (let n = 0, i = t.length; n < i; n++)
                if (t[n] !== e[n])
                    return !1;
            return !0
        }
        function Zi(t, e) {
            for (let n = 0, i = e.length; n < i; n++)
                t[n] = e[n]
        }
        function Ji(t, e) {
            let n = Vi[e];
            void 0 === n && (n = new Int32Array(e),
            Vi[e] = n);
            for (let i = 0; i !== e; ++i)
                n[i] = t.allocateTextureUnit();
            return n
        }
        function $i(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e),
            n[0] = e)
        }
        function Ki(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y),
                n[0] = e.x,
                n[1] = e.y);
            else {
                if (Yi(n, e))
                    return;
                t.uniform2fv(this.addr, e),
                Zi(n, e)
            }
        }
        function Qi(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z);
            else if (void 0 !== e.r)
                n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b),
                n[0] = e.r,
                n[1] = e.g,
                n[2] = e.b);
            else {
                if (Yi(n, e))
                    return;
                t.uniform3fv(this.addr, e),
                Zi(n, e)
            }
        }
        function tr(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z,
                n[3] = e.w);
            else {
                if (Yi(n, e))
                    return;
                t.uniform4fv(this.addr, e),
                Zi(n, e)
            }
        }
        function er(t, e) {
            const n = this.cache
              , i = e.elements;
            if (void 0 === i) {
                if (Yi(n, e))
                    return;
                t.uniformMatrix2fv(this.addr, !1, e),
                Zi(n, e)
            } else {
                if (Yi(n, i))
                    return;
                qi.set(i),
                t.uniformMatrix2fv(this.addr, !1, qi),
                Zi(n, i)
            }
        }
        function nr(t, e) {
            const n = this.cache
              , i = e.elements;
            if (void 0 === i) {
                if (Yi(n, e))
                    return;
                t.uniformMatrix3fv(this.addr, !1, e),
                Zi(n, e)
            } else {
                if (Yi(n, i))
                    return;
                ji.set(i),
                t.uniformMatrix3fv(this.addr, !1, ji),
                Zi(n, i)
            }
        }
        function ir(t, e) {
            const n = this.cache
              , i = e.elements;
            if (void 0 === i) {
                if (Yi(n, e))
                    return;
                t.uniformMatrix4fv(this.addr, !1, e),
                Zi(n, e)
            } else {
                if (Yi(n, i))
                    return;
                Wi.set(i),
                t.uniformMatrix4fv(this.addr, !1, Wi),
                Zi(n, i)
            }
        }
        function rr(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e),
            n[0] = e)
        }
        function sr(t, e) {
            const n = this.cache;
            Yi(n, e) || (t.uniform2iv(this.addr, e),
            Zi(n, e))
        }
        function ar(t, e) {
            const n = this.cache;
            Yi(n, e) || (t.uniform3iv(this.addr, e),
            Zi(n, e))
        }
        function or(t, e) {
            const n = this.cache;
            Yi(n, e) || (t.uniform4iv(this.addr, e),
            Zi(n, e))
        }
        function lr(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e),
            n[0] = e)
        }
        function cr(t, e) {
            const n = this.cache;
            Yi(n, e) || (t.uniform2uiv(this.addr, e),
            Zi(n, e))
        }
        function hr(t, e) {
            const n = this.cache;
            Yi(n, e) || (t.uniform3uiv(this.addr, e),
            Zi(n, e))
        }
        function ur(t, e) {
            const n = this.cache;
            Yi(n, e) || (t.uniform4uiv(this.addr, e),
            Zi(n, e))
        }
        function dr(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.safeSetTexture2D(e || ki, r)
        }
        function pr(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture3D(e || Hi, r)
        }
        function fr(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.safeSetTextureCube(e || Ui, r)
        }
        function mr(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture2DArray(e || Fi, r)
        }
        function gr(t, e) {
            t.uniform1fv(this.addr, e)
        }
        function vr(t, e) {
            const n = Xi(e, this.size, 2);
            t.uniform2fv(this.addr, n)
        }
        function yr(t, e) {
            const n = Xi(e, this.size, 3);
            t.uniform3fv(this.addr, n)
        }
        function xr(t, e) {
            const n = Xi(e, this.size, 4);
            t.uniform4fv(this.addr, n)
        }
        function _r(t, e) {
            const n = Xi(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, n)
        }
        function wr(t, e) {
            const n = Xi(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, n)
        }
        function br(t, e) {
            const n = Xi(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, n)
        }
        function Mr(t, e) {
            t.uniform1iv(this.addr, e)
        }
        function Sr(t, e) {
            t.uniform2iv(this.addr, e)
        }
        function Tr(t, e) {
            t.uniform3iv(this.addr, e)
        }
        function Er(t, e) {
            t.uniform4iv(this.addr, e)
        }
        function Lr(t, e) {
            t.uniform1uiv(this.addr, e)
        }
        function Ar(t, e) {
            t.uniform2uiv(this.addr, e)
        }
        function Cr(t, e) {
            t.uniform3uiv(this.addr, e)
        }
        function Pr(t, e) {
            t.uniform4uiv(this.addr, e)
        }
        function Rr(t, e, n) {
            const i = e.length
              , r = Ji(n, i);
            t.uniform1iv(this.addr, r);
            for (let t = 0; t !== i; ++t)
                n.safeSetTexture2D(e[t] || ki, r[t])
        }
        function Ir(t, e, n) {
            const i = e.length
              , r = Ji(n, i);
            t.uniform1iv(this.addr, r);
            for (let t = 0; t !== i; ++t)
                n.safeSetTextureCube(e[t] || Ui, r[t])
        }
        function Dr(t, e, n) {
            this.id = t,
            this.addr = n,
            this.cache = [],
            this.setValue = function(t) {
                switch (t) {
                case 5126:
                    return $i;
                case 35664:
                    return Ki;
                case 35665:
                    return Qi;
                case 35666:
                    return tr;
                case 35674:
                    return er;
                case 35675:
                    return nr;
                case 35676:
                    return ir;
                case 5124:
                case 35670:
                    return rr;
                case 35667:
                case 35671:
                    return sr;
                case 35668:
                case 35672:
                    return ar;
                case 35669:
                case 35673:
                    return or;
                case 5125:
                    return lr;
                case 36294:
                    return cr;
                case 36295:
                    return hr;
                case 36296:
                    return ur;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return dr;
                case 35679:
                case 36299:
                case 36307:
                    return pr;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return fr;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return mr
                }
            }(e.type)
        }
        function Nr(t, e, n) {
            this.id = t,
            this.addr = n,
            this.cache = [],
            this.size = e.size,
            this.setValue = function(t) {
                switch (t) {
                case 5126:
                    return gr;
                case 35664:
                    return vr;
                case 35665:
                    return yr;
                case 35666:
                    return xr;
                case 35674:
                    return _r;
                case 35675:
                    return wr;
                case 35676:
                    return br;
                case 5124:
                case 35670:
                    return Mr;
                case 35667:
                case 35671:
                    return Sr;
                case 35668:
                case 35672:
                    return Tr;
                case 35669:
                case 35673:
                    return Er;
                case 5125:
                    return Lr;
                case 36294:
                    return Ar;
                case 36295:
                    return Cr;
                case 36296:
                    return Pr;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return Rr;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return Ir
                }
            }(e.type)
        }
        function Or(t) {
            this.id = t,
            this.seq = [],
            this.map = {}
        }
        Nr.prototype.updateCache = function(t) {
            const e = this.cache;
            t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)),
            Zi(e, t)
        }
        ,
        Or.prototype.setValue = function(t, e, n) {
            const i = this.seq;
            for (let r = 0, s = i.length; r !== s; ++r) {
                const s = i[r];
                s.setValue(t, e[s.id], n)
            }
        }
        ;
        const zr = /(\w+)(\])?(\[|\.)?/g;
        function Br(t, e) {
            t.seq.push(e),
            t.map[e.id] = e
        }
        function kr(t, e, n) {
            const i = t.name
              , r = i.length;
            for (zr.lastIndex = 0; ; ) {
                const s = zr.exec(i)
                  , a = zr.lastIndex;
                let o = s[1];
                const l = "]" === s[2]
                  , c = s[3];
                if (l && (o |= 0),
                void 0 === c || "[" === c && a + 2 === r) {
                    Br(n, void 0 === c ? new Dr(o,t,e) : new Nr(o,t,e));
                    break
                }
                {
                    let t = n.map[o];
                    void 0 === t && (t = new Or(o),
                    Br(n, t)),
                    n = t
                }
            }
        }
        function Fr(t, e) {
            this.seq = [],
            this.map = {};
            const n = t.getProgramParameter(e, 35718);
            for (let i = 0; i < n; ++i) {
                const n = t.getActiveUniform(e, i);
                kr(n, t.getUniformLocation(e, n.name), this)
            }
        }
        function Hr(t, e, n) {
            const i = t.createShader(e);
            return t.shaderSource(i, n),
            t.compileShader(i),
            i
        }
        Fr.prototype.setValue = function(t, e, n, i) {
            const r = this.map[e];
            void 0 !== r && r.setValue(t, n, i)
        }
        ,
        Fr.prototype.setOptional = function(t, e, n) {
            const i = e[n];
            void 0 !== i && this.setValue(t, n, i)
        }
        ,
        Fr.upload = function(t, e, n, i) {
            for (let r = 0, s = e.length; r !== s; ++r) {
                const s = e[r]
                  , a = n[s.id];
                !1 !== a.needsUpdate && s.setValue(t, a.value, i)
            }
        }
        ,
        Fr.seqWithValue = function(t, e) {
            const n = [];
            for (let i = 0, r = t.length; i !== r; ++i) {
                const r = t[i];
                r.id in e && n.push(r)
            }
            return n
        }
        ;
        let Ur = 0;
        function Gr(t) {
            switch (t) {
            case 3e3:
                return ["Linear", "( value )"];
            case 3001:
                return ["sRGB", "( value )"];
            case 3002:
                return ["RGBE", "( value )"];
            case 3004:
                return ["RGBM", "( value, 7.0 )"];
            case 3005:
                return ["RGBM", "( value, 16.0 )"];
            case 3006:
                return ["RGBD", "( value, 256.0 )"];
            case 3007:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            case 3003:
                return ["LogLuv", "( value )"];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
                ["Linear", "( value )"]
            }
        }
        function Vr(t, e, n) {
            const i = t.getShaderParameter(e, 35713)
              , r = t.getShaderInfoLog(e).trim();
            if (i && "" === r)
                return "";
            return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function(t) {
                const e = t.split("\n");
                for (let t = 0; t < e.length; t++)
                    e[t] = t + 1 + ": " + e[t];
                return e.join("\n")
            }(t.getShaderSource(e))
        }
        function Wr(t, e) {
            const n = Gr(e);
            return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
        }
        function jr(t, e) {
            const n = Gr(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        }
        function qr(t, e) {
            let n;
            switch (e) {
            case 1:
                n = "Linear";
                break;
            case 2:
                n = "Reinhard";
                break;
            case 3:
                n = "OptimizedCineon";
                break;
            case 4:
                n = "ACESFilmic";
                break;
            case 5:
                n = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
                n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }
        function Xr(t) {
            return "" !== t
        }
        function Yr(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }
        function Zr(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const Jr = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function $r(t) {
            return t.replace(Jr, Kr)
        }
        function Kr(t, e) {
            const n = xi[e];
            if (void 0 === n)
                throw new Error("Can not resolve #include <" + e + ">");
            return $r(n)
        }
        const Qr = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
          , ts = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function es(t) {
            return t.replace(ts, is).replace(Qr, ns)
        }
        function ns(t, e, n, i) {
            return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
            is(t, e, n, i)
        }
        function is(t, e, n, i) {
            let r = "";
            for (let t = parseInt(e); t < parseInt(n); t++)
                r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
            return r
        }
        function rs(t) {
            let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
            e
        }
        function ss(t, e, n, i) {
            const r = t.getContext()
              , s = n.defines;
            let a = n.vertexShader
              , o = n.fragmentShader;
            const l = function(t) {
                let e = "SHADOWMAP_TYPE_BASIC";
                return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"),
                e
            }(n)
              , c = function(t) {
                let e = "ENVMAP_TYPE_CUBE";
                if (t.envMap)
                    switch (t.envMapMode) {
                    case 301:
                    case 302:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                    case 306:
                    case 307:
                        e = "ENVMAP_TYPE_CUBE_UV"
                    }
                return e
            }(n)
              , h = function(t) {
                let e = "ENVMAP_MODE_REFLECTION";
                if (t.envMap)
                    switch (t.envMapMode) {
                    case 302:
                    case 307:
                        e = "ENVMAP_MODE_REFRACTION"
                    }
                return e
            }(n)
              , u = function(t) {
                let e = "ENVMAP_BLENDING_NONE";
                if (t.envMap)
                    switch (t.combine) {
                    case 0:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        e = "ENVMAP_BLENDING_ADD"
                    }
                return e
            }(n)
              , d = t.gammaFactor > 0 ? t.gammaFactor : 1
              , p = n.isWebGL2 ? "" : function(t) {
                return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Xr).join("\n")
            }(n)
              , f = function(t) {
                const e = [];
                for (const n in t) {
                    const i = t[n];
                    !1 !== i && e.push("#define " + n + " " + i)
                }
                return e.join("\n")
            }(s)
              , m = r.createProgram();
            let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (g = [f].filter(Xr).join("\n"),
            g.length > 0 && (g += "\n"),
            v = [p, f].filter(Xr).join("\n"),
            v.length > 0 && (v += "\n")) : (g = [rs(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Xr).join("\n"),
            v = [p, rs(n), "#define SHADER_NAME " + n.shaderName, f, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? xi.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? qr("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", xi.encodings_pars_fragment, n.map ? Wr("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Wr("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Wr("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Wr("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? Wr("lightMapTexelToLinear", n.lightMapEncoding) : "", jr("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Xr).join("\n")),
            a = $r(a),
            a = Yr(a, n),
            a = Zr(a, n),
            o = $r(o),
            o = Yr(o, n),
            o = Zr(o, n),
            a = es(a),
            o = es(o),
            n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n",
            g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g,
            v = ["#define varying in", "300 es" === n.glslVersion ? "" : "out highp vec4 pc_fragColor;", "300 es" === n.glslVersion ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
            const x = y + v + o
              , _ = Hr(r, 35633, y + g + a)
              , w = Hr(r, 35632, x);
            if (r.attachShader(m, _),
            r.attachShader(m, w),
            void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
            r.linkProgram(m),
            t.debug.checkShaderErrors) {
                const t = r.getProgramInfoLog(m).trim()
                  , e = r.getShaderInfoLog(_).trim()
                  , n = r.getShaderInfoLog(w).trim();
                let i = !0
                  , s = !0;
                if (!1 === r.getProgramParameter(m, 35714)) {
                    i = !1;
                    const e = Vr(r, _, "vertex")
                      , n = Vr(r, w, "fragment");
                    console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(m, 35715), "gl.getProgramInfoLog", t, e, n)
                } else
                    "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (s = !1);
                s && (this.diagnostics = {
                    runnable: i,
                    programLog: t,
                    vertexShader: {
                        log: e,
                        prefix: g
                    },
                    fragmentShader: {
                        log: n,
                        prefix: v
                    }
                })
            }
            let b, M;
            return r.deleteShader(_),
            r.deleteShader(w),
            this.getUniforms = function() {
                return void 0 === b && (b = new Fr(r,m)),
                b
            }
            ,
            this.getAttributes = function() {
                return void 0 === M && (M = function(t, e) {
                    const n = {}
                      , i = t.getProgramParameter(e, 35721);
                    for (let r = 0; r < i; r++) {
                        const i = t.getActiveAttrib(e, r).name;
                        n[i] = t.getAttribLocation(e, i)
                    }
                    return n
                }(r, m)),
                M
            }
            ,
            this.destroy = function() {
                i.releaseStatesOfProgram(this),
                r.deleteProgram(m),
                this.program = void 0
            }
            ,
            this.name = n.shaderName,
            this.id = Ur++,
            this.cacheKey = e,
            this.usedTimes = 1,
            this.program = m,
            this.vertexShader = _,
            this.fragmentShader = w,
            this
        }
        function as(t, e, n, i, r, s) {
            const a = []
              , o = i.isWebGL2
              , l = i.logarithmicDepthBuffer
              , c = i.floatVertexTextures
              , h = i.maxVertexUniforms
              , u = i.vertexTextures;
            let d = i.precision;
            const p = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            }
              , f = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];
            function m(t) {
                let e;
                return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
                e = t.texture.encoding) : e = 3e3,
                e
            }
            return {
                getParameters: function(r, a, f, g, v) {
                    const y = g.fog
                      , x = r.isMeshStandardMaterial ? g.environment : null
                      , _ = e.get(r.envMap || x)
                      , w = p[r.type]
                      , b = v.isSkinnedMesh ? function(t) {
                        const e = t.skeleton.bones;
                        if (c)
                            return 1024;
                        {
                            const t = h
                              , n = Math.floor((t - 20) / 4)
                              , i = Math.min(n, e.length);
                            return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."),
                            0) : i
                        }
                    }(v) : 0;
                    let M, S;
                    if (null !== r.precision && (d = i.getMaxPrecision(r.precision),
                    d !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", d, "instead.")),
                    w) {
                        const t = wi[w];
                        M = t.vertexShader,
                        S = t.fragmentShader
                    } else
                        M = r.vertexShader,
                        S = r.fragmentShader;
                    const T = t.getRenderTarget();
                    return {
                        isWebGL2: o,
                        shaderID: w,
                        shaderName: r.type,
                        vertexShader: M,
                        fragmentShader: S,
                        defines: r.defines,
                        isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                        glslVersion: r.glslVersion,
                        precision: d,
                        instancing: !0 === v.isInstancedMesh,
                        instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
                        supportsVertexTextures: u,
                        outputEncoding: null !== T ? m(T.texture) : t.outputEncoding,
                        map: !!r.map,
                        mapEncoding: m(r.map),
                        matcap: !!r.matcap,
                        matcapEncoding: m(r.matcap),
                        envMap: !!_,
                        envMapMode: _ && _.mapping,
                        envMapEncoding: m(_),
                        envMapCubeUV: !!_ && (306 === _.mapping || 307 === _.mapping),
                        lightMap: !!r.lightMap,
                        lightMapEncoding: m(r.lightMap),
                        aoMap: !!r.aoMap,
                        emissiveMap: !!r.emissiveMap,
                        emissiveMapEncoding: m(r.emissiveMap),
                        bumpMap: !!r.bumpMap,
                        normalMap: !!r.normalMap,
                        objectSpaceNormalMap: 1 === r.normalMapType,
                        tangentSpaceNormalMap: 0 === r.normalMapType,
                        clearcoatMap: !!r.clearcoatMap,
                        clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
                        clearcoatNormalMap: !!r.clearcoatNormalMap,
                        displacementMap: !!r.displacementMap,
                        roughnessMap: !!r.roughnessMap,
                        metalnessMap: !!r.metalnessMap,
                        specularMap: !!r.specularMap,
                        alphaMap: !!r.alphaMap,
                        gradientMap: !!r.gradientMap,
                        sheen: !!r.sheen,
                        transmissionMap: !!r.transmissionMap,
                        combine: r.combine,
                        vertexTangents: r.normalMap && r.vertexTangents,
                        vertexColors: r.vertexColors,
                        vertexAlphas: !0 === r.vertexColors && v.geometry && v.geometry.attributes.color && 4 === v.geometry.attributes.color.itemSize,
                        vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmissionMap),
                        uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmissionMap || !r.displacementMap),
                        fog: !!y,
                        useFog: r.fog,
                        fogExp2: y && y.isFogExp2,
                        flatShading: !!r.flatShading,
                        sizeAttenuation: r.sizeAttenuation,
                        logarithmicDepthBuffer: l,
                        skinning: r.skinning && b > 0,
                        maxBones: b,
                        useVertexTexture: c,
                        morphTargets: r.morphTargets,
                        morphNormals: r.morphNormals,
                        numDirLights: a.directional.length,
                        numPointLights: a.point.length,
                        numSpotLights: a.spot.length,
                        numRectAreaLights: a.rectArea.length,
                        numHemiLights: a.hemi.length,
                        numDirLightShadows: a.directionalShadowMap.length,
                        numPointLightShadows: a.pointShadowMap.length,
                        numSpotLightShadows: a.spotShadowMap.length,
                        numClippingPlanes: s.numPlanes,
                        numClipIntersection: s.numIntersection,
                        dithering: r.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && f.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: r.toneMapped ? t.toneMapping : 0,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: r.premultipliedAlpha,
                        alphaTest: r.alphaTest,
                        doubleSided: 2 === r.side,
                        flipSided: 1 === r.side,
                        depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                        index0AttributeName: r.index0AttributeName,
                        extensionDerivatives: r.extensions && r.extensions.derivatives,
                        extensionFragDepth: r.extensions && r.extensions.fragDepth,
                        extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                        extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: o || n.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: o || n.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: o || n.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: r.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(e) {
                    const n = [];
                    if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader),
                    n.push(e.vertexShader)),
                    void 0 !== e.defines)
                        for (const t in e.defines)
                            n.push(t),
                            n.push(e.defines[t]);
                    if (!1 === e.isRawShaderMaterial) {
                        for (let t = 0; t < f.length; t++)
                            n.push(e[f[t]]);
                        n.push(t.outputEncoding),
                        n.push(t.gammaFactor)
                    }
                    return n.push(e.customProgramCacheKey),
                    n.join()
                },
                getUniforms: function(t) {
                    const e = p[t.type];
                    let n;
                    if (e) {
                        const t = wi[e];
                        n = si.clone(t.uniforms)
                    } else
                        n = t.uniforms;
                    return n
                },
                acquireProgram: function(e, n) {
                    let i;
                    for (let t = 0, e = a.length; t < e; t++) {
                        const e = a[t];
                        if (e.cacheKey === n) {
                            i = e,
                            ++i.usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new ss(t,n,e,r),
                    a.push(i)),
                    i
                },
                releaseProgram: function(t) {
                    if (0 == --t.usedTimes) {
                        const e = a.indexOf(t);
                        a[e] = a[a.length - 1],
                        a.pop(),
                        t.destroy()
                    }
                },
                programs: a
            }
        }
        function os() {
            let t = new WeakMap;
            return {
                get: function(e) {
                    let n = t.get(e);
                    return void 0 === n && (n = {},
                    t.set(e, n)),
                    n
                },
                remove: function(e) {
                    t.delete(e)
                },
                update: function(e, n, i) {
                    t.get(e)[n] = i
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        function ls(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }
        function cs(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }
        function hs(t) {
            const e = [];
            let n = 0;
            const i = []
              , r = []
              , s = {
                id: -1
            };
            function a(i, r, a, o, l, c) {
                let h = e[n];
                const u = t.get(a);
                return void 0 === h ? (h = {
                    id: i.id,
                    object: i,
                    geometry: r,
                    material: a,
                    program: u.program || s,
                    groupOrder: o,
                    renderOrder: i.renderOrder,
                    z: l,
                    group: c
                },
                e[n] = h) : (h.id = i.id,
                h.object = i,
                h.geometry = r,
                h.material = a,
                h.program = u.program || s,
                h.groupOrder = o,
                h.renderOrder = i.renderOrder,
                h.z = l,
                h.group = c),
                n++,
                h
            }
            return {
                opaque: i,
                transparent: r,
                init: function() {
                    n = 0,
                    i.length = 0,
                    r.length = 0
                },
                push: function(t, e, n, s, o, l) {
                    const c = a(t, e, n, s, o, l);
                    (!0 === n.transparent ? r : i).push(c)
                },
                unshift: function(t, e, n, s, o, l) {
                    const c = a(t, e, n, s, o, l);
                    (!0 === n.transparent ? r : i).unshift(c)
                },
                finish: function() {
                    for (let t = n, i = e.length; t < i; t++) {
                        const n = e[t];
                        if (null === n.id)
                            break;
                        n.id = null,
                        n.object = null,
                        n.geometry = null,
                        n.material = null,
                        n.program = null,
                        n.group = null
                    }
                },
                sort: function(t, e) {
                    i.length > 1 && i.sort(t || ls),
                    r.length > 1 && r.sort(e || cs)
                }
            }
        }
        function us(t) {
            let e = new WeakMap;
            return {
                get: function(n, i) {
                    let r;
                    return !1 === e.has(n) ? (r = new hs(t),
                    e.set(n, [r])) : i >= e.get(n).length ? (r = new hs(t),
                    e.get(n).push(r)) : r = e.get(n)[i],
                    r
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        function ds() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id])
                        return t[e.id];
                    let n;
                    switch (e.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new Xt,
                            color: new _n
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new Xt,
                            direction: new Xt,
                            color: new _n,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new Xt,
                            color: new _n,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new Xt,
                            skyColor: new _n,
                            groundColor: new _n
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new _n,
                            position: new Xt,
                            halfWidth: new Xt,
                            halfHeight: new Xt
                        }
                    }
                    return t[e.id] = n,
                    n
                }
            }
        }
        let ps = 0;
        function fs(t, e) {
            return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
        }
        function ms(t, e) {
            const n = new ds
              , i = function() {
                const t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id])
                            return t[e.id];
                        let n;
                        switch (e.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Bt
                            };
                            break;
                        case "PointLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Bt,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                        }
                        return t[e.id] = n,
                        n
                    }
                }
            }()
              , r = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadow: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            };
            for (let t = 0; t < 9; t++)
                r.probe.push(new Xt);
            const s = new Xt
              , a = new Se
              , o = new Se;
            return {
                setup: function(s) {
                    let a = 0
                      , o = 0
                      , l = 0;
                    for (let t = 0; t < 9; t++)
                        r.probe[t].set(0, 0, 0);
                    let c = 0
                      , h = 0
                      , u = 0
                      , d = 0
                      , p = 0
                      , f = 0
                      , m = 0
                      , g = 0;
                    s.sort(fs);
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = s[t]
                          , v = e.color
                          , y = e.intensity
                          , x = e.distance
                          , _ = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                        if (e.isAmbientLight)
                            a += v.r * y,
                            o += v.g * y,
                            l += v.b * y;
                        else if (e.isLightProbe)
                            for (let t = 0; t < 9; t++)
                                r.probe[t].addScaledVector(e.sh.coefficients[t], y);
                        else if (e.isDirectionalLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity),
                            e.castShadow) {
                                const t = e.shadow
                                  , n = i.get(e);
                                n.shadowBias = t.bias,
                                n.shadowNormalBias = t.normalBias,
                                n.shadowRadius = t.radius,
                                n.shadowMapSize = t.mapSize,
                                r.directionalShadow[c] = n,
                                r.directionalShadowMap[c] = _,
                                r.directionalShadowMatrix[c] = e.shadow.matrix,
                                f++
                            }
                            r.directional[c] = t,
                            c++
                        } else if (e.isSpotLight) {
                            const t = n.get(e);
                            if (t.position.setFromMatrixPosition(e.matrixWorld),
                            t.color.copy(v).multiplyScalar(y),
                            t.distance = x,
                            t.coneCos = Math.cos(e.angle),
                            t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)),
                            t.decay = e.decay,
                            e.castShadow) {
                                const t = e.shadow
                                  , n = i.get(e);
                                n.shadowBias = t.bias,
                                n.shadowNormalBias = t.normalBias,
                                n.shadowRadius = t.radius,
                                n.shadowMapSize = t.mapSize,
                                r.spotShadow[u] = n,
                                r.spotShadowMap[u] = _,
                                r.spotShadowMatrix[u] = e.shadow.matrix,
                                g++
                            }
                            r.spot[u] = t,
                            u++
                        } else if (e.isRectAreaLight) {
                            const t = n.get(e);
                            t.color.copy(v).multiplyScalar(y),
                            t.halfWidth.set(.5 * e.width, 0, 0),
                            t.halfHeight.set(0, .5 * e.height, 0),
                            r.rectArea[d] = t,
                            d++
                        } else if (e.isPointLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity),
                            t.distance = e.distance,
                            t.decay = e.decay,
                            e.castShadow) {
                                const t = e.shadow
                                  , n = i.get(e);
                                n.shadowBias = t.bias,
                                n.shadowNormalBias = t.normalBias,
                                n.shadowRadius = t.radius,
                                n.shadowMapSize = t.mapSize,
                                n.shadowCameraNear = t.camera.near,
                                n.shadowCameraFar = t.camera.far,
                                r.pointShadow[h] = n,
                                r.pointShadowMap[h] = _,
                                r.pointShadowMatrix[h] = e.shadow.matrix,
                                m++
                            }
                            r.point[h] = t,
                            h++
                        } else if (e.isHemisphereLight) {
                            const t = n.get(e);
                            t.skyColor.copy(e.color).multiplyScalar(y),
                            t.groundColor.copy(e.groundColor).multiplyScalar(y),
                            r.hemi[p] = t,
                            p++
                        }
                    }
                    d > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = _i.LTC_FLOAT_1,
                    r.rectAreaLTC2 = _i.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = _i.LTC_HALF_1,
                    r.rectAreaLTC2 = _i.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                    r.ambient[0] = a,
                    r.ambient[1] = o,
                    r.ambient[2] = l;
                    const v = r.hash;
                    v.directionalLength === c && v.pointLength === h && v.spotLength === u && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === f && v.numPointShadows === m && v.numSpotShadows === g || (r.directional.length = c,
                    r.spot.length = u,
                    r.rectArea.length = d,
                    r.point.length = h,
                    r.hemi.length = p,
                    r.directionalShadow.length = f,
                    r.directionalShadowMap.length = f,
                    r.pointShadow.length = m,
                    r.pointShadowMap.length = m,
                    r.spotShadow.length = g,
                    r.spotShadowMap.length = g,
                    r.directionalShadowMatrix.length = f,
                    r.pointShadowMatrix.length = m,
                    r.spotShadowMatrix.length = g,
                    v.directionalLength = c,
                    v.pointLength = h,
                    v.spotLength = u,
                    v.rectAreaLength = d,
                    v.hemiLength = p,
                    v.numDirectionalShadows = f,
                    v.numPointShadows = m,
                    v.numSpotShadows = g,
                    r.version = ps++)
                },
                setupView: function(t, e) {
                    let n = 0
                      , i = 0
                      , l = 0
                      , c = 0
                      , h = 0;
                    const u = e.matrixWorldInverse;
                    for (let e = 0, d = t.length; e < d; e++) {
                        const d = t[e];
                        if (d.isDirectionalLight) {
                            const t = r.directional[n];
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            s.setFromMatrixPosition(d.target.matrixWorld),
                            t.direction.sub(s),
                            t.direction.transformDirection(u),
                            n++
                        } else if (d.isSpotLight) {
                            const t = r.spot[l];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(u),
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            s.setFromMatrixPosition(d.target.matrixWorld),
                            t.direction.sub(s),
                            t.direction.transformDirection(u),
                            l++
                        } else if (d.isRectAreaLight) {
                            const t = r.rectArea[c];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(u),
                            o.identity(),
                            a.copy(d.matrixWorld),
                            a.premultiply(u),
                            o.extractRotation(a),
                            t.halfWidth.set(.5 * d.width, 0, 0),
                            t.halfHeight.set(0, .5 * d.height, 0),
                            t.halfWidth.applyMatrix4(o),
                            t.halfHeight.applyMatrix4(o),
                            c++
                        } else if (d.isPointLight) {
                            const t = r.point[i];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(u),
                            i++
                        } else if (d.isHemisphereLight) {
                            const t = r.hemi[h];
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            t.direction.transformDirection(u),
                            t.direction.normalize(),
                            h++
                        }
                    }
                },
                state: r
            }
        }
        function gs(t, e) {
            const n = new ms(t,e)
              , i = []
              , r = [];
            return {
                init: function() {
                    i.length = 0,
                    r.length = 0
                },
                state: {
                    lightsArray: i,
                    shadowsArray: r,
                    lights: n
                },
                setupLights: function() {
                    n.setup(i)
                },
                setupLightsView: function(t) {
                    n.setupView(i, t)
                },
                pushLight: function(t) {
                    i.push(t)
                },
                pushShadow: function(t) {
                    r.push(t)
                }
            }
        }
        function vs(t, e) {
            let n = new WeakMap;
            return {
                get: function(i, r=0) {
                    let s;
                    return !1 === n.has(i) ? (s = new gs(t,e),
                    n.set(i, [s])) : r >= n.get(i).length ? (s = new gs(t,e),
                    n.get(i).push(s)) : s = n.get(i)[r],
                    s
                },
                dispose: function() {
                    n = new WeakMap
                }
            }
        }
        class ys extends pn {
            constructor(t) {
                super(),
                this.type = "MeshDepthMaterial",
                this.depthPacking = 3200,
                this.skinning = !1,
                this.morphTargets = !1,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.depthPacking = t.depthPacking,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this
            }
        }
        ys.prototype.isMeshDepthMaterial = !0;
        class xs extends pn {
            constructor(t) {
                super(),
                this.type = "MeshDistanceMaterial",
                this.referencePosition = new Xt,
                this.nearDistance = 1,
                this.farDistance = 1e3,
                this.skinning = !1,
                this.morphTargets = !1,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.fog = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.referencePosition.copy(t.referencePosition),
                this.nearDistance = t.nearDistance,
                this.farDistance = t.farDistance,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this
            }
        }
        xs.prototype.isMeshDistanceMaterial = !0;
        function _s(t, e, n) {
            let i = new mi;
            const r = new Bt
              , s = new Bt
              , a = new Wt
              , o = []
              , l = []
              , c = {}
              , h = n.maxTextureSize
              , u = {
                0: 1,
                1: 0,
                2: 2
            }
              , d = new ai({
                defines: {
                    SAMPLE_RATE: 2 / 8,
                    HALF_SAMPLE_RATE: 1 / 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new Bt
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
            })
              , p = d.clone();
            p.defines.HORIZONTAL_PASS = 1;
            const f = new zn;
            f.setAttribute("position", new Sn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
            const m = new ti(f,d)
              , g = this;
            function v(n, i) {
                const r = e.update(m);
                d.uniforms.shadow_pass.value = n.map.texture,
                d.uniforms.resolution.value = n.mapSize,
                d.uniforms.radius.value = n.radius,
                t.setRenderTarget(n.mapPass),
                t.clear(),
                t.renderBufferDirect(i, null, r, d, m, null),
                p.uniforms.shadow_pass.value = n.mapPass.texture,
                p.uniforms.resolution.value = n.mapSize,
                p.uniforms.radius.value = n.radius,
                t.setRenderTarget(n.map),
                t.clear(),
                t.renderBufferDirect(i, null, r, p, m, null)
            }
            function y(t, e, n) {
                const i = t << 0 | e << 1 | n << 2;
                let r = o[i];
                return void 0 === r && (r = new ys({
                    depthPacking: 3201,
                    morphTargets: t,
                    skinning: e
                }),
                o[i] = r),
                r
            }
            function x(t, e, n) {
                const i = t << 0 | e << 1 | n << 2;
                let r = l[i];
                return void 0 === r && (r = new xs({
                    morphTargets: t,
                    skinning: e
                }),
                l[i] = r),
                r
            }
            function _(e, n, i, r, s, a, o) {
                let l = null
                  , h = y
                  , d = e.customDepthMaterial;
                if (!0 === r.isPointLight && (h = x,
                d = e.customDistanceMaterial),
                void 0 === d) {
                    let t = !1;
                    !0 === i.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                    let r = !1;
                    !0 === e.isSkinnedMesh && (!0 === i.skinning ? r = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e));
                    l = h(t, r, !0 === e.isInstancedMesh)
                } else
                    l = d;
                if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                    const t = l.uuid
                      , e = i.uuid;
                    let n = c[t];
                    void 0 === n && (n = {},
                    c[t] = n);
                    let r = n[e];
                    void 0 === r && (r = l.clone(),
                    n[e] = r),
                    l = r
                }
                return l.visible = i.visible,
                l.wireframe = i.wireframe,
                l.side = 3 === o ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side],
                l.clipShadows = i.clipShadows,
                l.clippingPlanes = i.clippingPlanes,
                l.clipIntersection = i.clipIntersection,
                l.wireframeLinewidth = i.wireframeLinewidth,
                l.linewidth = i.linewidth,
                !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld),
                l.nearDistance = s,
                l.farDistance = a),
                l
            }
            function w(n, r, s, a, o) {
                if (!1 === n.visible)
                    return;
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                    const i = e.update(n)
                      , r = n.material;
                    if (Array.isArray(r)) {
                        const e = i.groups;
                        for (let l = 0, c = e.length; l < c; l++) {
                            const c = e[l]
                              , h = r[c.materialIndex];
                            if (h && h.visible) {
                                const e = _(n, i, h, a, s.near, s.far, o);
                                t.renderBufferDirect(s, null, i, e, n, c)
                            }
                        }
                    } else if (r.visible) {
                        const e = _(n, i, r, a, s.near, s.far, o);
                        t.renderBufferDirect(s, null, i, e, n, null)
                    }
                }
                const l = n.children;
                for (let t = 0, e = l.length; t < e; t++)
                    w(l[t], r, s, a, o)
            }
            this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = 1,
            this.render = function(e, n, o) {
                if (!1 === g.enabled)
                    return;
                if (!1 === g.autoUpdate && !1 === g.needsUpdate)
                    return;
                if (0 === e.length)
                    return;
                const l = t.getRenderTarget()
                  , c = t.getActiveCubeFace()
                  , u = t.getActiveMipmapLevel()
                  , d = t.state;
                d.setBlending(0),
                d.buffers.color.setClear(1, 1, 1, 1),
                d.buffers.depth.setTest(!0),
                d.setScissorTest(!1);
                for (let l = 0, c = e.length; l < c; l++) {
                    const c = e[l]
                      , u = c.shadow;
                    if (void 0 === u) {
                        console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                        continue
                    }
                    if (!1 === u.autoUpdate && !1 === u.needsUpdate)
                        continue;
                    r.copy(u.mapSize);
                    const p = u.getFrameExtents();
                    if (r.multiply(p),
                    s.copy(u.mapSize),
                    (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / p.x),
                    r.x = s.x * p.x,
                    u.mapSize.x = s.x),
                    r.y > h && (s.y = Math.floor(h / p.y),
                    r.y = s.y * p.y,
                    u.mapSize.y = s.y)),
                    null === u.map && !u.isPointLightShadow && 3 === this.type) {
                        const t = {
                            minFilter: 1006,
                            magFilter: 1006,
                            format: 1023
                        };
                        u.map = new jt(r.x,r.y,t),
                        u.map.texture.name = c.name + ".shadowMap",
                        u.mapPass = new jt(r.x,r.y,t),
                        u.camera.updateProjectionMatrix()
                    }
                    if (null === u.map) {
                        const t = {
                            minFilter: 1003,
                            magFilter: 1003,
                            format: 1023
                        };
                        u.map = new jt(r.x,r.y,t),
                        u.map.texture.name = c.name + ".shadowMap",
                        u.camera.updateProjectionMatrix()
                    }
                    t.setRenderTarget(u.map),
                    t.clear();
                    const f = u.getViewportCount();
                    for (let t = 0; t < f; t++) {
                        const e = u.getViewport(t);
                        a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
                        d.viewport(a),
                        u.updateMatrices(c, t),
                        i = u.getFrustum(),
                        w(n, o, u.camera, c, this.type)
                    }
                    u.isPointLightShadow || 3 !== this.type || v(u, o),
                    u.needsUpdate = !1
                }
                g.needsUpdate = !1,
                t.setRenderTarget(l, c, u)
            }
        }
        function ws(t, e, n) {
            const i = n.isWebGL2;
            const r = new function() {
                let e = !1;
                const n = new Wt;
                let i = null;
                const r = new Wt(0,0,0,0);
                return {
                    setMask: function(n) {
                        i === n || e || (t.colorMask(n, n, n, n),
                        i = n)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e, i, s, a, o) {
                        !0 === o && (e *= a,
                        i *= a,
                        s *= a),
                        n.set(e, i, s, a),
                        !1 === r.equals(n) && (t.clearColor(e, i, s, a),
                        r.copy(n))
                    },
                    reset: function() {
                        e = !1,
                        i = null,
                        r.set(-1, 0, 0, 0)
                    }
                }
            }
              , s = new function() {
                let e = !1
                  , n = null
                  , i = null
                  , r = null;
                return {
                    setTest: function(t) {
                        t ? O(2929) : z(2929)
                    },
                    setMask: function(i) {
                        n === i || e || (t.depthMask(i),
                        n = i)
                    },
                    setFunc: function(e) {
                        if (i !== e) {
                            if (e)
                                switch (e) {
                                case 0:
                                    t.depthFunc(512);
                                    break;
                                case 1:
                                    t.depthFunc(519);
                                    break;
                                case 2:
                                    t.depthFunc(513);
                                    break;
                                case 3:
                                    t.depthFunc(515);
                                    break;
                                case 4:
                                    t.depthFunc(514);
                                    break;
                                case 5:
                                    t.depthFunc(518);
                                    break;
                                case 6:
                                    t.depthFunc(516);
                                    break;
                                case 7:
                                    t.depthFunc(517);
                                    break;
                                default:
                                    t.depthFunc(515)
                                }
                            else
                                t.depthFunc(515);
                            i = e
                        }
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        r !== e && (t.clearDepth(e),
                        r = e)
                    },
                    reset: function() {
                        e = !1,
                        n = null,
                        i = null,
                        r = null
                    }
                }
            }
              , a = new function() {
                let e = !1
                  , n = null
                  , i = null
                  , r = null
                  , s = null
                  , a = null
                  , o = null
                  , l = null
                  , c = null;
                return {
                    setTest: function(t) {
                        e || (t ? O(2960) : z(2960))
                    },
                    setMask: function(i) {
                        n === i || e || (t.stencilMask(i),
                        n = i)
                    },
                    setFunc: function(e, n, a) {
                        i === e && r === n && s === a || (t.stencilFunc(e, n, a),
                        i = e,
                        r = n,
                        s = a)
                    },
                    setOp: function(e, n, i) {
                        a === e && o === n && l === i || (t.stencilOp(e, n, i),
                        a = e,
                        o = n,
                        l = i)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        c !== e && (t.clearStencil(e),
                        c = e)
                    },
                    reset: function() {
                        e = !1,
                        n = null,
                        i = null,
                        r = null,
                        s = null,
                        a = null,
                        o = null,
                        l = null,
                        c = null
                    }
                }
            }
            ;
            let o = {}
              , l = null
              , c = {}
              , h = null
              , u = !1
              , d = null
              , p = null
              , f = null
              , m = null
              , g = null
              , v = null
              , y = null
              , x = !1
              , _ = null
              , w = null
              , b = null
              , M = null
              , S = null;
            const T = t.getParameter(35661);
            let E = !1
              , L = 0;
            const A = t.getParameter(7938);
            -1 !== A.indexOf("WebGL") ? (L = parseFloat(/^WebGL (\d)/.exec(A)[1]),
            E = L >= 1) : -1 !== A.indexOf("OpenGL ES") && (L = parseFloat(/^OpenGL ES (\d)/.exec(A)[1]),
            E = L >= 2);
            let C = null
              , P = {};
            const R = new Wt(0,0,t.canvas.width,t.canvas.height)
              , I = new Wt(0,0,t.canvas.width,t.canvas.height);
            function D(e, n, i) {
                const r = new Uint8Array(4)
                  , s = t.createTexture();
                t.bindTexture(e, s),
                t.texParameteri(e, 10241, 9728),
                t.texParameteri(e, 10240, 9728);
                for (let e = 0; e < i; e++)
                    t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                return s
            }
            const N = {};
            function O(e) {
                !0 !== o[e] && (t.enable(e),
                o[e] = !0)
            }
            function z(e) {
                !1 !== o[e] && (t.disable(e),
                o[e] = !1)
            }
            N[3553] = D(3553, 3553, 1),
            N[34067] = D(34067, 34069, 6),
            r.setClear(0, 0, 0, 1),
            s.setClear(1),
            a.setClear(0),
            O(2929),
            s.setFunc(3),
            H(!1),
            U(1),
            O(2884),
            F(0);
            const B = {
                100: 32774,
                101: 32778,
                102: 32779
            };
            if (i)
                B[103] = 32775,
                B[104] = 32776;
            else {
                const t = e.get("EXT_blend_minmax");
                null !== t && (B[103] = t.MIN_EXT,
                B[104] = t.MAX_EXT)
            }
            const k = {
                200: 0,
                201: 1,
                202: 768,
                204: 770,
                210: 776,
                208: 774,
                206: 772,
                203: 769,
                205: 771,
                209: 775,
                207: 773
            };
            function F(e, n, i, r, s, a, o, l) {
                if (0 !== e) {
                    if (!1 === u && (O(3042),
                    u = !0),
                    5 === e)
                        s = s || n,
                        a = a || i,
                        o = o || r,
                        n === p && s === g || (t.blendEquationSeparate(B[n], B[s]),
                        p = n,
                        g = s),
                        i === f && r === m && a === v && o === y || (t.blendFuncSeparate(k[i], k[r], k[a], k[o]),
                        f = i,
                        m = r,
                        v = a,
                        y = o),
                        d = e,
                        x = null;
                    else if (e !== d || l !== x) {
                        if (100 === p && 100 === g || (t.blendEquation(32774),
                        p = 100,
                        g = 100),
                        l)
                            switch (e) {
                            case 1:
                                t.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(1, 1);
                                break;
                            case 3:
                                t.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case 4:
                                t.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                        else
                            switch (e) {
                            case 1:
                                t.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(770, 1);
                                break;
                            case 3:
                                t.blendFunc(0, 769);
                                break;
                            case 4:
                                t.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                        f = null,
                        m = null,
                        v = null,
                        y = null,
                        d = e,
                        x = l
                    }
                } else
                    !0 === u && (z(3042),
                    u = !1)
            }
            function H(e) {
                _ !== e && (e ? t.frontFace(2304) : t.frontFace(2305),
                _ = e)
            }
            function U(e) {
                0 !== e ? (O(2884),
                e !== w && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : z(2884),
                w = e
            }
            function G(e, n, i) {
                e ? (O(32823),
                M === n && S === i || (t.polygonOffset(n, i),
                M = n,
                S = i)) : z(32823)
            }
            function V(e) {
                void 0 === e && (e = 33984 + T - 1),
                C !== e && (t.activeTexture(e),
                C = e)
            }
            return {
                buffers: {
                    color: r,
                    depth: s,
                    stencil: a
                },
                enable: O,
                disable: z,
                bindFramebuffer: function(e, n) {
                    null === n && null !== l && (n = l),
                    c[e] !== n && (t.bindFramebuffer(e, n),
                    c[e] = n,
                    i && (36009 === e && (c[36160] = n),
                    36160 === e && (c[36009] = n)))
                },
                bindXRFramebuffer: function(e) {
                    e !== l && (t.bindFramebuffer(36160, e),
                    l = e)
                },
                useProgram: function(e) {
                    return h !== e && (t.useProgram(e),
                    h = e,
                    !0)
                },
                setBlending: F,
                setMaterial: function(t, e) {
                    2 === t.side ? z(2884) : O(2884);
                    let n = 1 === t.side;
                    e && (n = !n),
                    H(n),
                    1 === t.blending && !1 === t.transparent ? F(0) : F(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha),
                    s.setFunc(t.depthFunc),
                    s.setTest(t.depthTest),
                    s.setMask(t.depthWrite),
                    r.setMask(t.colorWrite);
                    const i = t.stencilWrite;
                    a.setTest(i),
                    i && (a.setMask(t.stencilWriteMask),
                    a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                    a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                    G(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                    !0 === t.alphaToCoverage ? O(32926) : z(32926)
                },
                setFlipSided: H,
                setCullFace: U,
                setLineWidth: function(e) {
                    e !== b && (E && t.lineWidth(e),
                    b = e)
                },
                setPolygonOffset: G,
                setScissorTest: function(t) {
                    t ? O(3089) : z(3089)
                },
                activeTexture: V,
                bindTexture: function(e, n) {
                    null === C && V();
                    let i = P[C];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    },
                    P[C] = i),
                    i.type === e && i.texture === n || (t.bindTexture(e, n || N[e]),
                    i.type = e,
                    i.texture = n)
                },
                unbindTexture: function() {
                    const e = P[C];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null),
                    e.type = void 0,
                    e.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function() {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage3D: function() {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function(e) {
                    !1 === R.equals(e) && (t.scissor(e.x, e.y, e.z, e.w),
                    R.copy(e))
                },
                viewport: function(e) {
                    !1 === I.equals(e) && (t.viewport(e.x, e.y, e.z, e.w),
                    I.copy(e))
                },
                reset: function() {
                    t.disable(3042),
                    t.disable(2884),
                    t.disable(2929),
                    t.disable(32823),
                    t.disable(3089),
                    t.disable(2960),
                    t.disable(32926),
                    t.blendEquation(32774),
                    t.blendFunc(1, 0),
                    t.blendFuncSeparate(1, 0, 1, 0),
                    t.colorMask(!0, !0, !0, !0),
                    t.clearColor(0, 0, 0, 0),
                    t.depthMask(!0),
                    t.depthFunc(513),
                    t.clearDepth(1),
                    t.stencilMask(4294967295),
                    t.stencilFunc(519, 0, 4294967295),
                    t.stencilOp(7680, 7680, 7680),
                    t.clearStencil(0),
                    t.cullFace(1029),
                    t.frontFace(2305),
                    t.polygonOffset(0, 0),
                    t.activeTexture(33984),
                    t.bindFramebuffer(36160, null),
                    !0 === i && (t.bindFramebuffer(36009, null),
                    t.bindFramebuffer(36008, null)),
                    t.useProgram(null),
                    t.lineWidth(1),
                    t.scissor(0, 0, t.canvas.width, t.canvas.height),
                    t.viewport(0, 0, t.canvas.width, t.canvas.height),
                    o = {},
                    C = null,
                    P = {},
                    l = null,
                    c = {},
                    h = null,
                    u = !1,
                    d = null,
                    p = null,
                    f = null,
                    m = null,
                    g = null,
                    v = null,
                    y = null,
                    x = !1,
                    _ = null,
                    w = null,
                    b = null,
                    M = null,
                    S = null,
                    R.set(0, 0, t.canvas.width, t.canvas.height),
                    I.set(0, 0, t.canvas.width, t.canvas.height),
                    r.reset(),
                    s.reset(),
                    a.reset()
                }
            }
        }
        function bs(t, e, n, i, r, s, a) {
            const o = r.isWebGL2
              , l = r.maxTextures
              , c = r.maxCubemapSize
              , h = r.maxTextureSize
              , u = r.maxSamples
              , d = new WeakMap;
            let p, f = !1;
            try {
                f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
            } catch (t) {}
            function m(t, e) {
                return f ? new OffscreenCanvas(t,e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
            }
            function g(t, e, n, i) {
                let r = 1;
                if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)),
                r < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        const i = e ? zt : Math.floor
                          , s = i(r * t.width)
                          , a = i(r * t.height);
                        void 0 === p && (p = m(s, a));
                        const o = n ? m(s, a) : p;
                        o.width = s,
                        o.height = a;
                        return o.getContext("2d").drawImage(t, 0, 0, s, a),
                        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + a + ")."),
                        o
                    }
                    return "data"in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."),
                    t
                }
                return t
            }
            function v(t) {
                return Nt(t.width) && Nt(t.height)
            }
            function y(t, e) {
                return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
            }
            function x(e, n, r, s) {
                t.generateMipmap(e);
                i.get(n).__maxMipLevel = Math.log2(Math.max(r, s))
            }
            function _(n, i, r) {
                if (!1 === o)
                    return i;
                if (null !== n) {
                    if (void 0 !== t[n])
                        return t[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let s = i;
                return 6403 === i && (5126 === r && (s = 33326),
                5131 === r && (s = 33325),
                5121 === r && (s = 33321)),
                6407 === i && (5126 === r && (s = 34837),
                5131 === r && (s = 34843),
                5121 === r && (s = 32849)),
                6408 === i && (5126 === r && (s = 34836),
                5131 === r && (s = 34842),
                5121 === r && (s = 32856)),
                33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s || e.get("EXT_color_buffer_float"),
                s
            }
            function w(t) {
                return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729
            }
            function b(e) {
                const n = e.target;
                n.removeEventListener("dispose", b),
                function(e) {
                    const n = i.get(e);
                    if (void 0 === n.__webglInit)
                        return;
                    t.deleteTexture(n.__webglTexture),
                    i.remove(e)
                }(n),
                n.isVideoTexture && d.delete(n),
                a.memory.textures--
            }
            function M(e) {
                const n = e.target;
                n.removeEventListener("dispose", M),
                function(e) {
                    const n = e.texture
                      , r = i.get(e)
                      , s = i.get(n);
                    if (!e)
                        return;
                    void 0 !== s.__webglTexture && t.deleteTexture(s.__webglTexture);
                    e.depthTexture && e.depthTexture.dispose();
                    if (e.isWebGLCubeRenderTarget)
                        for (let e = 0; e < 6; e++)
                            t.deleteFramebuffer(r.__webglFramebuffer[e]),
                            r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                    else
                        t.deleteFramebuffer(r.__webglFramebuffer),
                        r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer),
                        r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                        r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                        r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                    i.remove(n),
                    i.remove(e)
                }(n),
                a.memory.textures--
            }
            let S = 0;
            function T(t, e) {
                const r = i.get(t);
                if (t.isVideoTexture && function(t) {
                    const e = a.render.frame;
                    d.get(t) !== e && (d.set(t, e),
                    t.update())
                }(t),
                t.version > 0 && r.__version !== t.version) {
                    const n = t.image;
                    if (void 0 === n)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                    else {
                        if (!1 !== n.complete)
                            return void R(r, t, e);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.activeTexture(33984 + e),
                n.bindTexture(3553, r.__webglTexture)
            }
            function E(e, r) {
                const a = i.get(e);
                e.version > 0 && a.__version !== e.version ? function(e, i, r) {
                    if (6 !== i.image.length)
                        return;
                    P(e, i),
                    n.activeTexture(33984 + r),
                    n.bindTexture(34067, e.__webglTexture),
                    t.pixelStorei(37440, i.flipY),
                    t.pixelStorei(37441, i.premultiplyAlpha),
                    t.pixelStorei(3317, i.unpackAlignment),
                    t.pixelStorei(37443, 0);
                    const a = i && (i.isCompressedTexture || i.image[0].isCompressedTexture)
                      , l = i.image[0] && i.image[0].isDataTexture
                      , h = [];
                    for (let t = 0; t < 6; t++)
                        h[t] = a || l ? l ? i.image[t].image : i.image[t] : g(i.image[t], !1, !0, c);
                    const u = h[0]
                      , d = v(u) || o
                      , p = s.convert(i.format)
                      , f = s.convert(i.type)
                      , m = _(i.internalFormat, p, f);
                    let w;
                    if (C(34067, i, d),
                    a) {
                        for (let t = 0; t < 6; t++) {
                            w = h[t].mipmaps;
                            for (let e = 0; e < w.length; e++) {
                                const r = w[e];
                                1023 !== i.format && 1022 !== i.format ? null !== p ? n.compressedTexImage2D(34069 + t, e, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, m, r.width, r.height, 0, p, f, r.data)
                            }
                        }
                        e.__maxMipLevel = w.length - 1
                    } else {
                        w = i.mipmaps;
                        for (let t = 0; t < 6; t++)
                            if (l) {
                                n.texImage2D(34069 + t, 0, m, h[t].width, h[t].height, 0, p, f, h[t].data);
                                for (let e = 0; e < w.length; e++) {
                                    const i = w[e].image[t].image;
                                    n.texImage2D(34069 + t, e + 1, m, i.width, i.height, 0, p, f, i.data)
                                }
                            } else {
                                n.texImage2D(34069 + t, 0, m, p, f, h[t]);
                                for (let e = 0; e < w.length; e++) {
                                    const i = w[e];
                                    n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t])
                                }
                            }
                        e.__maxMipLevel = w.length
                    }
                    y(i, d) && x(34067, i, u.width, u.height);
                    e.__version = i.version,
                    i.onUpdate && i.onUpdate(i)
                }(a, e, r) : (n.activeTexture(33984 + r),
                n.bindTexture(34067, a.__webglTexture))
            }
            const L = {
                1e3: 10497,
                1001: 33071,
                1002: 33648
            }
              , A = {
                1003: 9728,
                1004: 9984,
                1005: 9986,
                1006: 9729,
                1007: 9985,
                1008: 9987
            };
            function C(n, s, a) {
                if (a ? (t.texParameteri(n, 10242, L[s.wrapS]),
                t.texParameteri(n, 10243, L[s.wrapT]),
                32879 !== n && 35866 !== n || t.texParameteri(n, 32882, L[s.wrapR]),
                t.texParameteri(n, 10240, A[s.magFilter]),
                t.texParameteri(n, 10241, A[s.minFilter])) : (t.texParameteri(n, 10242, 33071),
                t.texParameteri(n, 10243, 33071),
                32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071),
                1001 === s.wrapS && 1001 === s.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
                t.texParameteri(n, 10240, w(s.magFilter)),
                t.texParameteri(n, 10241, w(s.minFilter)),
                1003 !== s.minFilter && 1006 !== s.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
                !0 === e.has("EXT_texture_filter_anisotropic")) {
                    const a = e.get("EXT_texture_filter_anisotropic");
                    if (1015 === s.type && !1 === e.has("OES_texture_float_linear"))
                        return;
                    if (!1 === o && 1016 === s.type && !1 === e.has("OES_texture_half_float_linear"))
                        return;
                    (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())),
                    i.get(s).__currentAnisotropy = s.anisotropy)
                }
            }
            function P(e, n) {
                void 0 === e.__webglInit && (e.__webglInit = !0,
                n.addEventListener("dispose", b),
                e.__webglTexture = t.createTexture(),
                a.memory.textures++)
            }
            function R(e, i, r) {
                let a = 3553;
                i.isDataTexture2DArray && (a = 35866),
                i.isDataTexture3D && (a = 32879),
                P(e, i),
                n.activeTexture(33984 + r),
                n.bindTexture(a, e.__webglTexture),
                t.pixelStorei(37440, i.flipY),
                t.pixelStorei(37441, i.premultiplyAlpha),
                t.pixelStorei(3317, i.unpackAlignment),
                t.pixelStorei(37443, 0);
                const l = function(t) {
                    return !o && (1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && 1006 !== t.minFilter)
                }(i) && !1 === v(i.image)
                  , c = g(i.image, l, !1, h)
                  , u = v(c) || o
                  , d = s.convert(i.format);
                let p, f = s.convert(i.type), m = _(i.internalFormat, d, f);
                C(a, i, u);
                const w = i.mipmaps;
                if (i.isDepthTexture)
                    m = 6402,
                    o ? m = 1015 === i.type ? 36012 : 1014 === i.type ? 33190 : 1020 === i.type ? 35056 : 33189 : 1015 === i.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                    1026 === i.format && 6402 === m && 1012 !== i.type && 1014 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                    i.type = 1012,
                    f = s.convert(i.type)),
                    1027 === i.format && 6402 === m && (m = 34041,
                    1020 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                    i.type = 1020,
                    f = s.convert(i.type))),
                    n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
                else if (i.isDataTexture)
                    if (w.length > 0 && u) {
                        for (let t = 0, e = w.length; t < e; t++)
                            p = w[t],
                            n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                        i.generateMipmaps = !1,
                        e.__maxMipLevel = w.length - 1
                    } else
                        n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data),
                        e.__maxMipLevel = 0;
                else if (i.isCompressedTexture) {
                    for (let t = 0, e = w.length; t < e; t++)
                        p = w[t],
                        1023 !== i.format && 1022 !== i.format ? null !== d ? n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                    e.__maxMipLevel = w.length - 1
                } else if (i.isDataTexture2DArray)
                    n.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data),
                    e.__maxMipLevel = 0;
                else if (i.isDataTexture3D)
                    n.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data),
                    e.__maxMipLevel = 0;
                else if (w.length > 0 && u) {
                    for (let t = 0, e = w.length; t < e; t++)
                        p = w[t],
                        n.texImage2D(3553, t, m, d, f, p);
                    i.generateMipmaps = !1,
                    e.__maxMipLevel = w.length - 1
                } else
                    n.texImage2D(3553, 0, m, d, f, c),
                    e.__maxMipLevel = 0;
                y(i, u) && x(a, i, c.width, c.height),
                e.__version = i.version,
                i.onUpdate && i.onUpdate(i)
            }
            function I(e, r, a, o) {
                const l = r.texture
                  , c = s.convert(l.format)
                  , h = s.convert(l.type)
                  , u = _(l.internalFormat, c, h);
                32879 === o || 35866 === o ? n.texImage3D(o, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(o, 0, u, r.width, r.height, 0, c, h, null),
                n.bindFramebuffer(36160, e),
                t.framebufferTexture2D(36160, a, o, i.get(l).__webglTexture, 0),
                n.bindFramebuffer(36160, null)
            }
            function D(e, n, i) {
                if (t.bindRenderbuffer(36161, e),
                n.depthBuffer && !n.stencilBuffer) {
                    let r = 33189;
                    if (i) {
                        const e = n.depthTexture;
                        e && e.isDepthTexture && (1015 === e.type ? r = 36012 : 1014 === e.type && (r = 33190));
                        const i = O(n);
                        t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                    } else
                        t.renderbufferStorage(36161, r, n.width, n.height);
                    t.framebufferRenderbuffer(36160, 36096, 36161, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    if (i) {
                        const e = O(n);
                        t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                    } else
                        t.renderbufferStorage(36161, 34041, n.width, n.height);
                    t.framebufferRenderbuffer(36160, 33306, 36161, e)
                } else {
                    const e = n.texture
                      , r = s.convert(e.format)
                      , a = s.convert(e.type)
                      , o = _(e.internalFormat, r, a);
                    if (i) {
                        const e = O(n);
                        t.renderbufferStorageMultisample(36161, e, o, n.width, n.height)
                    } else
                        t.renderbufferStorage(36161, o, n.width, n.height)
                }
                t.bindRenderbuffer(36161, null)
            }
            function N(e) {
                const r = i.get(e)
                  , s = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture) {
                    if (s)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    !function(e, r) {
                        if (r && r.isWebGLCubeRenderTarget)
                            throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(36160, e),
                        !r.depthTexture || !r.depthTexture.isDepthTexture)
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                        r.depthTexture.image.height = r.height,
                        r.depthTexture.needsUpdate = !0),
                        T(r.depthTexture, 0);
                        const s = i.get(r.depthTexture).__webglTexture;
                        if (1026 === r.depthTexture.format)
                            t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                        else {
                            if (1027 !== r.depthTexture.format)
                                throw new Error("Unknown depthTexture format");
                            t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                        }
                    }(r.__webglFramebuffer, e)
                } else if (s) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++)
                        n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
                        r.__webglDepthbuffer[i] = t.createRenderbuffer(),
                        D(r.__webglDepthbuffer[i], e, !1)
                } else
                    n.bindFramebuffer(36160, r.__webglFramebuffer),
                    r.__webglDepthbuffer = t.createRenderbuffer(),
                    D(r.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(36160, null)
            }
            function O(t) {
                return o && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0
            }
            let z = !1
              , B = !1;
            this.allocateTextureUnit = function() {
                const t = S;
                return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l),
                S += 1,
                t
            }
            ,
            this.resetTextureUnits = function() {
                S = 0
            }
            ,
            this.setTexture2D = T,
            this.setTexture2DArray = function(t, e) {
                const r = i.get(t);
                t.version > 0 && r.__version !== t.version ? R(r, t, e) : (n.activeTexture(33984 + e),
                n.bindTexture(35866, r.__webglTexture))
            }
            ,
            this.setTexture3D = function(t, e) {
                const r = i.get(t);
                t.version > 0 && r.__version !== t.version ? R(r, t, e) : (n.activeTexture(33984 + e),
                n.bindTexture(32879, r.__webglTexture))
            }
            ,
            this.setTextureCube = E,
            this.setupRenderTarget = function(e) {
                const r = e.texture
                  , l = i.get(e)
                  , c = i.get(r);
                e.addEventListener("dispose", M),
                c.__webglTexture = t.createTexture(),
                c.__version = r.version,
                a.memory.textures++;
                const h = !0 === e.isWebGLCubeRenderTarget
                  , u = !0 === e.isWebGLMultisampleRenderTarget
                  , d = r.isDataTexture3D || r.isDataTexture2DArray
                  , p = v(e) || o;
                if (!o || 1022 !== r.format || 1015 !== r.type && 1016 !== r.type || (r.format = 1023,
                console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),
                h) {
                    l.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++)
                        l.__webglFramebuffer[e] = t.createFramebuffer()
                } else if (l.__webglFramebuffer = t.createFramebuffer(),
                u)
                    if (o) {
                        l.__webglMultisampledFramebuffer = t.createFramebuffer(),
                        l.__webglColorRenderbuffer = t.createRenderbuffer(),
                        t.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
                        const i = s.convert(r.format)
                          , a = s.convert(r.type)
                          , o = _(r.internalFormat, i, a)
                          , c = O(e);
                        t.renderbufferStorageMultisample(36161, c, o, e.width, e.height),
                        n.bindFramebuffer(36160, l.__webglMultisampledFramebuffer),
                        t.framebufferRenderbuffer(36160, 36064, 36161, l.__webglColorRenderbuffer),
                        t.bindRenderbuffer(36161, null),
                        e.depthBuffer && (l.__webglDepthRenderbuffer = t.createRenderbuffer(),
                        D(l.__webglDepthRenderbuffer, e, !0)),
                        n.bindFramebuffer(36160, null)
                    } else
                        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                if (h) {
                    n.bindTexture(34067, c.__webglTexture),
                    C(34067, r, p);
                    for (let t = 0; t < 6; t++)
                        I(l.__webglFramebuffer[t], e, 36064, 34069 + t);
                    y(r, p) && x(34067, r, e.width, e.height),
                    n.bindTexture(34067, null)
                } else {
                    let t = 3553;
                    if (d)
                        if (o) {
                            t = r.isDataTexture3D ? 32879 : 35866
                        } else
                            console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
                    n.bindTexture(t, c.__webglTexture),
                    C(t, r, p),
                    I(l.__webglFramebuffer, e, 36064, t),
                    y(r, p) && x(3553, r, e.width, e.height),
                    n.bindTexture(3553, null)
                }
                e.depthBuffer && N(e)
            }
            ,
            this.updateRenderTargetMipmap = function(t) {
                const e = t.texture;
                if (y(e, v(t) || o)) {
                    const r = t.isWebGLCubeRenderTarget ? 34067 : 3553
                      , s = i.get(e).__webglTexture;
                    n.bindTexture(r, s),
                    x(r, e, t.width, t.height),
                    n.bindTexture(r, null)
                }
            }
            ,
            this.updateMultisampleRenderTarget = function(e) {
                if (e.isWebGLMultisampleRenderTarget)
                    if (o) {
                        const r = e.width
                          , s = e.height;
                        let a = 16384;
                        e.depthBuffer && (a |= 256),
                        e.stencilBuffer && (a |= 1024);
                        const o = i.get(e);
                        n.bindFramebuffer(36008, o.__webglMultisampledFramebuffer),
                        n.bindFramebuffer(36009, o.__webglFramebuffer),
                        t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728),
                        n.bindFramebuffer(36008, null),
                        n.bindFramebuffer(36009, o.__webglMultisampledFramebuffer)
                    } else
                        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
            }
            ,
            this.safeSetTexture2D = function(t, e) {
                t && t.isWebGLRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),
                z = !0),
                t = t.texture),
                T(t, e)
            }
            ,
            this.safeSetTextureCube = function(t, e) {
                t && t.isWebGLCubeRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
                B = !0),
                t = t.texture),
                E(t, e)
            }
        }
        function Ms(t, e, n) {
            const i = n.isWebGL2;
            return {
                convert: function(t) {
                    let n;
                    if (1009 === t)
                        return 5121;
                    if (1017 === t)
                        return 32819;
                    if (1018 === t)
                        return 32820;
                    if (1019 === t)
                        return 33635;
                    if (1010 === t)
                        return 5120;
                    if (1011 === t)
                        return 5122;
                    if (1012 === t)
                        return 5123;
                    if (1013 === t)
                        return 5124;
                    if (1014 === t)
                        return 5125;
                    if (1015 === t)
                        return 5126;
                    if (1016 === t)
                        return i ? 5131 : (n = e.get("OES_texture_half_float"),
                        null !== n ? n.HALF_FLOAT_OES : null);
                    if (1021 === t)
                        return 6406;
                    if (1022 === t)
                        return 6407;
                    if (1023 === t)
                        return 6408;
                    if (1024 === t)
                        return 6409;
                    if (1025 === t)
                        return 6410;
                    if (1026 === t)
                        return 6402;
                    if (1027 === t)
                        return 34041;
                    if (1028 === t)
                        return 6403;
                    if (1029 === t)
                        return 36244;
                    if (1030 === t)
                        return 33319;
                    if (1031 === t)
                        return 33320;
                    if (1032 === t)
                        return 36248;
                    if (1033 === t)
                        return 36249;
                    if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
                        if (n = e.get("WEBGL_compressed_texture_s3tc"),
                        null === n)
                            return null;
                        if (33776 === t)
                            return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (33777 === t)
                            return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (33778 === t)
                            return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (33779 === t)
                            return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                        if (n = e.get("WEBGL_compressed_texture_pvrtc"),
                        null === n)
                            return null;
                        if (35840 === t)
                            return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === t)
                            return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === t)
                            return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === t)
                            return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === t)
                        return n = e.get("WEBGL_compressed_texture_etc1"),
                        null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if ((37492 === t || 37496 === t) && (n = e.get("WEBGL_compressed_texture_etc"),
                    null !== n)) {
                        if (37492 === t)
                            return n.COMPRESSED_RGB8_ETC2;
                        if (37496 === t)
                            return n.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (n = e.get("WEBGL_compressed_texture_astc"),
                    null !== n ? t : null) : 36492 === t ? (n = e.get("EXT_texture_compression_bptc"),
                    null !== n ? t : null) : 1020 === t ? i ? 34042 : (n = e.get("WEBGL_depth_texture"),
                    null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                }
            }
        }
        class Ss extends li {
            constructor(t=[]) {
                super(),
                this.cameras = t
            }
        }
        Ss.prototype.isArrayCamera = !0;
        class Ts extends Ze {
            constructor() {
                super(),
                this.type = "Group"
            }
        }
        Ts.prototype.isGroup = !0;
        const Es = {
            type: "move"
        };
        class Ls {
            constructor() {
                this._targetRay = null,
                this._grip = null,
                this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new Ts,
                this._hand.matrixAutoUpdate = !1,
                this._hand.visible = !1,
                this._hand.joints = {},
                this._hand.inputState = {
                    pinching: !1
                }),
                this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new Ts,
                this._targetRay.matrixAutoUpdate = !1,
                this._targetRay.visible = !1,
                this._targetRay.hasLinearVelocity = !1,
                this._targetRay.linearVelocity = new Xt,
                this._targetRay.hasAngularVelocity = !1,
                this._targetRay.angularVelocity = new Xt),
                this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new Ts,
                this._grip.matrixAutoUpdate = !1,
                this._grip.visible = !1,
                this._grip.hasLinearVelocity = !1,
                this._grip.linearVelocity = new Xt,
                this._grip.hasAngularVelocity = !1,
                this._grip.angularVelocity = new Xt),
                this._grip
            }
            dispatchEvent(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t),
                null !== this._grip && this._grip.dispatchEvent(t),
                null !== this._hand && this._hand.dispatchEvent(t),
                this
            }
            disconnect(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }),
                null !== this._targetRay && (this._targetRay.visible = !1),
                null !== this._grip && (this._grip.visible = !1),
                null !== this._hand && (this._hand.visible = !1),
                this
            }
            update(t, e, n) {
                let i = null
                  , r = null
                  , s = null;
                const a = this._targetRay
                  , o = this._grip
                  , l = this._hand;
                if (t && "visible-blurred" !== e.session.visibilityState)
                    if (null !== a && (i = e.getPose(t.targetRaySpace, n),
                    null !== i && (a.matrix.fromArray(i.transform.matrix),
                    a.matrix.decompose(a.position, a.rotation, a.scale),
                    i.linearVelocity ? (a.hasLinearVelocity = !0,
                    a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1,
                    i.angularVelocity ? (a.hasAngularVelocity = !0,
                    a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1,
                    this.dispatchEvent(Es))),
                    l && t.hand) {
                        s = !0;
                        for (const i of t.hand.values()) {
                            const t = e.getJointPose(i, n);
                            if (void 0 === l.joints[i.jointName]) {
                                const t = new Ts;
                                t.matrixAutoUpdate = !1,
                                t.visible = !1,
                                l.joints[i.jointName] = t,
                                l.add(t)
                            }
                            const r = l.joints[i.jointName];
                            null !== t && (r.matrix.fromArray(t.transform.matrix),
                            r.matrix.decompose(r.position, r.rotation, r.scale),
                            r.jointRadius = t.radius),
                            r.visible = null !== t
                        }
                        const i = l.joints["index-finger-tip"]
                          , r = l.joints["thumb-tip"]
                          , a = i.position.distanceTo(r.position)
                          , o = .02
                          , c = .005;
                        l.inputState.pinching && a > o + c ? (l.inputState.pinching = !1,
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: t.handedness,
                            target: this
                        })) : !l.inputState.pinching && a <= o - c && (l.inputState.pinching = !0,
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: t.handedness,
                            target: this
                        }))
                    } else
                        null !== o && t.gripSpace && (r = e.getPose(t.gripSpace, n),
                        null !== r && (o.matrix.fromArray(r.transform.matrix),
                        o.matrix.decompose(o.position, o.rotation, o.scale),
                        r.linearVelocity ? (o.hasLinearVelocity = !0,
                        o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1,
                        r.angularVelocity ? (o.hasAngularVelocity = !0,
                        o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                return null !== a && (a.visible = null !== i),
                null !== o && (o.visible = null !== r),
                null !== l && (l.visible = null !== s),
                this
            }
        }
        class As extends Et {
            constructor(t, e) {
                super();
                const n = this
                  , i = t.state;
                let r = null
                  , s = 1
                  , a = null
                  , o = "local-floor"
                  , l = null;
                const c = []
                  , h = new Map
                  , u = new li;
                u.layers.enable(1),
                u.viewport = new Wt;
                const d = new li;
                d.layers.enable(2),
                d.viewport = new Wt;
                const p = [u, d]
                  , f = new Ss;
                f.layers.enable(1),
                f.layers.enable(2);
                let m = null
                  , g = null;
                function v(t) {
                    const e = h.get(t.inputSource);
                    e && e.dispatchEvent({
                        type: t.type,
                        data: t.inputSource
                    })
                }
                function y() {
                    h.forEach((function(t, e) {
                        t.disconnect(e)
                    }
                    )),
                    h.clear(),
                    m = null,
                    g = null,
                    i.bindXRFramebuffer(null),
                    t.setRenderTarget(t.getRenderTarget()),
                    S.stop(),
                    n.isPresenting = !1,
                    n.dispatchEvent({
                        type: "sessionend"
                    })
                }
                function x(t) {
                    const e = r.inputSources;
                    for (let t = 0; t < c.length; t++)
                        h.set(e[t], c[t]);
                    for (let e = 0; e < t.removed.length; e++) {
                        const n = t.removed[e]
                          , i = h.get(n);
                        i && (i.dispatchEvent({
                            type: "disconnected",
                            data: n
                        }),
                        h.delete(n))
                    }
                    for (let e = 0; e < t.added.length; e++) {
                        const n = t.added[e]
                          , i = h.get(n);
                        i && i.dispatchEvent({
                            type: "connected",
                            data: n
                        })
                    }
                }
                this.enabled = !1,
                this.isPresenting = !1,
                this.getController = function(t) {
                    let e = c[t];
                    return void 0 === e && (e = new Ls,
                    c[t] = e),
                    e.getTargetRaySpace()
                }
                ,
                this.getControllerGrip = function(t) {
                    let e = c[t];
                    return void 0 === e && (e = new Ls,
                    c[t] = e),
                    e.getGripSpace()
                }
                ,
                this.getHand = function(t) {
                    let e = c[t];
                    return void 0 === e && (e = new Ls,
                    c[t] = e),
                    e.getHandSpace()
                }
                ,
                this.setFramebufferScaleFactor = function(t) {
                    s = t,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }
                ,
                this.setReferenceSpaceType = function(t) {
                    o = t,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }
                ,
                this.getReferenceSpace = function() {
                    return a
                }
                ,
                this.getSession = function() {
                    return r
                }
                ,
                this.setSession = async function(t) {
                    if (r = t,
                    null !== r) {
                        r.addEventListener("select", v),
                        r.addEventListener("selectstart", v),
                        r.addEventListener("selectend", v),
                        r.addEventListener("squeeze", v),
                        r.addEventListener("squeezestart", v),
                        r.addEventListener("squeezeend", v),
                        r.addEventListener("end", y),
                        r.addEventListener("inputsourceschange", x);
                        const t = e.getContextAttributes();
                        !0 !== t.xrCompatible && await e.makeXRCompatible();
                        const i = {
                            antialias: t.antialias,
                            alpha: t.alpha,
                            depth: t.depth,
                            stencil: t.stencil,
                            framebufferScaleFactor: s
                        }
                          , l = new XRWebGLLayer(r,e,i);
                        r.updateRenderState({
                            baseLayer: l
                        }),
                        a = await r.requestReferenceSpace(o),
                        S.setContext(r),
                        S.start(),
                        n.isPresenting = !0,
                        n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }
                ;
                const _ = new Xt
                  , w = new Xt;
                function b(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert()
                }
                this.getCamera = function(t) {
                    f.near = d.near = u.near = t.near,
                    f.far = d.far = u.far = t.far,
                    m === f.near && g === f.far || (r.updateRenderState({
                        depthNear: f.near,
                        depthFar: f.far
                    }),
                    m = f.near,
                    g = f.far);
                    const e = t.parent
                      , n = f.cameras;
                    b(f, e);
                    for (let t = 0; t < n.length; t++)
                        b(n[t], e);
                    t.matrixWorld.copy(f.matrixWorld),
                    t.matrix.copy(f.matrix),
                    t.matrix.decompose(t.position, t.quaternion, t.scale);
                    const i = t.children;
                    for (let t = 0, e = i.length; t < e; t++)
                        i[t].updateMatrixWorld(!0);
                    return 2 === n.length ? function(t, e, n) {
                        _.setFromMatrixPosition(e.matrixWorld),
                        w.setFromMatrixPosition(n.matrixWorld);
                        const i = _.distanceTo(w)
                          , r = e.projectionMatrix.elements
                          , s = n.projectionMatrix.elements
                          , a = r[14] / (r[10] - 1)
                          , o = r[14] / (r[10] + 1)
                          , l = (r[9] + 1) / r[5]
                          , c = (r[9] - 1) / r[5]
                          , h = (r[8] - 1) / r[0]
                          , u = (s[8] + 1) / s[0]
                          , d = a * h
                          , p = a * u
                          , f = i / (-h + u)
                          , m = f * -h;
                        e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                        t.translateX(m),
                        t.translateZ(f),
                        t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                        t.matrixWorldInverse.copy(t.matrixWorld).invert();
                        const g = a + f
                          , v = o + f
                          , y = d - m
                          , x = p + (i - m)
                          , b = l * o / v * g
                          , M = c * o / v * g;
                        t.projectionMatrix.makePerspective(y, x, b, M, g, v)
                    }(f, u, d) : f.projectionMatrix.copy(u.projectionMatrix),
                    f
                }
                ;
                let M = null;
                const S = new gi;
                S.setAnimationLoop((function(t, e) {
                    if (l = e.getViewerPose(a),
                    null !== l) {
                        const t = l.views
                          , e = r.renderState.baseLayer;
                        i.bindXRFramebuffer(e.framebuffer);
                        let n = !1;
                        t.length !== f.cameras.length && (f.cameras.length = 0,
                        n = !0);
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i]
                              , s = e.getViewport(r)
                              , a = p[i];
                            a.matrix.fromArray(r.transform.matrix),
                            a.projectionMatrix.fromArray(r.projectionMatrix),
                            a.viewport.set(s.x, s.y, s.width, s.height),
                            0 === i && f.matrix.copy(a.matrix),
                            !0 === n && f.cameras.push(a)
                        }
                    }
                    const n = r.inputSources;
                    for (let t = 0; t < c.length; t++) {
                        const i = c[t]
                          , r = n[t];
                        i.update(r, e, a)
                    }
                    M && M(t, e)
                }
                )),
                this.setAnimationLoop = function(t) {
                    M = t
                }
                ,
                this.dispose = function() {}
            }
        }
        function Cs(t) {
            function e(e, n) {
                e.opacity.value = n.opacity,
                n.color && e.diffuse.value.copy(n.color),
                n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
                n.map && (e.map.value = n.map),
                n.alphaMap && (e.alphaMap.value = n.alphaMap),
                n.specularMap && (e.specularMap.value = n.specularMap);
                const i = t.get(n).envMap;
                if (i) {
                    e.envMap.value = i,
                    e.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1,
                    e.reflectivity.value = n.reflectivity,
                    e.refractionRatio.value = n.refractionRatio;
                    const r = t.get(i).__maxMipLevel;
                    void 0 !== r && (e.maxMipLevel.value = r)
                }
                let r, s;
                n.lightMap && (e.lightMap.value = n.lightMap,
                e.lightMapIntensity.value = n.lightMapIntensity),
                n.aoMap && (e.aoMap.value = n.aoMap,
                e.aoMapIntensity.value = n.aoMapIntensity),
                n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap),
                void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture),
                !0 === r.matrixAutoUpdate && r.updateMatrix(),
                e.uvTransform.value.copy(r.matrix)),
                n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap),
                void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture),
                !0 === s.matrixAutoUpdate && s.updateMatrix(),
                e.uv2Transform.value.copy(s.matrix))
            }
            function n(e, n) {
                e.roughness.value = n.roughness,
                e.metalness.value = n.metalness,
                n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
                n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
                n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
                n.bumpMap && (e.bumpMap.value = n.bumpMap,
                e.bumpScale.value = n.bumpScale,
                1 === n.side && (e.bumpScale.value *= -1)),
                n.normalMap && (e.normalMap.value = n.normalMap,
                e.normalScale.value.copy(n.normalScale),
                1 === n.side && e.normalScale.value.negate()),
                n.displacementMap && (e.displacementMap.value = n.displacementMap,
                e.displacementScale.value = n.displacementScale,
                e.displacementBias.value = n.displacementBias);
                t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
            }
            return {
                refreshFogUniforms: function(t, e) {
                    t.fogColor.value.copy(e.color),
                    e.isFog ? (t.fogNear.value = e.near,
                    t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                },
                refreshMaterialUniforms: function(t, i, r, s) {
                    i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i),
                    function(t, e) {
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                    }(t, i)) : i.isMeshToonMaterial ? (e(t, i),
                    function(t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap);
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        1 === e.side && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        1 === e.side && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshPhongMaterial ? (e(t, i),
                    function(t, e) {
                        t.specular.value.copy(e.specular),
                        t.shininess.value = Math.max(e.shininess, 1e-4),
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        1 === e.side && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        1 === e.side && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshStandardMaterial ? (e(t, i),
                    i.isMeshPhysicalMaterial ? function(t, e) {
                        n(t, e),
                        t.reflectivity.value = e.reflectivity,
                        t.clearcoat.value = e.clearcoat,
                        t.clearcoatRoughness.value = e.clearcoatRoughness,
                        e.sheen && t.sheen.value.copy(e.sheen);
                        e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                        e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                        e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                        t.clearcoatNormalMap.value = e.clearcoatNormalMap,
                        1 === e.side && t.clearcoatNormalScale.value.negate());
                        t.transmission.value = e.transmission,
                        e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
                    }(t, i) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i),
                    function(t, e) {
                        e.matcap && (t.matcap.value = e.matcap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        1 === e.side && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        1 === e.side && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshDepthMaterial ? (e(t, i),
                    function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i),
                    function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias);
                        t.referencePosition.value.copy(e.referencePosition),
                        t.nearDistance.value = e.nearDistance,
                        t.farDistance.value = e.farDistance
                    }(t, i)) : i.isMeshNormalMaterial ? (e(t, i),
                    function(t, e) {
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        1 === e.side && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        1 === e.side && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isLineBasicMaterial ? (function(t, e) {
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity
                    }(t, i),
                    i.isLineDashedMaterial && function(t, e) {
                        t.dashSize.value = e.dashSize,
                        t.totalSize.value = e.dashSize + e.gapSize,
                        t.scale.value = e.scale
                    }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity,
                        t.size.value = e.size * n,
                        t.scale.value = .5 * i,
                        e.map && (t.map.value = e.map);
                        e.alphaMap && (t.alphaMap.value = e.alphaMap);
                        let r;
                        e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
                        void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                        t.uvTransform.value.copy(r.matrix))
                    }(t, i, r, s) : i.isSpriteMaterial ? function(t, e) {
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity,
                        t.rotation.value = e.rotation,
                        e.map && (t.map.value = e.map);
                        e.alphaMap && (t.alphaMap.value = e.alphaMap);
                        let n;
                        e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                        void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                        t.uvTransform.value.copy(n.matrix))
                    }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color),
                    t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                }
            }
        }
        function Ps(t) {
            const e = void 0 !== (t = t || {}).canvas ? t.canvas : function() {
                const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                return t.style.display = "block",
                t
            }()
              , n = void 0 !== t.context ? t.context : null
              , i = void 0 !== t.alpha && t.alpha
              , r = void 0 === t.depth || t.depth
              , s = void 0 === t.stencil || t.stencil
              , a = void 0 !== t.antialias && t.antialias
              , o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
              , l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
              , c = void 0 !== t.powerPreference ? t.powerPreference : "default"
              , h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
            let u = null
              , d = null;
            const p = []
              , f = [];
            this.domElement = e,
            this.debug = {
                checkShaderErrors: !0
            },
            this.autoClear = !0,
            this.autoClearColor = !0,
            this.autoClearDepth = !0,
            this.autoClearStencil = !0,
            this.sortObjects = !0,
            this.clippingPlanes = [],
            this.localClippingEnabled = !1,
            this.gammaFactor = 2,
            this.outputEncoding = 3e3,
            this.physicallyCorrectLights = !1,
            this.toneMapping = 0,
            this.toneMappingExposure = 1;
            const m = this;
            let g = !1
              , v = 0
              , y = 0
              , x = null
              , _ = -1
              , w = null;
            const b = new Wt
              , M = new Wt;
            let S = null
              , T = e.width
              , E = e.height
              , L = 1
              , A = null
              , C = null;
            const P = new Wt(0,0,T,E)
              , R = new Wt(0,0,T,E);
            let I = !1;
            const D = new mi;
            let N = !1
              , O = !1;
            const z = new Se
              , B = new Xt
              , k = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
            function F() {
                return null === x ? L : 1
            }
            let H, U, G, V, W, j, q, X, Y, Z, J, $, K, Q, tt, et, nt, it, rt, st, at, ot, lt = n;
            function ct(t, n) {
                for (let i = 0; i < t.length; i++) {
                    const r = t[i]
                      , s = e.getContext(r, n);
                    if (null !== s)
                        return s
                }
                return null
            }
            try {
                const t = {
                    alpha: i,
                    depth: r,
                    stencil: s,
                    antialias: a,
                    premultipliedAlpha: o,
                    preserveDrawingBuffer: l,
                    powerPreference: c,
                    failIfMajorPerformanceCaveat: h
                };
                if (e.addEventListener("webglcontextlost", dt, !1),
                e.addEventListener("webglcontextrestored", pt, !1),
                null === lt) {
                    const e = ["webgl2", "webgl", "experimental-webgl"];
                    if (!0 === m.isWebGL1Renderer && e.shift(),
                    lt = ct(e, t),
                    null === lt)
                        throw ct(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                void 0 === lt.getShaderPrecisionFormat && (lt.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                }
                )
            } catch (t) {
                throw console.error("THREE.WebGLRenderer: " + t.message),
                t
            }
            function ht() {
                H = new Ai(lt),
                U = new Ti(lt,H,t),
                H.init(U),
                at = new Ms(lt,H,U),
                G = new ws(lt,H,U),
                V = new Ri(lt),
                W = new os,
                j = new bs(lt,H,G,W,U,at,V),
                q = new Li(m),
                X = new vi(lt,U),
                ot = new Mi(lt,H,X,U),
                Y = new Ci(lt,X,V,ot),
                Z = new Oi(lt,Y,X,V),
                it = new Ni(lt),
                tt = new Ei(W),
                J = new as(m,q,H,U,ot,tt),
                $ = new Cs(W),
                K = new us(W),
                Q = new vs(H,U),
                nt = new bi(m,q,G,Z,o),
                et = new _s(m,Z,U),
                rt = new Si(lt,H,V,U),
                st = new Pi(lt,H,V,U),
                V.programs = J.programs,
                m.capabilities = U,
                m.extensions = H,
                m.properties = W,
                m.renderLists = K,
                m.shadowMap = et,
                m.state = G,
                m.info = V
            }
            ht();
            const ut = new As(m,lt);
            function dt(t) {
                t.preventDefault(),
                console.log("THREE.WebGLRenderer: Context Lost."),
                g = !0
            }
            function pt() {
                console.log("THREE.WebGLRenderer: Context Restored."),
                g = !1;
                const t = V.autoReset
                  , e = et.enabled
                  , n = et.autoUpdate
                  , i = et.needsUpdate
                  , r = et.type;
                ht(),
                V.autoReset = t,
                et.enabled = e,
                et.autoUpdate = n,
                et.needsUpdate = i,
                et.type = r
            }
            function ft(t) {
                const e = t.target;
                e.removeEventListener("dispose", ft),
                function(t) {
                    (function(t) {
                        const e = W.get(t).programs;
                        void 0 !== e && e.forEach((function(t) {
                            J.releaseProgram(t)
                        }
                        ))
                    }
                    )(t),
                    W.remove(t)
                }(e)
            }
            this.xr = ut,
            this.getContext = function() {
                return lt
            }
            ,
            this.getContextAttributes = function() {
                return lt.getContextAttributes()
            }
            ,
            this.forceContextLoss = function() {
                const t = H.get("WEBGL_lose_context");
                t && t.loseContext()
            }
            ,
            this.forceContextRestore = function() {
                const t = H.get("WEBGL_lose_context");
                t && t.restoreContext()
            }
            ,
            this.getPixelRatio = function() {
                return L
            }
            ,
            this.setPixelRatio = function(t) {
                void 0 !== t && (L = t,
                this.setSize(T, E, !1))
            }
            ,
            this.getSize = function(t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),
                t = new Bt),
                t.set(T, E)
            }
            ,
            this.setSize = function(t, n, i) {
                ut.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = t,
                E = n,
                e.width = Math.floor(t * L),
                e.height = Math.floor(n * L),
                !1 !== i && (e.style.width = t + "px",
                e.style.height = n + "px"),
                this.setViewport(0, 0, t, n))
            }
            ,
            this.getDrawingBufferSize = function(t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),
                t = new Bt),
                t.set(T * L, E * L).floor()
            }
            ,
            this.setDrawingBufferSize = function(t, n, i) {
                T = t,
                E = n,
                L = i,
                e.width = Math.floor(t * i),
                e.height = Math.floor(n * i),
                this.setViewport(0, 0, t, n)
            }
            ,
            this.getCurrentViewport = function(t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),
                t = new Wt),
                t.copy(b)
            }
            ,
            this.getViewport = function(t) {
                return t.copy(P)
            }
            ,
            this.setViewport = function(t, e, n, i) {
                t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, i),
                G.viewport(b.copy(P).multiplyScalar(L).floor())
            }
            ,
            this.getScissor = function(t) {
                return t.copy(R)
            }
            ,
            this.setScissor = function(t, e, n, i) {
                t.isVector4 ? R.set(t.x, t.y, t.z, t.w) : R.set(t, e, n, i),
                G.scissor(M.copy(R).multiplyScalar(L).floor())
            }
            ,
            this.getScissorTest = function() {
                return I
            }
            ,
            this.setScissorTest = function(t) {
                G.setScissorTest(I = t)
            }
            ,
            this.setOpaqueSort = function(t) {
                A = t
            }
            ,
            this.setTransparentSort = function(t) {
                C = t
            }
            ,
            this.getClearColor = function(t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),
                t = new _n),
                t.copy(nt.getClearColor())
            }
            ,
            this.setClearColor = function() {
                nt.setClearColor.apply(nt, arguments)
            }
            ,
            this.getClearAlpha = function() {
                return nt.getClearAlpha()
            }
            ,
            this.setClearAlpha = function() {
                nt.setClearAlpha.apply(nt, arguments)
            }
            ,
            this.clear = function(t, e, n) {
                let i = 0;
                (void 0 === t || t) && (i |= 16384),
                (void 0 === e || e) && (i |= 256),
                (void 0 === n || n) && (i |= 1024),
                lt.clear(i)
            }
            ,
            this.clearColor = function() {
                this.clear(!0, !1, !1)
            }
            ,
            this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }
            ,
            this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }
            ,
            this.dispose = function() {
                e.removeEventListener("webglcontextlost", dt, !1),
                e.removeEventListener("webglcontextrestored", pt, !1),
                K.dispose(),
                Q.dispose(),
                W.dispose(),
                q.dispose(),
                Z.dispose(),
                ot.dispose(),
                ut.dispose(),
                ut.removeEventListener("sessionstart", gt),
                ut.removeEventListener("sessionend", vt),
                yt.stop()
            }
            ,
            this.renderBufferImmediate = function(t, e) {
                ot.initAttributes();
                const n = W.get(t);
                t.hasPositions && !n.position && (n.position = lt.createBuffer()),
                t.hasNormals && !n.normal && (n.normal = lt.createBuffer()),
                t.hasUvs && !n.uv && (n.uv = lt.createBuffer()),
                t.hasColors && !n.color && (n.color = lt.createBuffer());
                const i = e.getAttributes();
                t.hasPositions && (lt.bindBuffer(34962, n.position),
                lt.bufferData(34962, t.positionArray, 35048),
                ot.enableAttribute(i.position),
                lt.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
                t.hasNormals && (lt.bindBuffer(34962, n.normal),
                lt.bufferData(34962, t.normalArray, 35048),
                ot.enableAttribute(i.normal),
                lt.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
                t.hasUvs && (lt.bindBuffer(34962, n.uv),
                lt.bufferData(34962, t.uvArray, 35048),
                ot.enableAttribute(i.uv),
                lt.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
                t.hasColors && (lt.bindBuffer(34962, n.color),
                lt.bufferData(34962, t.colorArray, 35048),
                ot.enableAttribute(i.color),
                lt.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
                ot.disableUnusedAttributes(),
                lt.drawArrays(4, 0, t.count),
                t.count = 0
            }
            ,
            this.renderBufferDirect = function(t, e, n, i, r, s) {
                null === e && (e = k);
                const a = r.isMesh && r.matrixWorld.determinant() < 0
                  , o = St(t, e, i, r);
                G.setMaterial(i, a);
                let l = n.index;
                const c = n.attributes.position;
                if (null === l) {
                    if (void 0 === c || 0 === c.count)
                        return
                } else if (0 === l.count)
                    return;
                let h, u = 1;
                !0 === i.wireframe && (l = Y.getWireframeAttribute(n),
                u = 2),
                (i.morphTargets || i.morphNormals) && it.update(r, n, i, o),
                ot.setup(r, i, o, n, l);
                let d = rt;
                null !== l && (h = X.get(l),
                d = st,
                d.setIndex(h));
                const p = null !== l ? l.count : c.count
                  , f = n.drawRange.start * u
                  , m = n.drawRange.count * u
                  , g = null !== s ? s.start * u : 0
                  , v = null !== s ? s.count * u : 1 / 0
                  , y = Math.max(f, g)
                  , x = Math.min(p, f + m, g + v) - 1
                  , _ = Math.max(0, x - y + 1);
                if (0 !== _) {
                    if (r.isMesh)
                        !0 === i.wireframe ? (G.setLineWidth(i.wireframeLinewidth * F()),
                        d.setMode(1)) : d.setMode(4);
                    else if (r.isLine) {
                        let t = i.linewidth;
                        void 0 === t && (t = 1),
                        G.setLineWidth(t * F()),
                        r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                    } else
                        r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                    if (r.isInstancedMesh)
                        d.renderInstances(y, _, r.count);
                    else if (n.isInstancedBufferGeometry) {
                        const t = Math.min(n.instanceCount, n._maxInstanceCount);
                        d.renderInstances(y, _, t)
                    } else
                        d.render(y, _)
                }
            }
            ,
            this.compile = function(t, e) {
                d = Q.get(t),
                d.init(),
                t.traverseVisible((function(t) {
                    t.isLight && t.layers.test(e.layers) && (d.pushLight(t),
                    t.castShadow && d.pushShadow(t))
                }
                )),
                d.setupLights(),
                t.traverse((function(e) {
                    const n = e.material;
                    if (n)
                        if (Array.isArray(n))
                            for (let i = 0; i < n.length; i++) {
                                bt(n[i], t, e)
                            }
                        else
                            bt(n, t, e)
                }
                ))
            }
            ;
            let mt = null;
            function gt() {
                yt.stop()
            }
            function vt() {
                yt.start()
            }
            const yt = new gi;
            function xt(t, e, n, i) {
                if (!1 === t.visible)
                    return;
                if (t.layers.test(e.layers))
                    if (t.isGroup)
                        n = t.renderOrder;
                    else if (t.isLOD)
                        !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight)
                        d.pushLight(t),
                        t.castShadow && d.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || D.intersectsSprite(t)) {
                            i && B.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z);
                            const e = Z.update(t)
                              , r = t.material;
                            r.visible && u.push(t, e, r, n, B.z, null)
                        }
                    } else if (t.isImmediateRenderObject)
                        i && B.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z),
                        u.push(t, null, t.material, n, B.z, null);
                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== V.render.frame && (t.skeleton.update(),
                    t.skeleton.frame = V.render.frame),
                    !t.frustumCulled || D.intersectsObject(t))) {
                        i && B.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z);
                        const e = Z.update(t)
                          , r = t.material;
                        if (Array.isArray(r)) {
                            const i = e.groups;
                            for (let s = 0, a = i.length; s < a; s++) {
                                const a = i[s]
                                  , o = r[a.materialIndex];
                                o && o.visible && u.push(t, e, o, n, B.z, a)
                            }
                        } else
                            r.visible && u.push(t, e, r, n, B.z, null)
                    }
                const r = t.children;
                for (let t = 0, s = r.length; t < s; t++)
                    xt(r[t], e, n, i)
            }
            function _t(t, e, n) {
                const i = !0 === e.isScene ? e.overrideMaterial : null;
                for (let r = 0, s = t.length; r < s; r++) {
                    const s = t[r]
                      , a = s.object
                      , o = s.geometry
                      , l = null === i ? s.material : i
                      , c = s.group;
                    if (n.isArrayCamera) {
                        const t = n.cameras;
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n];
                            a.layers.test(i.layers) && (G.viewport(b.copy(i.viewport)),
                            d.setupLightsView(i),
                            wt(a, e, i, o, l, c))
                        }
                    } else
                        wt(a, e, n, o, l, c)
                }
            }
            function wt(t, e, n, i, r, s) {
                if (t.onBeforeRender(m, e, n, i, r, s),
                t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
                t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                t.isImmediateRenderObject) {
                    const i = St(n, e, r, t);
                    G.setMaterial(r),
                    ot.reset(),
                    function(t, e) {
                        t.render((function(t) {
                            m.renderBufferImmediate(t, e)
                        }
                        ))
                    }(t, i)
                } else
                    m.renderBufferDirect(n, e, i, r, t, s);
                t.onAfterRender(m, e, n, i, r, s)
            }
            function bt(t, e, n) {
                !0 !== e.isScene && (e = k);
                const i = W.get(t)
                  , r = d.state.lights
                  , s = d.state.shadowsArray
                  , a = r.state.version
                  , o = J.getParameters(t, r.state, s, e, n)
                  , l = J.getProgramCacheKey(o);
                let c = i.programs;
                i.environment = t.isMeshStandardMaterial ? e.environment : null,
                i.fog = e.fog,
                i.envMap = q.get(t.envMap || i.environment),
                void 0 === c && (t.addEventListener("dispose", ft),
                c = new Map,
                i.programs = c);
                let h = c.get(l);
                if (void 0 !== h) {
                    if (i.currentProgram === h && i.lightsStateVersion === a)
                        return Mt(t, o),
                        h
                } else
                    o.uniforms = J.getUniforms(t),
                    t.onBuild(o, m),
                    t.onBeforeCompile(o, m),
                    h = J.acquireProgram(o, l),
                    c.set(l, h),
                    i.uniforms = o.uniforms;
                const u = i.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = tt.uniform),
                Mt(t, o),
                i.needsLights = function(t) {
                    return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                }(t),
                i.lightsStateVersion = a,
                i.needsLights && (u.ambientLightColor.value = r.state.ambient,
                u.lightProbe.value = r.state.probe,
                u.directionalLights.value = r.state.directional,
                u.directionalLightShadows.value = r.state.directionalShadow,
                u.spotLights.value = r.state.spot,
                u.spotLightShadows.value = r.state.spotShadow,
                u.rectAreaLights.value = r.state.rectArea,
                u.ltc_1.value = r.state.rectAreaLTC1,
                u.ltc_2.value = r.state.rectAreaLTC2,
                u.pointLights.value = r.state.point,
                u.pointLightShadows.value = r.state.pointShadow,
                u.hemisphereLights.value = r.state.hemi,
                u.directionalShadowMap.value = r.state.directionalShadowMap,
                u.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
                u.spotShadowMap.value = r.state.spotShadowMap,
                u.spotShadowMatrix.value = r.state.spotShadowMatrix,
                u.pointShadowMap.value = r.state.pointShadowMap,
                u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                const p = h.getUniforms()
                  , f = Fr.seqWithValue(p.seq, u);
                return i.currentProgram = h,
                i.uniformsList = f,
                h
            }
            function Mt(t, e) {
                const n = W.get(t);
                n.outputEncoding = e.outputEncoding,
                n.instancing = e.instancing,
                n.numClippingPlanes = e.numClippingPlanes,
                n.numIntersection = e.numClipIntersection,
                n.vertexAlphas = e.vertexAlphas
            }
            function St(t, e, n, i) {
                !0 !== e.isScene && (e = k),
                j.resetTextureUnits();
                const r = e.fog
                  , s = n.isMeshStandardMaterial ? e.environment : null
                  , a = null === x ? m.outputEncoding : x.texture.encoding
                  , o = q.get(n.envMap || s)
                  , l = !0 === n.vertexColors && i.geometry && i.geometry.attributes.color && 4 === i.geometry.attributes.color.itemSize
                  , c = W.get(n)
                  , h = d.state.lights;
                if (!0 === N && (!0 === O || t !== w)) {
                    const e = t === w && n.id === _;
                    tt.setState(n, t, e)
                }
                let u = !1;
                n.version === c.__version ? c.needsLights && c.lightsStateVersion !== h.state.version || c.outputEncoding !== a || i.isInstancedMesh && !1 === c.instancing ? u = !0 : i.isInstancedMesh || !0 !== c.instancing ? c.envMap !== o || n.fog && c.fog !== r ? u = !0 : void 0 === c.numClippingPlanes || c.numClippingPlanes === tt.numPlanes && c.numIntersection === tt.numIntersection ? c.vertexAlphas !== l && (u = !0) : u = !0 : u = !0 : (u = !0,
                c.__version = n.version);
                let p = c.currentProgram;
                !0 === u && (p = bt(n, e, i));
                let f = !1
                  , g = !1
                  , v = !1;
                const y = p.getUniforms()
                  , b = c.uniforms;
                if (G.useProgram(p.program) && (f = !0,
                g = !0,
                v = !0),
                n.id !== _ && (_ = n.id,
                g = !0),
                f || w !== t) {
                    if (y.setValue(lt, "projectionMatrix", t.projectionMatrix),
                    U.logarithmicDepthBuffer && y.setValue(lt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                    w !== t && (w = t,
                    g = !0,
                    v = !0),
                    n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                        const e = y.map.cameraPosition;
                        void 0 !== e && e.setValue(lt, B.setFromMatrixPosition(t.matrixWorld))
                    }
                    (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && y.setValue(lt, "isOrthographic", !0 === t.isOrthographicCamera),
                    (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && y.setValue(lt, "viewMatrix", t.matrixWorldInverse)
                }
                if (n.skinning) {
                    y.setOptional(lt, i, "bindMatrix"),
                    y.setOptional(lt, i, "bindMatrixInverse");
                    const t = i.skeleton;
                    if (t) {
                        const e = t.bones;
                        if (U.floatVertexTextures) {
                            if (null === t.boneTexture) {
                                let n = Math.sqrt(4 * e.length);
                                n = Ot(n),
                                n = Math.max(n, 4);
                                const i = new Float32Array(n * n * 4);
                                i.set(t.boneMatrices);
                                const r = new di(i,n,n,1023,1015);
                                t.boneMatrices = i,
                                t.boneTexture = r,
                                t.boneTextureSize = n
                            }
                            y.setValue(lt, "boneTexture", t.boneTexture, j),
                            y.setValue(lt, "boneTextureSize", t.boneTextureSize)
                        } else
                            y.setOptional(lt, t, "boneMatrices")
                    }
                }
                var M, S;
                return (g || c.receiveShadow !== i.receiveShadow) && (c.receiveShadow = i.receiveShadow,
                y.setValue(lt, "receiveShadow", i.receiveShadow)),
                g && (y.setValue(lt, "toneMappingExposure", m.toneMappingExposure),
                c.needsLights && (S = v,
                (M = b).ambientLightColor.needsUpdate = S,
                M.lightProbe.needsUpdate = S,
                M.directionalLights.needsUpdate = S,
                M.directionalLightShadows.needsUpdate = S,
                M.pointLights.needsUpdate = S,
                M.pointLightShadows.needsUpdate = S,
                M.spotLights.needsUpdate = S,
                M.spotLightShadows.needsUpdate = S,
                M.rectAreaLights.needsUpdate = S,
                M.hemisphereLights.needsUpdate = S),
                r && n.fog && $.refreshFogUniforms(b, r),
                $.refreshMaterialUniforms(b, n, L, E),
                Fr.upload(lt, c.uniformsList, b, j)),
                n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Fr.upload(lt, c.uniformsList, b, j),
                n.uniformsNeedUpdate = !1),
                n.isSpriteMaterial && y.setValue(lt, "center", i.center),
                y.setValue(lt, "modelViewMatrix", i.modelViewMatrix),
                y.setValue(lt, "normalMatrix", i.normalMatrix),
                y.setValue(lt, "modelMatrix", i.matrixWorld),
                p
            }
            yt.setAnimationLoop((function(t) {
                mt && mt(t)
            }
            )),
            "undefined" != typeof window && yt.setContext(window),
            this.setAnimationLoop = function(t) {
                mt = t,
                ut.setAnimationLoop(t),
                null === t ? yt.stop() : yt.start()
            }
            ,
            ut.addEventListener("sessionstart", gt),
            ut.addEventListener("sessionend", vt),
            this.render = function(t, e) {
                let n, i;
                if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),
                n = arguments[2]),
                void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),
                i = arguments[3]),
                void 0 !== e && !0 !== e.isCamera)
                    return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                if (!0 === g)
                    return;
                !0 === t.autoUpdate && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                !0 === ut.enabled && !0 === ut.isPresenting && (e = ut.getCamera(e)),
                !0 === t.isScene && t.onBeforeRender(m, t, e, n || x),
                d = Q.get(t, f.length),
                d.init(),
                f.push(d),
                z.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                D.setFromProjectionMatrix(z),
                O = this.localClippingEnabled,
                N = tt.init(this.clippingPlanes, O, e),
                u = K.get(t, p.length),
                u.init(),
                p.push(u),
                xt(t, e, 0, m.sortObjects),
                u.finish(),
                !0 === m.sortObjects && u.sort(A, C),
                !0 === N && tt.beginShadows();
                const r = d.state.shadowsArray;
                et.render(r, t, e),
                d.setupLights(),
                d.setupLightsView(e),
                !0 === N && tt.endShadows(),
                !0 === this.info.autoReset && this.info.reset(),
                void 0 !== n && this.setRenderTarget(n),
                nt.render(u, t, e, i);
                const s = u.opaque
                  , a = u.transparent;
                s.length > 0 && _t(s, t, e),
                a.length > 0 && _t(a, t, e),
                null !== x && (j.updateRenderTargetMipmap(x),
                j.updateMultisampleRenderTarget(x)),
                !0 === t.isScene && t.onAfterRender(m, t, e),
                G.buffers.depth.setTest(!0),
                G.buffers.depth.setMask(!0),
                G.buffers.color.setMask(!0),
                G.setPolygonOffset(!1),
                ot.resetDefaultState(),
                _ = -1,
                w = null,
                f.pop(),
                d = f.length > 0 ? f[f.length - 1] : null,
                p.pop(),
                u = p.length > 0 ? p[p.length - 1] : null
            }
            ,
            this.getActiveCubeFace = function() {
                return v
            }
            ,
            this.getActiveMipmapLevel = function() {
                return y
            }
            ,
            this.getRenderTarget = function() {
                return x
            }
            ,
            this.setRenderTarget = function(t, e=0, n=0) {
                x = t,
                v = e,
                y = n,
                t && void 0 === W.get(t).__webglFramebuffer && j.setupRenderTarget(t);
                let i = null
                  , r = !1
                  , s = !1;
                if (t) {
                    const n = t.texture;
                    (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
                    const a = W.get(t).__webglFramebuffer;
                    t.isWebGLCubeRenderTarget ? (i = a[e],
                    r = !0) : i = t.isWebGLMultisampleRenderTarget ? W.get(t).__webglMultisampledFramebuffer : a,
                    b.copy(t.viewport),
                    M.copy(t.scissor),
                    S = t.scissorTest
                } else
                    b.copy(P).multiplyScalar(L).floor(),
                    M.copy(R).multiplyScalar(L).floor(),
                    S = I;
                if (G.bindFramebuffer(36160, i),
                G.viewport(b),
                G.scissor(M),
                G.setScissorTest(S),
                r) {
                    const i = W.get(t.texture);
                    lt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
                } else if (s) {
                    const i = W.get(t.texture)
                      , r = e || 0;
                    lt.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
                }
            }
            ,
            this.readRenderTargetPixels = function(t, e, n, i, r, s, a) {
                if (!t || !t.isWebGLRenderTarget)
                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let o = W.get(t).__webglFramebuffer;
                if (t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]),
                o) {
                    G.bindFramebuffer(36160, o);
                    try {
                        const a = t.texture
                          , o = a.format
                          , l = a.type;
                        if (1023 !== o && at.convert(o) !== lt.getParameter(35739))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        const c = 1016 === l && (H.has("EXT_color_buffer_half_float") || U.isWebGL2 && H.has("EXT_color_buffer_float"));
                        if (!(1009 === l || at.convert(l) === lt.getParameter(35738) || 1015 === l && (U.isWebGL2 || H.has("OES_texture_float") || H.has("WEBGL_color_buffer_float")) || c))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        36053 === lt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && lt.readPixels(e, n, i, r, at.convert(o), at.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        const t = null !== x ? W.get(x).__webglFramebuffer : null;
                        G.bindFramebuffer(36160, t)
                    }
                }
            }
            ,
            this.copyFramebufferToTexture = function(t, e, n=0) {
                const i = Math.pow(2, -n)
                  , r = Math.floor(e.image.width * i)
                  , s = Math.floor(e.image.height * i)
                  , a = at.convert(e.format);
                j.setTexture2D(e, 0),
                lt.copyTexImage2D(3553, n, a, t.x, t.y, r, s, 0),
                G.unbindTexture()
            }
            ,
            this.copyTextureToTexture = function(t, e, n, i=0) {
                const r = e.image.width
                  , s = e.image.height
                  , a = at.convert(n.format)
                  , o = at.convert(n.type);
                j.setTexture2D(n, 0),
                lt.pixelStorei(37440, n.flipY),
                lt.pixelStorei(37441, n.premultiplyAlpha),
                lt.pixelStorei(3317, n.unpackAlignment),
                e.isDataTexture ? lt.texSubImage2D(3553, i, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? lt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : lt.texSubImage2D(3553, i, t.x, t.y, a, o, e.image),
                0 === i && n.generateMipmaps && lt.generateMipmap(3553),
                G.unbindTexture()
            }
            ,
            this.copyTextureToTexture3D = function(t, e, n, i, r=0) {
                if (m.isWebGL1Renderer)
                    return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                const {width: s, height: a, data: o} = n.image
                  , l = at.convert(i.format)
                  , c = at.convert(i.type);
                let h;
                if (i.isDataTexture3D)
                    j.setTexture3D(i, 0),
                    h = 32879;
                else {
                    if (!i.isDataTexture2DArray)
                        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                    j.setTexture2DArray(i, 0),
                    h = 35866
                }
                lt.pixelStorei(37440, i.flipY),
                lt.pixelStorei(37441, i.premultiplyAlpha),
                lt.pixelStorei(3317, i.unpackAlignment);
                const u = lt.getParameter(3314)
                  , d = lt.getParameter(32878)
                  , p = lt.getParameter(3316)
                  , f = lt.getParameter(3315)
                  , g = lt.getParameter(32877);
                lt.pixelStorei(3314, s),
                lt.pixelStorei(32878, a),
                lt.pixelStorei(3316, t.min.x),
                lt.pixelStorei(3315, t.min.y),
                lt.pixelStorei(32877, t.min.z),
                lt.texSubImage3D(h, r, e.x, e.y, e.z, t.max.x - t.min.x + 1, t.max.y - t.min.y + 1, t.max.z - t.min.z + 1, l, c, o),
                lt.pixelStorei(3314, u),
                lt.pixelStorei(32878, d),
                lt.pixelStorei(3316, p),
                lt.pixelStorei(3315, f),
                lt.pixelStorei(32877, g),
                0 === r && i.generateMipmaps && lt.generateMipmap(h),
                G.unbindTexture()
            }
            ,
            this.initTexture = function(t) {
                j.setTexture2D(t, 0),
                G.unbindTexture()
            }
            ,
            this.resetState = function() {
                v = 0,
                y = 0,
                x = null,
                G.reset(),
                ot.reset()
            }
            ,
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                detail: this
            }))
        }
        (class extends Ps {
        }
        ).prototype.isWebGL1Renderer = !0;
        class Rs {
            constructor(t, e=25e-5) {
                this.name = "",
                this.color = new _n(t),
                this.density = e
            }
            clone() {
                return new Rs(this.color,this.density)
            }
            toJSON() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }
        Rs.prototype.isFogExp2 = !0;
        class Is {
            constructor(t, e=1, n=1e3) {
                this.name = "",
                this.color = new _n(t),
                this.near = e,
                this.far = n
            }
            clone() {
                return new Is(this.color,this.near,this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        Is.prototype.isFog = !0;
        class Ds extends Ze {
            constructor() {
                super(),
                this.type = "Scene",
                this.background = null,
                this.environment = null,
                this.fog = null,
                this.overrideMaterial = null,
                this.autoUpdate = !0,
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            copy(t, e) {
                return super.copy(t, e),
                null !== t.background && (this.background = t.background.clone()),
                null !== t.environment && (this.environment = t.environment.clone()),
                null !== t.fog && (this.fog = t.fog.clone()),
                null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
                this.autoUpdate = t.autoUpdate,
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.background && (e.object.background = this.background.toJSON(t)),
                null !== this.environment && (e.object.environment = this.environment.toJSON(t)),
                null !== this.fog && (e.object.fog = this.fog.toJSON()),
                e
            }
        }
        Ds.prototype.isScene = !0;
        class Ns {
            constructor(t, e) {
                this.array = t,
                this.stride = e,
                this.count = void 0 !== t ? t.length / e : 0,
                this.usage = 35044,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0,
                this.uuid = Pt(),
                this.onUploadCallback = function() {}
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t,
                this
            }
            copy(t) {
                return this.array = new t.array.constructor(t.array),
                this.count = t.count,
                this.stride = t.stride,
                this.usage = t.usage,
                this
            }
            copyAt(t, e, n) {
                t *= this.stride,
                n *= e.stride;
                for (let i = 0, r = this.stride; i < r; i++)
                    this.array[t + i] = e.array[n + i];
                return this
            }
            set(t, e=0) {
                return this.array.set(t, e),
                this
            }
            clone(t) {
                void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Pt()),
                void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid])
                  , n = new Ns(e,this.stride);
                return n.setUsage(this.usage),
                n
            }
            onUpload(t) {
                return this.onUploadCallback = t,
                this
            }
            toJSON(t) {
                return void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Pt()),
                void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
                {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        Ns.prototype.isInterleavedBuffer = !0;
        const Os = new Xt;
        class zs {
            constructor(t, e, n, i) {
                this.name = "",
                this.data = t,
                this.itemSize = e,
                this.offset = n,
                this.normalized = !0 === i
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(t) {
                this.data.needsUpdate = t
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.data.count; e < n; e++)
                    Os.x = this.getX(e),
                    Os.y = this.getY(e),
                    Os.z = this.getZ(e),
                    Os.applyMatrix4(t),
                    this.setXYZ(e, Os.x, Os.y, Os.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    Os.x = this.getX(e),
                    Os.y = this.getY(e),
                    Os.z = this.getZ(e),
                    Os.applyNormalMatrix(t),
                    this.setXYZ(e, Os.x, Os.y, Os.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    Os.x = this.getX(e),
                    Os.y = this.getY(e),
                    Os.z = this.getZ(e),
                    Os.transformDirection(t),
                    this.setXYZ(e, Os.x, Os.y, Os.z);
                return this
            }
            setX(t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e,
                this
            }
            setY(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e,
                this
            }
            setZ(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e,
                this
            }
            setW(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e,
                this
            }
            getX(t) {
                return this.data.array[t * this.data.stride + this.offset]
            }
            getY(t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            }
            getZ(t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            }
            getW(t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            }
            setXY(t, e, n) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = n,
                this
            }
            setXYZ(t, e, n, i) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = n,
                this.data.array[t + 2] = i,
                this
            }
            setXYZW(t, e, n, i, r) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = n,
                this.data.array[t + 2] = i,
                this.data.array[t + 3] = r,
                this
            }
            clone(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++)
                            t.push(this.data.array[n + e])
                    }
                    return new Sn(new this.array.constructor(t),this.itemSize,this.normalized)
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
                new zs(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
            }
            toJSON(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++)
                            t.push(this.data.array[n + e])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: t,
                        normalized: this.normalized
                    }
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
                {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        zs.prototype.isInterleavedBufferAttribute = !0;
        class Bs extends pn {
            constructor(t) {
                super(),
                this.type = "SpriteMaterial",
                this.color = new _n(16777215),
                this.map = null,
                this.alphaMap = null,
                this.rotation = 0,
                this.sizeAttenuation = !0,
                this.transparent = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.rotation = t.rotation,
                this.sizeAttenuation = t.sizeAttenuation,
                this
            }
        }
        let ks;
        Bs.prototype.isSpriteMaterial = !0;
        const Fs = new Xt
          , Hs = new Xt
          , Us = new Xt
          , Gs = new Bt
          , Vs = new Bt
          , Ws = new Se
          , js = new Xt
          , qs = new Xt
          , Xs = new Xt
          , Ys = new Bt
          , Zs = new Bt
          , Js = new Bt;
        class $s extends Ze {
            constructor(t) {
                if (super(),
                this.type = "Sprite",
                void 0 === ks) {
                    ks = new zn;
                    const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
                      , e = new Ns(t,5);
                    ks.setIndex([0, 1, 2, 0, 2, 3]),
                    ks.setAttribute("position", new zs(e,3,0,!1)),
                    ks.setAttribute("uv", new zs(e,2,3,!1))
                }
                this.geometry = ks,
                this.material = void 0 !== t ? t : new Bs,
                this.center = new Bt(.5,.5)
            }
            raycast(t, e) {
                null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
                Hs.setFromMatrixScale(this.matrixWorld),
                Ws.copy(t.camera.matrixWorld),
                this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
                Us.setFromMatrixPosition(this.modelViewMatrix),
                t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Hs.multiplyScalar(-Us.z);
                const n = this.material.rotation;
                let i, r;
                0 !== n && (r = Math.cos(n),
                i = Math.sin(n));
                const s = this.center;
                Ks(js.set(-.5, -.5, 0), Us, s, Hs, i, r),
                Ks(qs.set(.5, -.5, 0), Us, s, Hs, i, r),
                Ks(Xs.set(.5, .5, 0), Us, s, Hs, i, r),
                Ys.set(0, 0),
                Zs.set(1, 0),
                Js.set(1, 1);
                let a = t.ray.intersectTriangle(js, qs, Xs, !1, Fs);
                if (null === a && (Ks(qs.set(-.5, .5, 0), Us, s, Hs, i, r),
                Zs.set(0, 1),
                a = t.ray.intersectTriangle(js, Xs, qs, !1, Fs),
                null === a))
                    return;
                const o = t.ray.origin.distanceTo(Fs);
                o < t.near || o > t.far || e.push({
                    distance: o,
                    point: Fs.clone(),
                    uv: un.getUV(Fs, js, qs, Xs, Ys, Zs, Js, new Bt),
                    face: null,
                    object: this
                })
            }
            copy(t) {
                return super.copy(t),
                void 0 !== t.center && this.center.copy(t.center),
                this.material = t.material,
                this
            }
        }
        function Ks(t, e, n, i, r, s) {
            Gs.subVectors(t, n).addScalar(.5).multiply(i),
            void 0 !== r ? (Vs.x = s * Gs.x - r * Gs.y,
            Vs.y = r * Gs.x + s * Gs.y) : Vs.copy(Gs),
            t.copy(e),
            t.x += Vs.x,
            t.y += Vs.y,
            t.applyMatrix4(Ws)
        }
        $s.prototype.isSprite = !0;
        const Qs = new Xt
          , ta = new Wt
          , ea = new Wt
          , na = new Xt
          , ia = new Se;
        class ra extends ti {
            constructor(t, e) {
                super(t, e),
                this.type = "SkinnedMesh",
                this.bindMode = "attached",
                this.bindMatrix = new Se,
                this.bindMatrixInverse = new Se
            }
            copy(t) {
                return super.copy(t),
                this.bindMode = t.bindMode,
                this.bindMatrix.copy(t.bindMatrix),
                this.bindMatrixInverse.copy(t.bindMatrixInverse),
                this.skeleton = t.skeleton,
                this
            }
            bind(t, e) {
                this.skeleton = t,
                void 0 === e && (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                e = this.matrixWorld),
                this.bindMatrix.copy(e),
                this.bindMatrixInverse.copy(e).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const t = new Wt
                  , e = this.geometry.attributes.skinWeight;
                for (let n = 0, i = e.count; n < i; n++) {
                    t.x = e.getX(n),
                    t.y = e.getY(n),
                    t.z = e.getZ(n),
                    t.w = e.getW(n);
                    const i = 1 / t.manhattanLength();
                    i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
                    e.setXYZW(n, t.x, t.y, t.z, t.w)
                }
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t),
                "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            boneTransform(t, e) {
                const n = this.skeleton
                  , i = this.geometry;
                ta.fromBufferAttribute(i.attributes.skinIndex, t),
                ea.fromBufferAttribute(i.attributes.skinWeight, t),
                Qs.fromBufferAttribute(i.attributes.position, t).applyMatrix4(this.bindMatrix),
                e.set(0, 0, 0);
                for (let t = 0; t < 4; t++) {
                    const i = ea.getComponent(t);
                    if (0 !== i) {
                        const r = ta.getComponent(t);
                        ia.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                        e.addScaledVector(na.copy(Qs).applyMatrix4(ia), i)
                    }
                }
                return e.applyMatrix4(this.bindMatrixInverse)
            }
        }
        ra.prototype.isSkinnedMesh = !0;
        class sa extends Ze {
            constructor() {
                super(),
                this.type = "Bone"
            }
        }
        sa.prototype.isBone = !0;
        const aa = new Se
          , oa = new Se
          , la = []
          , ca = new ti;
        class ha extends ti {
            constructor(t, e, n) {
                super(t, e),
                this.instanceMatrix = new Sn(new Float32Array(16 * n),16),
                this.instanceColor = null,
                this.count = n,
                this.frustumCulled = !1
            }
            copy(t) {
                return super.copy(t),
                this.instanceMatrix.copy(t.instanceMatrix),
                null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
                this.count = t.count,
                this
            }
            getColorAt(t, e) {
                e.fromArray(this.instanceColor.array, 3 * t)
            }
            getMatrixAt(t, e) {
                e.fromArray(this.instanceMatrix.array, 16 * t)
            }
            raycast(t, e) {
                const n = this.matrixWorld
                  , i = this.count;
                if (ca.geometry = this.geometry,
                ca.material = this.material,
                void 0 !== ca.material)
                    for (let r = 0; r < i; r++) {
                        this.getMatrixAt(r, aa),
                        oa.multiplyMatrices(n, aa),
                        ca.matrixWorld = oa,
                        ca.raycast(t, la);
                        for (let t = 0, n = la.length; t < n; t++) {
                            const n = la[t];
                            n.instanceId = r,
                            n.object = this,
                            e.push(n)
                        }
                        la.length = 0
                    }
            }
            setColorAt(t, e) {
                null === this.instanceColor && (this.instanceColor = new Sn(new Float32Array(3 * this.count),3)),
                e.toArray(this.instanceColor.array, 3 * t)
            }
            setMatrixAt(t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        ha.prototype.isInstancedMesh = !0;
        class ua extends pn {
            constructor(t) {
                super(),
                this.type = "LineBasicMaterial",
                this.color = new _n(16777215),
                this.linewidth = 1,
                this.linecap = "round",
                this.linejoin = "round",
                this.morphTargets = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.linewidth = t.linewidth,
                this.linecap = t.linecap,
                this.linejoin = t.linejoin,
                this.morphTargets = t.morphTargets,
                this
            }
        }
        ua.prototype.isLineBasicMaterial = !0;
        const da = new Xt
          , pa = new Xt
          , fa = new Se
          , ma = new Me
          , ga = new me;
        class va extends Ze {
            constructor(t=new zn, e=new ua) {
                super(),
                this.type = "Line",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t) {
                return super.copy(t),
                this.material = t.material,
                this.geometry = t.geometry,
                this
            }
            computeLineDistances() {
                const t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        const e = t.attributes.position
                          , n = [0];
                        for (let t = 1, i = e.count; t < i; t++)
                            da.fromBufferAttribute(e, t - 1),
                            pa.fromBufferAttribute(e, t),
                            n[t] = n[t - 1],
                            n[t] += da.distanceTo(pa);
                        t.setAttribute("lineDistance", new Ln(n,1))
                    } else
                        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else
                    t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
            raycast(t, e) {
                const n = this.geometry
                  , i = this.matrixWorld
                  , r = t.params.Line.threshold
                  , s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                ga.copy(n.boundingSphere),
                ga.applyMatrix4(i),
                ga.radius += r,
                !1 === t.ray.intersectsSphere(ga))
                    return;
                fa.copy(i).invert(),
                ma.copy(t.ray).applyMatrix4(fa);
                const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , o = a * a
                  , l = new Xt
                  , c = new Xt
                  , h = new Xt
                  , u = new Xt
                  , d = this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    const i = n.index
                      , r = n.attributes.position;
                    if (null !== i) {
                        for (let n = Math.max(0, s.start), a = Math.min(i.count, s.start + s.count) - 1; n < a; n += d) {
                            const s = i.getX(n)
                              , a = i.getX(n + 1);
                            l.fromBufferAttribute(r, s),
                            c.fromBufferAttribute(r, a);
                            if (ma.distanceSqToSegment(l, c, u, h) > o)
                                continue;
                            u.applyMatrix4(this.matrixWorld);
                            const d = t.ray.origin.distanceTo(u);
                            d < t.near || d > t.far || e.push({
                                distance: d,
                                point: h.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    } else {
                        for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += d) {
                            l.fromBufferAttribute(r, n),
                            c.fromBufferAttribute(r, n + 1);
                            if (ma.distanceSqToSegment(l, c, u, h) > o)
                                continue;
                            u.applyMatrix4(this.matrixWorld);
                            const i = t.ray.origin.distanceTo(u);
                            i < t.near || i > t.far || e.push({
                                distance: i,
                                point: h.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                } else
                    n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                      , n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }
        va.prototype.isLine = !0;
        const ya = new Xt
          , xa = new Xt;
        class _a extends va {
            constructor(t, e) {
                super(t, e),
                this.type = "LineSegments"
            }
            computeLineDistances() {
                const t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        const e = t.attributes.position
                          , n = [];
                        for (let t = 0, i = e.count; t < i; t += 2)
                            ya.fromBufferAttribute(e, t),
                            xa.fromBufferAttribute(e, t + 1),
                            n[t] = 0 === t ? 0 : n[t - 1],
                            n[t + 1] = n[t] + ya.distanceTo(xa);
                        t.setAttribute("lineDistance", new Ln(n,1))
                    } else
                        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else
                    t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
        }
        _a.prototype.isLineSegments = !0;
        class wa extends va {
            constructor(t, e) {
                super(t, e),
                this.type = "LineLoop"
            }
        }
        wa.prototype.isLineLoop = !0;
        class ba extends pn {
            constructor(t) {
                super(),
                this.type = "PointsMaterial",
                this.color = new _n(16777215),
                this.map = null,
                this.alphaMap = null,
                this.size = 1,
                this.sizeAttenuation = !0,
                this.morphTargets = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.size = t.size,
                this.sizeAttenuation = t.sizeAttenuation,
                this.morphTargets = t.morphTargets,
                this
            }
        }
        ba.prototype.isPointsMaterial = !0;
        const Ma = new Se
          , Sa = new Me
          , Ta = new me
          , Ea = new Xt;
        class La extends Ze {
            constructor(t=new zn, e=new ba) {
                super(),
                this.type = "Points",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t) {
                return super.copy(t),
                this.material = t.material,
                this.geometry = t.geometry,
                this
            }
            raycast(t, e) {
                const n = this.geometry
                  , i = this.matrixWorld
                  , r = t.params.Points.threshold
                  , s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                Ta.copy(n.boundingSphere),
                Ta.applyMatrix4(i),
                Ta.radius += r,
                !1 === t.ray.intersectsSphere(Ta))
                    return;
                Ma.copy(i).invert(),
                Sa.copy(t.ray).applyMatrix4(Ma);
                const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , o = a * a;
                if (n.isBufferGeometry) {
                    const r = n.index
                      , a = n.attributes.position;
                    if (null !== r) {
                        for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) {
                            const s = r.getX(n);
                            Ea.fromBufferAttribute(a, s),
                            Aa(Ea, s, o, i, t, e, this)
                        }
                    } else {
                        for (let n = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); n < r; n++)
                            Ea.fromBufferAttribute(a, n),
                            Aa(Ea, n, o, i, t, e, this)
                    }
                } else
                    console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                      , n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }
        function Aa(t, e, n, i, r, s, a) {
            const o = Sa.distanceSqToPoint(t);
            if (o < n) {
                const n = new Xt;
                Sa.closestPointToPoint(t, n),
                n.applyMatrix4(i);
                const l = r.ray.origin.distanceTo(n);
                if (l < r.near || l > r.far)
                    return;
                s.push({
                    distance: l,
                    distanceToRay: Math.sqrt(o),
                    point: n,
                    index: e,
                    face: null,
                    object: a
                })
            }
        }
        La.prototype.isPoints = !0;
        (class extends Gt {
            constructor(t, e, n, i, r, s, a, o, l) {
                super(t, e, n, i, r, s, a, o, l),
                this.format = void 0 !== a ? a : 1022,
                this.minFilter = void 0 !== s ? s : 1006,
                this.magFilter = void 0 !== r ? r : 1006,
                this.generateMipmaps = !1;
                const c = this;
                "requestVideoFrameCallback"in t && t.requestVideoFrameCallback((function e() {
                    c.needsUpdate = !0,
                    t.requestVideoFrameCallback(e)
                }
                ))
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const t = this.image;
                !1 === "requestVideoFrameCallback"in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        ).prototype.isVideoTexture = !0;
        class Ca extends Gt {
            constructor(t, e, n, i, r, s, a, o, l, c, h, u) {
                super(null, s, a, o, l, c, i, r, h, u),
                this.image = {
                    width: e,
                    height: n
                },
                this.mipmaps = t,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
        }
        Ca.prototype.isCompressedTexture = !0;
        (class extends Gt {
            constructor(t, e, n, i, r, s, a, o, l) {
                super(t, e, n, i, r, s, a, o, l),
                this.needsUpdate = !0
            }
        }
        ).prototype.isCanvasTexture = !0;
        (class extends Gt {
            constructor(t, e, n, i, r, s, a, o, l, c) {
                if (1026 !== (c = void 0 !== c ? c : 1026) && 1027 !== c)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && 1026 === c && (n = 1012),
                void 0 === n && 1027 === c && (n = 1020),
                super(null, i, r, s, a, o, c, n, l),
                this.image = {
                    width: t,
                    height: e
                },
                this.magFilter = void 0 !== a ? a : 1003,
                this.minFilter = void 0 !== o ? o : 1003,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
        }
        ).prototype.isDepthTexture = !0;
        new Xt,
        new Xt,
        new Xt,
        new un;
        const Pa = function(t, e, n) {
            n = n || 2;
            const i = e && e.length
              , r = i ? e[0] * n : t.length;
            let s = Ra(t, 0, r, n, !0);
            const a = [];
            if (!s || s.next === s.prev)
                return a;
            let o, l, c, h, u, d, p;
            if (i && (s = function(t, e, n, i) {
                const r = [];
                let s, a, o, l, c;
                for (s = 0,
                a = e.length; s < a; s++)
                    o = e[s] * i,
                    l = s < a - 1 ? e[s + 1] * i : t.length,
                    c = Ra(t, o, l, i, !1),
                    c === c.next && (c.steiner = !0),
                    r.push(Ga(c));
                for (r.sort(ka),
                s = 0; s < r.length; s++)
                    Fa(r[s], n),
                    n = Ia(n, n.next);
                return n
            }(t, e, s, n)),
            t.length > 80 * n) {
                o = c = t[0],
                l = h = t[1];
                for (let e = n; e < r; e += n)
                    u = t[e],
                    d = t[e + 1],
                    u < o && (o = u),
                    d < l && (l = d),
                    u > c && (c = u),
                    d > h && (h = d);
                p = Math.max(c - o, h - l),
                p = 0 !== p ? 1 / p : 0
            }
            return Da(s, a, n, o, l, p),
            a
        };
        function Ra(t, e, n, i, r) {
            let s, a;
            if (r === function(t, e, n, i) {
                let r = 0;
                for (let s = e, a = n - i; s < n; s += i)
                    r += (t[a] - t[s]) * (t[s + 1] + t[a + 1]),
                    a = s;
                return r
            }(t, e, n, i) > 0)
                for (s = e; s < n; s += i)
                    a = Ka(s, t[s], t[s + 1], a);
            else
                for (s = n - i; s >= e; s -= i)
                    a = Ka(s, t[s], t[s + 1], a);
            return a && qa(a, a.next) && (Qa(a),
            a = a.next),
            a
        }
        function Ia(t, e) {
            if (!t)
                return t;
            e || (e = t);
            let n, i = t;
            do {
                if (n = !1,
                i.steiner || !qa(i, i.next) && 0 !== ja(i.prev, i, i.next))
                    i = i.next;
                else {
                    if (Qa(i),
                    i = e = i.prev,
                    i === i.next)
                        break;
                    n = !0
                }
            } while (n || i !== e);
            return e
        }
        function Da(t, e, n, i, r, s, a) {
            if (!t)
                return;
            !a && s && function(t, e, n, i) {
                let r = t;
                do {
                    null === r.z && (r.z = Ua(r.x, r.y, e, n, i)),
                    r.prevZ = r.prev,
                    r.nextZ = r.next,
                    r = r.next
                } while (r !== t);
                r.prevZ.nextZ = null,
                r.prevZ = null,
                function(t) {
                    let e, n, i, r, s, a, o, l, c = 1;
                    do {
                        for (n = t,
                        t = null,
                        s = null,
                        a = 0; n; ) {
                            for (a++,
                            i = n,
                            o = 0,
                            e = 0; e < c && (o++,
                            i = i.nextZ,
                            i); e++)
                                ;
                            for (l = c; o > 0 || l > 0 && i; )
                                0 !== o && (0 === l || !i || n.z <= i.z) ? (r = n,
                                n = n.nextZ,
                                o--) : (r = i,
                                i = i.nextZ,
                                l--),
                                s ? s.nextZ = r : t = r,
                                r.prevZ = s,
                                s = r;
                            n = i
                        }
                        s.nextZ = null,
                        c *= 2
                    } while (a > 1)
                }(r)
            }(t, i, r, s);
            let o, l, c = t;
            for (; t.prev !== t.next; )
                if (o = t.prev,
                l = t.next,
                s ? Oa(t, i, r, s) : Na(t))
                    e.push(o.i / n),
                    e.push(t.i / n),
                    e.push(l.i / n),
                    Qa(t),
                    t = l.next,
                    c = l.next;
                else if ((t = l) === c) {
                    a ? 1 === a ? Da(t = za(Ia(t), e, n), e, n, i, r, s, 2) : 2 === a && Ba(t, e, n, i, r, s) : Da(Ia(t), e, n, i, r, s, 1);
                    break
                }
        }
        function Na(t) {
            const e = t.prev
              , n = t
              , i = t.next;
            if (ja(e, n, i) >= 0)
                return !1;
            let r = t.next.next;
            for (; r !== t.prev; ) {
                if (Va(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && ja(r.prev, r, r.next) >= 0)
                    return !1;
                r = r.next
            }
            return !0
        }
        function Oa(t, e, n, i) {
            const r = t.prev
              , s = t
              , a = t.next;
            if (ja(r, s, a) >= 0)
                return !1;
            const o = r.x < s.x ? r.x < a.x ? r.x : a.x : s.x < a.x ? s.x : a.x
              , l = r.y < s.y ? r.y < a.y ? r.y : a.y : s.y < a.y ? s.y : a.y
              , c = r.x > s.x ? r.x > a.x ? r.x : a.x : s.x > a.x ? s.x : a.x
              , h = r.y > s.y ? r.y > a.y ? r.y : a.y : s.y > a.y ? s.y : a.y
              , u = Ua(o, l, e, n, i)
              , d = Ua(c, h, e, n, i);
            let p = t.prevZ
              , f = t.nextZ;
            for (; p && p.z >= u && f && f.z <= d; ) {
                if (p !== t.prev && p !== t.next && Va(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && ja(p.prev, p, p.next) >= 0)
                    return !1;
                if (p = p.prevZ,
                f !== t.prev && f !== t.next && Va(r.x, r.y, s.x, s.y, a.x, a.y, f.x, f.y) && ja(f.prev, f, f.next) >= 0)
                    return !1;
                f = f.nextZ
            }
            for (; p && p.z >= u; ) {
                if (p !== t.prev && p !== t.next && Va(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && ja(p.prev, p, p.next) >= 0)
                    return !1;
                p = p.prevZ
            }
            for (; f && f.z <= d; ) {
                if (f !== t.prev && f !== t.next && Va(r.x, r.y, s.x, s.y, a.x, a.y, f.x, f.y) && ja(f.prev, f, f.next) >= 0)
                    return !1;
                f = f.nextZ
            }
            return !0
        }
        function za(t, e, n) {
            let i = t;
            do {
                const r = i.prev
                  , s = i.next.next;
                !qa(r, s) && Xa(r, i, i.next, s) && Ja(r, s) && Ja(s, r) && (e.push(r.i / n),
                e.push(i.i / n),
                e.push(s.i / n),
                Qa(i),
                Qa(i.next),
                i = t = s),
                i = i.next
            } while (i !== t);
            return Ia(i)
        }
        function Ba(t, e, n, i, r, s) {
            let a = t;
            do {
                let t = a.next.next;
                for (; t !== a.prev; ) {
                    if (a.i !== t.i && Wa(a, t)) {
                        let o = $a(a, t);
                        return a = Ia(a, a.next),
                        o = Ia(o, o.next),
                        Da(a, e, n, i, r, s),
                        void Da(o, e, n, i, r, s)
                    }
                    t = t.next
                }
                a = a.next
            } while (a !== t)
        }
        function ka(t, e) {
            return t.x - e.x
        }
        function Fa(t, e) {
            if (e = function(t, e) {
                let n = e;
                const i = t.x
                  , r = t.y;
                let s, a = -1 / 0;
                do {
                    if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                        const t = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                        if (t <= i && t > a) {
                            if (a = t,
                            t === i) {
                                if (r === n.y)
                                    return n;
                                if (r === n.next.y)
                                    return n.next
                            }
                            s = n.x < n.next.x ? n : n.next
                        }
                    }
                    n = n.next
                } while (n !== e);
                if (!s)
                    return null;
                if (i === a)
                    return s;
                const o = s
                  , l = s.x
                  , c = s.y;
                let h, u = 1 / 0;
                n = s;
                do {
                    i >= n.x && n.x >= l && i !== n.x && Va(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x),
                    Ja(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && Ha(s, n))) && (s = n,
                    u = h)),
                    n = n.next
                } while (n !== o);
                return s
            }(t, e)) {
                const n = $a(e, t);
                Ia(e, e.next),
                Ia(n, n.next)
            }
        }
        function Ha(t, e) {
            return ja(t.prev, t, e.prev) < 0 && ja(e.next, t, t.next) < 0
        }
        function Ua(t, e, n, i, r) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }
        function Ga(t) {
            let e = t
              , n = t;
            do {
                (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e),
                e = e.next
            } while (e !== t);
            return n
        }
        function Va(t, e, n, i, r, s, a, o) {
            return (r - a) * (e - o) - (t - a) * (s - o) >= 0 && (t - a) * (i - o) - (n - a) * (e - o) >= 0 && (n - a) * (s - o) - (r - a) * (i - o) >= 0
        }
        function Wa(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
                let n = t;
                do {
                    if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Xa(n, n.next, t, e))
                        return !0;
                    n = n.next
                } while (n !== t);
                return !1
            }(t, e) && (Ja(t, e) && Ja(e, t) && function(t, e) {
                let n = t
                  , i = !1;
                const r = (t.x + e.x) / 2
                  , s = (t.y + e.y) / 2;
                do {
                    n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i),
                    n = n.next
                } while (n !== t);
                return i
            }(t, e) && (ja(t.prev, t, e.prev) || ja(t, e.prev, e)) || qa(t, e) && ja(t.prev, t, t.next) > 0 && ja(e.prev, e, e.next) > 0)
        }
        function ja(t, e, n) {
            return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
        }
        function qa(t, e) {
            return t.x === e.x && t.y === e.y
        }
        function Xa(t, e, n, i) {
            const r = Za(ja(t, e, n))
              , s = Za(ja(t, e, i))
              , a = Za(ja(n, i, t))
              , o = Za(ja(n, i, e));
            return r !== s && a !== o || (!(0 !== r || !Ya(t, n, e)) || (!(0 !== s || !Ya(t, i, e)) || (!(0 !== a || !Ya(n, t, i)) || !(0 !== o || !Ya(n, e, i)))))
        }
        function Ya(t, e, n) {
            return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
        }
        function Za(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0
        }
        function Ja(t, e) {
            return ja(t.prev, t, t.next) < 0 ? ja(t, e, t.next) >= 0 && ja(t, t.prev, e) >= 0 : ja(t, e, t.prev) < 0 || ja(t, t.next, e) < 0
        }
        function $a(t, e) {
            const n = new to(t.i,t.x,t.y)
              , i = new to(e.i,e.x,e.y)
              , r = t.next
              , s = e.prev;
            return t.next = e,
            e.prev = t,
            n.next = r,
            r.prev = n,
            i.next = n,
            n.prev = i,
            s.next = i,
            i.prev = s,
            i
        }
        function Ka(t, e, n, i) {
            const r = new to(t,e,n);
            return i ? (r.next = i.next,
            r.prev = i,
            i.next.prev = r,
            i.next = r) : (r.prev = r,
            r.next = r),
            r
        }
        function Qa(t) {
            t.next.prev = t.prev,
            t.prev.next = t.next,
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }
        function to(t, e, n) {
            this.i = t,
            this.x = e,
            this.y = n,
            this.prev = null,
            this.next = null,
            this.z = null,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1
        }
        class eo {
            static area(t) {
                const e = t.length;
                let n = 0;
                for (let i = e - 1, r = 0; r < e; i = r++)
                    n += t[i].x * t[r].y - t[r].x * t[i].y;
                return .5 * n
            }
            static isClockWise(t) {
                return eo.area(t) < 0
            }
            static triangulateShape(t, e) {
                const n = []
                  , i = []
                  , r = [];
                no(t),
                io(n, t);
                let s = t.length;
                e.forEach(no);
                for (let t = 0; t < e.length; t++)
                    i.push(s),
                    s += e[t].length,
                    io(n, e[t]);
                const a = Pa(n, i);
                for (let t = 0; t < a.length; t += 3)
                    r.push(a.slice(t, t + 3));
                return r
            }
        }
        function no(t) {
            const e = t.length;
            e > 2 && t[e - 1].equals(t[0]) && t.pop()
        }
        function io(t, e) {
            for (let n = 0; n < e.length; n++)
                t.push(e[n].x),
                t.push(e[n].y)
        }
        class ro extends zn {
            constructor(t, e) {
                super(),
                this.type = "ExtrudeGeometry",
                this.parameters = {
                    shapes: t,
                    options: e
                },
                t = Array.isArray(t) ? t : [t];
                const n = this
                  , i = []
                  , r = [];
                for (let e = 0, n = t.length; e < n; e++) {
                    s(t[e])
                }
                function s(t) {
                    const s = []
                      , a = void 0 !== e.curveSegments ? e.curveSegments : 12
                      , o = void 0 !== e.steps ? e.steps : 1;
                    let l = void 0 !== e.depth ? e.depth : 100
                      , c = void 0 === e.bevelEnabled || e.bevelEnabled
                      , h = void 0 !== e.bevelThickness ? e.bevelThickness : 6
                      , u = void 0 !== e.bevelSize ? e.bevelSize : h - 2
                      , d = void 0 !== e.bevelOffset ? e.bevelOffset : 0
                      , p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                    const f = e.extrudePath
                      , m = void 0 !== e.UVGenerator ? e.UVGenerator : so;
                    void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
                    l = e.amount);
                    let g, v, y, x, _, w = !1;
                    f && (g = f.getSpacedPoints(o),
                    w = !0,
                    c = !1,
                    v = f.computeFrenetFrames(o, !1),
                    y = new Xt,
                    x = new Xt,
                    _ = new Xt),
                    c || (p = 0,
                    h = 0,
                    u = 0,
                    d = 0);
                    const b = t.extractPoints(a);
                    let M = b.shape;
                    const S = b.holes;
                    if (!eo.isClockWise(M)) {
                        M = M.reverse();
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = S[t];
                            eo.isClockWise(e) && (S[t] = e.reverse())
                        }
                    }
                    const T = eo.triangulateShape(M, S)
                      , E = M;
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        M = M.concat(e)
                    }
                    function L(t, e, n) {
                        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                        e.clone().multiplyScalar(n).add(t)
                    }
                    const A = M.length
                      , C = T.length;
                    function P(t, e, n) {
                        let i, r, s;
                        const a = t.x - e.x
                          , o = t.y - e.y
                          , l = n.x - t.x
                          , c = n.y - t.y
                          , h = a * a + o * o
                          , u = a * c - o * l;
                        if (Math.abs(u) > Number.EPSILON) {
                            const u = Math.sqrt(h)
                              , d = Math.sqrt(l * l + c * c)
                              , p = e.x - o / u
                              , f = e.y + a / u
                              , m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (a * c - o * l);
                            i = p + a * m - t.x,
                            r = f + o * m - t.y;
                            const g = i * i + r * r;
                            if (g <= 2)
                                return new Bt(i,r);
                            s = Math.sqrt(g / 2)
                        } else {
                            let t = !1;
                            a > Number.EPSILON ? l > Number.EPSILON && (t = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(c) && (t = !0),
                            t ? (i = -o,
                            r = a,
                            s = Math.sqrt(h)) : (i = a,
                            r = o,
                            s = Math.sqrt(h / 2))
                        }
                        return new Bt(i / s,r / s)
                    }
                    const R = [];
                    for (let t = 0, e = E.length, n = e - 1, i = t + 1; t < e; t++,
                    n++,
                    i++)
                        n === e && (n = 0),
                        i === e && (i = 0),
                        R[t] = P(E[t], E[n], E[i]);
                    const I = [];
                    let D, N = R.concat();
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        D = [];
                        for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++,
                        i++,
                        r++)
                            i === n && (i = 0),
                            r === n && (r = 0),
                            D[t] = P(e[t], e[i], e[r]);
                        I.push(D),
                        N = N.concat(D)
                    }
                    for (let t = 0; t < p; t++) {
                        const e = t / p
                          , n = h * Math.cos(e * Math.PI / 2)
                          , i = u * Math.sin(e * Math.PI / 2) + d;
                        for (let t = 0, e = E.length; t < e; t++) {
                            const e = L(E[t], R[t], i);
                            B(e.x, e.y, -n)
                        }
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = S[t];
                            D = I[t];
                            for (let t = 0, r = e.length; t < r; t++) {
                                const r = L(e[t], D[t], i);
                                B(r.x, r.y, -n)
                            }
                        }
                    }
                    const O = u + d;
                    for (let t = 0; t < A; t++) {
                        const e = c ? L(M[t], N[t], O) : M[t];
                        w ? (x.copy(v.normals[0]).multiplyScalar(e.x),
                        y.copy(v.binormals[0]).multiplyScalar(e.y),
                        _.copy(g[0]).add(x).add(y),
                        B(_.x, _.y, _.z)) : B(e.x, e.y, 0)
                    }
                    for (let t = 1; t <= o; t++)
                        for (let e = 0; e < A; e++) {
                            const n = c ? L(M[e], N[e], O) : M[e];
                            w ? (x.copy(v.normals[t]).multiplyScalar(n.x),
                            y.copy(v.binormals[t]).multiplyScalar(n.y),
                            _.copy(g[t]).add(x).add(y),
                            B(_.x, _.y, _.z)) : B(n.x, n.y, l / o * t)
                        }
                    for (let t = p - 1; t >= 0; t--) {
                        const e = t / p
                          , n = h * Math.cos(e * Math.PI / 2)
                          , i = u * Math.sin(e * Math.PI / 2) + d;
                        for (let t = 0, e = E.length; t < e; t++) {
                            const e = L(E[t], R[t], i);
                            B(e.x, e.y, l + n)
                        }
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = S[t];
                            D = I[t];
                            for (let t = 0, r = e.length; t < r; t++) {
                                const r = L(e[t], D[t], i);
                                w ? B(r.x, r.y + g[o - 1].y, g[o - 1].x + n) : B(r.x, r.y, l + n)
                            }
                        }
                    }
                    function z(t, e) {
                        let n = t.length;
                        for (; --n >= 0; ) {
                            const i = n;
                            let r = n - 1;
                            r < 0 && (r = t.length - 1);
                            for (let t = 0, n = o + 2 * p; t < n; t++) {
                                const n = A * t
                                  , s = A * (t + 1);
                                F(e + i + n, e + r + n, e + r + s, e + i + s)
                            }
                        }
                    }
                    function B(t, e, n) {
                        s.push(t),
                        s.push(e),
                        s.push(n)
                    }
                    function k(t, e, r) {
                        H(t),
                        H(e),
                        H(r);
                        const s = i.length / 3
                          , a = m.generateTopUV(n, i, s - 3, s - 2, s - 1);
                        U(a[0]),
                        U(a[1]),
                        U(a[2])
                    }
                    function F(t, e, r, s) {
                        H(t),
                        H(e),
                        H(s),
                        H(e),
                        H(r),
                        H(s);
                        const a = i.length / 3
                          , o = m.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
                        U(o[0]),
                        U(o[1]),
                        U(o[3]),
                        U(o[1]),
                        U(o[2]),
                        U(o[3])
                    }
                    function H(t) {
                        i.push(s[3 * t + 0]),
                        i.push(s[3 * t + 1]),
                        i.push(s[3 * t + 2])
                    }
                    function U(t) {
                        r.push(t.x),
                        r.push(t.y)
                    }
                    !function() {
                        const t = i.length / 3;
                        if (c) {
                            let t = 0
                              , e = A * t;
                            for (let t = 0; t < C; t++) {
                                const n = T[t];
                                k(n[2] + e, n[1] + e, n[0] + e)
                            }
                            t = o + 2 * p,
                            e = A * t;
                            for (let t = 0; t < C; t++) {
                                const n = T[t];
                                k(n[0] + e, n[1] + e, n[2] + e)
                            }
                        } else {
                            for (let t = 0; t < C; t++) {
                                const e = T[t];
                                k(e[2], e[1], e[0])
                            }
                            for (let t = 0; t < C; t++) {
                                const e = T[t];
                                k(e[0] + A * o, e[1] + A * o, e[2] + A * o)
                            }
                        }
                        n.addGroup(t, i.length / 3 - t, 0)
                    }(),
                    function() {
                        const t = i.length / 3;
                        let e = 0;
                        z(E, e),
                        e += E.length;
                        for (let t = 0, n = S.length; t < n; t++) {
                            const n = S[t];
                            z(n, e),
                            e += n.length
                        }
                        n.addGroup(t, i.length / 3 - t, 1)
                    }()
                }
                this.setAttribute("position", new Ln(i,3)),
                this.setAttribute("uv", new Ln(r,2)),
                this.computeVertexNormals()
            }
            toJSON() {
                const t = zn.prototype.toJSON.call(this);
                return function(t, e, n) {
                    if (n.shapes = [],
                    Array.isArray(t))
                        for (let e = 0, i = t.length; e < i; e++) {
                            const i = t[e];
                            n.shapes.push(i.uuid)
                        }
                    else
                        n.shapes.push(t.uuid);
                    void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON());
                    return n
                }(this.parameters.shapes, this.parameters.options, t)
            }
        }
        const so = {
            generateTopUV: function(t, e, n, i, r) {
                const s = e[3 * n]
                  , a = e[3 * n + 1]
                  , o = e[3 * i]
                  , l = e[3 * i + 1]
                  , c = e[3 * r]
                  , h = e[3 * r + 1];
                return [new Bt(s,a), new Bt(o,l), new Bt(c,h)]
            },
            generateSideWallUV: function(t, e, n, i, r, s) {
                const a = e[3 * n]
                  , o = e[3 * n + 1]
                  , l = e[3 * n + 2]
                  , c = e[3 * i]
                  , h = e[3 * i + 1]
                  , u = e[3 * i + 2]
                  , d = e[3 * r]
                  , p = e[3 * r + 1]
                  , f = e[3 * r + 2]
                  , m = e[3 * s]
                  , g = e[3 * s + 1]
                  , v = e[3 * s + 2];
                return Math.abs(o - h) < .01 ? [new Bt(a,1 - l), new Bt(c,1 - u), new Bt(d,1 - f), new Bt(m,1 - v)] : [new Bt(o,1 - l), new Bt(h,1 - u), new Bt(p,1 - f), new Bt(g,1 - v)]
            }
        };
        class ao extends zn {
            constructor(t, e=12) {
                super(),
                this.type = "ShapeGeometry",
                this.parameters = {
                    shapes: t,
                    curveSegments: e
                };
                const n = []
                  , i = []
                  , r = []
                  , s = [];
                let a = 0
                  , o = 0;
                if (!1 === Array.isArray(t))
                    l(t);
                else
                    for (let e = 0; e < t.length; e++)
                        l(t[e]),
                        this.addGroup(a, o, e),
                        a += o,
                        o = 0;
                function l(t) {
                    const a = i.length / 3
                      , l = t.extractPoints(e);
                    let c = l.shape;
                    const h = l.holes;
                    !1 === eo.isClockWise(c) && (c = c.reverse());
                    for (let t = 0, e = h.length; t < e; t++) {
                        const e = h[t];
                        !0 === eo.isClockWise(e) && (h[t] = e.reverse())
                    }
                    const u = eo.triangulateShape(c, h);
                    for (let t = 0, e = h.length; t < e; t++) {
                        const e = h[t];
                        c = c.concat(e)
                    }
                    for (let t = 0, e = c.length; t < e; t++) {
                        const e = c[t];
                        i.push(e.x, e.y, 0),
                        r.push(0, 0, 1),
                        s.push(e.x, e.y)
                    }
                    for (let t = 0, e = u.length; t < e; t++) {
                        const e = u[t]
                          , i = e[0] + a
                          , r = e[1] + a
                          , s = e[2] + a;
                        n.push(i, r, s),
                        o += 3
                    }
                }
                this.setIndex(n),
                this.setAttribute("position", new Ln(i,3)),
                this.setAttribute("normal", new Ln(r,3)),
                this.setAttribute("uv", new Ln(s,2))
            }
            toJSON() {
                const t = zn.prototype.toJSON.call(this);
                return function(t, e) {
                    if (e.shapes = [],
                    Array.isArray(t))
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n];
                            e.shapes.push(i.uuid)
                        }
                    else
                        e.shapes.push(t.uuid);
                    return e
                }(this.parameters.shapes, t)
            }
        }
        class oo extends pn {
            constructor(t) {
                super(),
                this.type = "ShadowMaterial",
                this.color = new _n(0),
                this.transparent = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this
            }
        }
        oo.prototype.isShadowMaterial = !0;
        class lo extends ai {
            constructor(t) {
                super(t),
                this.type = "RawShaderMaterial"
            }
        }
        lo.prototype.isRawShaderMaterial = !0;
        class co extends pn {
            constructor(t) {
                super(),
                this.defines = {
                    STANDARD: ""
                },
                this.type = "MeshStandardMaterial",
                this.color = new _n(16777215),
                this.roughness = 1,
                this.metalness = 0,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new _n(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Bt(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.roughnessMap = null,
                this.metalnessMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapIntensity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.flatShading = !1,
                this.vertexTangents = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.defines = {
                    STANDARD: ""
                },
                this.color.copy(t.color),
                this.roughness = t.roughness,
                this.metalness = t.metalness,
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.roughnessMap = t.roughnessMap,
                this.metalnessMap = t.metalnessMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.envMapIntensity = t.envMapIntensity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this.flatShading = t.flatShading,
                this.vertexTangents = t.vertexTangents,
                this
            }
        }
        co.prototype.isMeshStandardMaterial = !0;
        class ho extends co {
            constructor(t) {
                super(),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.type = "MeshPhysicalMaterial",
                this.clearcoat = 0,
                this.clearcoatMap = null,
                this.clearcoatRoughness = 0,
                this.clearcoatRoughnessMap = null,
                this.clearcoatNormalScale = new Bt(1,1),
                this.clearcoatNormalMap = null,
                this.reflectivity = .5,
                Object.defineProperty(this, "ior", {
                    get: function() {
                        return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
                    },
                    set: function(t) {
                        this.reflectivity = Rt(2.5 * (t - 1) / (t + 1), 0, 1)
                    }
                }),
                this.sheen = null,
                this.transmission = 0,
                this.transmissionMap = null,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.clearcoat = t.clearcoat,
                this.clearcoatMap = t.clearcoatMap,
                this.clearcoatRoughness = t.clearcoatRoughness,
                this.clearcoatRoughnessMap = t.clearcoatRoughnessMap,
                this.clearcoatNormalMap = t.clearcoatNormalMap,
                this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
                this.reflectivity = t.reflectivity,
                t.sheen ? this.sheen = (this.sheen || new _n).copy(t.sheen) : this.sheen = null,
                this.transmission = t.transmission,
                this.transmissionMap = t.transmissionMap,
                this
            }
        }
        ho.prototype.isMeshPhysicalMaterial = !0;
        class uo extends pn {
            constructor(t) {
                super(),
                this.type = "MeshPhongMaterial",
                this.color = new _n(16777215),
                this.specular = new _n(1118481),
                this.shininess = 30,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new _n(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Bt(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = 0,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.flatShading = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.specular.copy(t.specular),
                this.shininess = t.shininess,
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this.flatShading = t.flatShading,
                this
            }
        }
        uo.prototype.isMeshPhongMaterial = !0;
        class po extends pn {
            constructor(t) {
                super(),
                this.defines = {
                    TOON: ""
                },
                this.type = "MeshToonMaterial",
                this.color = new _n(16777215),
                this.map = null,
                this.gradientMap = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new _n(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Bt(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.gradientMap = t.gradientMap,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.alphaMap = t.alphaMap,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this
            }
        }
        po.prototype.isMeshToonMaterial = !0;
        class fo extends pn {
            constructor(t) {
                super(),
                this.type = "MeshNormalMaterial",
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Bt(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.flatShading = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this.flatShading = t.flatShading,
                this
            }
        }
        fo.prototype.isMeshNormalMaterial = !0;
        class mo extends pn {
            constructor(t) {
                super(),
                this.type = "MeshLambertMaterial",
                this.color = new _n(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new _n(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = 0,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this
            }
        }
        mo.prototype.isMeshLambertMaterial = !0;
        class go extends pn {
            constructor(t) {
                super(),
                this.defines = {
                    MATCAP: ""
                },
                this.type = "MeshMatcapMaterial",
                this.color = new _n(16777215),
                this.matcap = null,
                this.map = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Bt(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.skinning = !1,
                this.morphTargets = !1,
                this.morphNormals = !1,
                this.flatShading = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.defines = {
                    MATCAP: ""
                },
                this.color.copy(t.color),
                this.matcap = t.matcap,
                this.map = t.map,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.alphaMap = t.alphaMap,
                this.skinning = t.skinning,
                this.morphTargets = t.morphTargets,
                this.morphNormals = t.morphNormals,
                this.flatShading = t.flatShading,
                this
            }
        }
        go.prototype.isMeshMatcapMaterial = !0;
        class vo extends ua {
            constructor(t) {
                super(),
                this.type = "LineDashedMaterial",
                this.scale = 1,
                this.dashSize = 3,
                this.gapSize = 1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.scale = t.scale,
                this.dashSize = t.dashSize,
                this.gapSize = t.gapSize,
                this
            }
        }
        vo.prototype.isLineDashedMaterial = !0;
        const yo = {
            arraySlice: function(t, e, n) {
                return yo.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
            },
            convertArray: function(t, e, n) {
                return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function(t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            },
            getKeyframeOrder: function(t) {
                const e = t.length
                  , n = new Array(e);
                for (let t = 0; t !== e; ++t)
                    n[t] = t;
                return n.sort((function(e, n) {
                    return t[e] - t[n]
                }
                )),
                n
            },
            sortedArray: function(t, e, n) {
                const i = t.length
                  , r = new t.constructor(i);
                for (let s = 0, a = 0; a !== i; ++s) {
                    const i = n[s] * e;
                    for (let n = 0; n !== e; ++n)
                        r[a++] = t[i + n]
                }
                return r
            },
            flattenJSON: function(t, e, n, i) {
                let r = 1
                  , s = t[0];
                for (; void 0 !== s && void 0 === s[i]; )
                    s = t[r++];
                if (void 0 === s)
                    return;
                let a = s[i];
                if (void 0 !== a)
                    if (Array.isArray(a))
                        do {
                            a = s[i],
                            void 0 !== a && (e.push(s.time),
                            n.push.apply(n, a)),
                            s = t[r++]
                        } while (void 0 !== s);
                    else if (void 0 !== a.toArray)
                        do {
                            a = s[i],
                            void 0 !== a && (e.push(s.time),
                            a.toArray(n, n.length)),
                            s = t[r++]
                        } while (void 0 !== s);
                    else
                        do {
                            a = s[i],
                            void 0 !== a && (e.push(s.time),
                            n.push(a)),
                            s = t[r++]
                        } while (void 0 !== s)
            },
            subclip: function(t, e, n, i, r=30) {
                const s = t.clone();
                s.name = e;
                const a = [];
                for (let t = 0; t < s.tracks.length; ++t) {
                    const e = s.tracks[t]
                      , o = e.getValueSize()
                      , l = []
                      , c = [];
                    for (let t = 0; t < e.times.length; ++t) {
                        const s = e.times[t] * r;
                        if (!(s < n || s >= i)) {
                            l.push(e.times[t]);
                            for (let n = 0; n < o; ++n)
                                c.push(e.values[t * o + n])
                        }
                    }
                    0 !== l.length && (e.times = yo.convertArray(l, e.times.constructor),
                    e.values = yo.convertArray(c, e.values.constructor),
                    a.push(e))
                }
                s.tracks = a;
                let o = 1 / 0;
                for (let t = 0; t < s.tracks.length; ++t)
                    o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);
                for (let t = 0; t < s.tracks.length; ++t)
                    s.tracks[t].shift(-1 * o);
                return s.resetDuration(),
                s
            },
            makeClipAdditive: function(t, e=0, n=t, i=30) {
                i <= 0 && (i = 30);
                const r = n.tracks.length
                  , s = e / i;
                for (let e = 0; e < r; ++e) {
                    const i = n.tracks[e]
                      , r = i.ValueTypeName;
                    if ("bool" === r || "string" === r)
                        continue;
                    const a = t.tracks.find((function(t) {
                        return t.name === i.name && t.ValueTypeName === r
                    }
                    ));
                    if (void 0 === a)
                        continue;
                    let o = 0;
                    const l = i.getValueSize();
                    i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
                    let c = 0;
                    const h = a.getValueSize();
                    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                    const u = i.times.length - 1;
                    let d;
                    if (s <= i.times[0]) {
                        const t = o
                          , e = l - o;
                        d = yo.arraySlice(i.values, t, e)
                    } else if (s >= i.times[u]) {
                        const t = u * l + o
                          , e = t + l - o;
                        d = yo.arraySlice(i.values, t, e)
                    } else {
                        const t = i.createInterpolant()
                          , e = o
                          , n = l - o;
                        t.evaluate(s),
                        d = yo.arraySlice(t.resultBuffer, e, n)
                    }
                    if ("quaternion" === r) {
                        (new qt).fromArray(d).normalize().conjugate().toArray(d)
                    }
                    const p = a.times.length;
                    for (let t = 0; t < p; ++t) {
                        const e = t * h + c;
                        if ("quaternion" === r)
                            qt.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
                        else {
                            const t = h - 2 * c;
                            for (let n = 0; n < t; ++n)
                                a.values[e + n] -= d[n]
                        }
                    }
                }
                return t.blendMode = 2501,
                t
            }
        };
        class xo {
            constructor(t, e, n, i) {
                this.parameterPositions = t,
                this._cachedIndex = 0,
                this.resultBuffer = void 0 !== i ? i : new e.constructor(n),
                this.sampleValues = e,
                this.valueSize = n,
                this.settings = null,
                this.DefaultSettings_ = {}
            }
            evaluate(t) {
                const e = this.parameterPositions;
                let n = this._cachedIndex
                  , i = e[n]
                  , r = e[n - 1];
                t: {
                    e: {
                        let s;
                        n: {
                            i: if (!(t < i)) {
                                for (let s = n + 2; ; ) {
                                    if (void 0 === i) {
                                        if (t < r)
                                            break i;
                                        return n = e.length,
                                        this._cachedIndex = n,
                                        this.afterEnd_(n - 1, t, r)
                                    }
                                    if (n === s)
                                        break;
                                    if (r = i,
                                    i = e[++n],
                                    t < i)
                                        break e
                                }
                                s = e.length;
                                break n
                            }
                            if (t >= r)
                                break t;
                            {
                                const a = e[1];
                                t < a && (n = 2,
                                r = a);
                                for (let s = n - 2; ; ) {
                                    if (void 0 === r)
                                        return this._cachedIndex = 0,
                                        this.beforeStart_(0, t, i);
                                    if (n === s)
                                        break;
                                    if (i = r,
                                    r = e[--n - 1],
                                    t >= r)
                                        break e
                                }
                                s = n,
                                n = 0
                            }
                        }
                        for (; n < s; ) {
                            const i = n + s >>> 1;
                            t < e[i] ? s = i : n = i + 1
                        }
                        if (i = e[n],
                        r = e[n - 1],
                        void 0 === r)
                            return this._cachedIndex = 0,
                            this.beforeStart_(0, t, i);
                        if (void 0 === i)
                            return n = e.length,
                            this._cachedIndex = n,
                            this.afterEnd_(n - 1, r, t)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, t, i)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(t) {
                const e = this.resultBuffer
                  , n = this.sampleValues
                  , i = this.valueSize
                  , r = t * i;
                for (let t = 0; t !== i; ++t)
                    e[t] = n[r + t];
                return e
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        xo.prototype.beforeStart_ = xo.prototype.copySampleValue_,
        xo.prototype.afterEnd_ = xo.prototype.copySampleValue_;
        class _o extends xo {
            constructor(t, e, n, i) {
                super(t, e, n, i),
                this._weightPrev = -0,
                this._offsetPrev = -0,
                this._weightNext = -0,
                this._offsetNext = -0,
                this.DefaultSettings_ = {
                    endingStart: 2400,
                    endingEnd: 2400
                }
            }
            intervalChanged_(t, e, n) {
                const i = this.parameterPositions;
                let r = t - 2
                  , s = t + 1
                  , a = i[r]
                  , o = i[s];
                if (void 0 === a)
                    switch (this.getSettings_().endingStart) {
                    case 2401:
                        r = t,
                        a = 2 * e - n;
                        break;
                    case 2402:
                        r = i.length - 2,
                        a = e + i[r] - i[r + 1];
                        break;
                    default:
                        r = t,
                        a = n
                    }
                if (void 0 === o)
                    switch (this.getSettings_().endingEnd) {
                    case 2401:
                        s = t,
                        o = 2 * n - e;
                        break;
                    case 2402:
                        s = 1,
                        o = n + i[1] - i[0];
                        break;
                    default:
                        s = t - 1,
                        o = e
                    }
                const l = .5 * (n - e)
                  , c = this.valueSize;
                this._weightPrev = l / (e - a),
                this._weightNext = l / (o - n),
                this._offsetPrev = r * c,
                this._offsetNext = s * c
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , a = this.valueSize
                  , o = t * a
                  , l = o - a
                  , c = this._offsetPrev
                  , h = this._offsetNext
                  , u = this._weightPrev
                  , d = this._weightNext
                  , p = (n - e) / (i - e)
                  , f = p * p
                  , m = f * p
                  , g = -u * m + 2 * u * f - u * p
                  , v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1
                  , y = (-1 - d) * m + (1.5 + d) * f + .5 * p
                  , x = d * m - d * f;
                for (let t = 0; t !== a; ++t)
                    r[t] = g * s[c + t] + v * s[l + t] + y * s[o + t] + x * s[h + t];
                return r
            }
        }
        class wo extends xo {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , a = this.valueSize
                  , o = t * a
                  , l = o - a
                  , c = (n - e) / (i - e)
                  , h = 1 - c;
                for (let t = 0; t !== a; ++t)
                    r[t] = s[l + t] * h + s[o + t] * c;
                return r
            }
        }
        class bo extends xo {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t) {
                return this.copySampleValue_(t - 1)
            }
        }
        class Mo {
            constructor(t, e, n, i) {
                if (void 0 === t)
                    throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length)
                    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t,
                this.times = yo.convertArray(e, this.TimeBufferType),
                this.values = yo.convertArray(n, this.ValueBufferType),
                this.setInterpolation(i || this.DefaultInterpolation)
            }
            static toJSON(t) {
                const e = t.constructor;
                let n;
                if (e.toJSON !== this.toJSON)
                    n = e.toJSON(t);
                else {
                    n = {
                        name: t.name,
                        times: yo.convertArray(t.times, Array),
                        values: yo.convertArray(t.values, Array)
                    };
                    const e = t.getInterpolation();
                    e !== t.DefaultInterpolation && (n.interpolation = e)
                }
                return n.type = t.ValueTypeName,
                n
            }
            InterpolantFactoryMethodDiscrete(t) {
                return new bo(this.times,this.values,this.getValueSize(),t)
            }
            InterpolantFactoryMethodLinear(t) {
                return new wo(this.times,this.values,this.getValueSize(),t)
            }
            InterpolantFactoryMethodSmooth(t) {
                return new _o(this.times,this.values,this.getValueSize(),t)
            }
            setInterpolation(t) {
                let e;
                switch (t) {
                case 2300:
                    e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case 2301:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation)
                            throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e),
                    this
                }
                return this.createInterpolant = e,
                this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return 2300;
                case this.InterpolantFactoryMethodLinear:
                    return 2301;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n)
                        e[n] += t
                }
                return this
            }
            scale(t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n)
                        e[n] *= t
                }
                return this
            }
            trim(t, e) {
                const n = this.times
                  , i = n.length;
                let r = 0
                  , s = i - 1;
                for (; r !== i && n[r] < t; )
                    ++r;
                for (; -1 !== s && n[s] > e; )
                    --s;
                if (++s,
                0 !== r || s !== i) {
                    r >= s && (s = Math.max(s, 1),
                    r = s - 1);
                    const t = this.getValueSize();
                    this.times = yo.arraySlice(n, r, s),
                    this.values = yo.arraySlice(this.values, r * t, s * t)
                }
                return this
            }
            validate() {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                t = !1);
                const n = this.times
                  , i = this.values
                  , r = n.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                t = !1);
                let s = null;
                for (let e = 0; e !== r; e++) {
                    const i = n[e];
                    if ("number" == typeof i && isNaN(i)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i),
                        t = !1;
                        break
                    }
                    if (null !== s && s > i) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s),
                        t = !1;
                        break
                    }
                    s = i
                }
                if (void 0 !== i && yo.isTypedArray(i))
                    for (let e = 0, n = i.length; e !== n; ++e) {
                        const n = i[e];
                        if (isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n),
                            t = !1;
                            break
                        }
                    }
                return t
            }
            optimize() {
                const t = yo.arraySlice(this.times)
                  , e = yo.arraySlice(this.values)
                  , n = this.getValueSize()
                  , i = 2302 === this.getInterpolation()
                  , r = t.length - 1;
                let s = 1;
                for (let a = 1; a < r; ++a) {
                    let r = !1;
                    const o = t[a];
                    if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                        if (i)
                            r = !0;
                        else {
                            const t = a * n
                              , i = t - n
                              , s = t + n;
                            for (let a = 0; a !== n; ++a) {
                                const n = e[t + a];
                                if (n !== e[i + a] || n !== e[s + a]) {
                                    r = !0;
                                    break
                                }
                            }
                        }
                    if (r) {
                        if (a !== s) {
                            t[s] = t[a];
                            const i = a * n
                              , r = s * n;
                            for (let t = 0; t !== n; ++t)
                                e[r + t] = e[i + t]
                        }
                        ++s
                    }
                }
                if (r > 0) {
                    t[s] = t[r];
                    for (let t = r * n, i = s * n, a = 0; a !== n; ++a)
                        e[i + a] = e[t + a];
                    ++s
                }
                return s !== t.length ? (this.times = yo.arraySlice(t, 0, s),
                this.values = yo.arraySlice(e, 0, s * n)) : (this.times = t,
                this.values = e),
                this
            }
            clone() {
                const t = yo.arraySlice(this.times, 0)
                  , e = yo.arraySlice(this.values, 0)
                  , n = new (0,
                this.constructor)(this.name,t,e);
                return n.createInterpolant = this.createInterpolant,
                n
            }
        }
        Mo.prototype.TimeBufferType = Float32Array,
        Mo.prototype.ValueBufferType = Float32Array,
        Mo.prototype.DefaultInterpolation = 2301;
        class So extends Mo {
        }
        So.prototype.ValueTypeName = "bool",
        So.prototype.ValueBufferType = Array,
        So.prototype.DefaultInterpolation = 2300,
        So.prototype.InterpolantFactoryMethodLinear = void 0,
        So.prototype.InterpolantFactoryMethodSmooth = void 0;
        class To extends Mo {
        }
        To.prototype.ValueTypeName = "color";
        class Eo extends Mo {
        }
        Eo.prototype.ValueTypeName = "number";
        class Lo extends xo {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , a = this.valueSize
                  , o = (n - e) / (i - e);
                let l = t * a;
                for (let t = l + a; l !== t; l += 4)
                    qt.slerpFlat(r, 0, s, l - a, s, l, o);
                return r
            }
        }
        class Ao extends Mo {
            InterpolantFactoryMethodLinear(t) {
                return new Lo(this.times,this.values,this.getValueSize(),t)
            }
        }
        Ao.prototype.ValueTypeName = "quaternion",
        Ao.prototype.DefaultInterpolation = 2301,
        Ao.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Co extends Mo {
        }
        Co.prototype.ValueTypeName = "string",
        Co.prototype.ValueBufferType = Array,
        Co.prototype.DefaultInterpolation = 2300,
        Co.prototype.InterpolantFactoryMethodLinear = void 0,
        Co.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Po extends Mo {
        }
        Po.prototype.ValueTypeName = "vector";
        class Ro {
            constructor(t, e=-1, n, i=2500) {
                this.name = t,
                this.tracks = n,
                this.duration = e,
                this.blendMode = i,
                this.uuid = Pt(),
                this.duration < 0 && this.resetDuration()
            }
            static parse(t) {
                const e = []
                  , n = t.tracks
                  , i = 1 / (t.fps || 1);
                for (let t = 0, r = n.length; t !== r; ++t)
                    e.push(Io(n[t]).scale(i));
                const r = new this(t.name,t.duration,e,t.blendMode);
                return r.uuid = t.uuid,
                r
            }
            static toJSON(t) {
                const e = []
                  , n = t.tracks
                  , i = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e,
                    uuid: t.uuid,
                    blendMode: t.blendMode
                };
                for (let t = 0, i = n.length; t !== i; ++t)
                    e.push(Mo.toJSON(n[t]));
                return i
            }
            static CreateFromMorphTargetSequence(t, e, n, i) {
                const r = e.length
                  , s = [];
                for (let t = 0; t < r; t++) {
                    let a = []
                      , o = [];
                    a.push((t + r - 1) % r, t, (t + 1) % r),
                    o.push(0, 1, 0);
                    const l = yo.getKeyframeOrder(a);
                    a = yo.sortedArray(a, 1, l),
                    o = yo.sortedArray(o, 1, l),
                    i || 0 !== a[0] || (a.push(r),
                    o.push(o[0])),
                    s.push(new Eo(".morphTargetInfluences[" + e[t].name + "]",a,o).scale(1 / n))
                }
                return new this(t,-1,s)
            }
            static findByName(t, e) {
                let n = t;
                if (!Array.isArray(t)) {
                    const e = t;
                    n = e.geometry && e.geometry.animations || e.animations
                }
                for (let t = 0; t < n.length; t++)
                    if (n[t].name === e)
                        return n[t];
                return null
            }
            static CreateClipsFromMorphTargetSequences(t, e, n) {
                const i = {}
                  , r = /^([\w-]*?)([\d]+)$/;
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e]
                      , s = n.name.match(r);
                    if (s && s.length > 1) {
                        const t = s[1];
                        let e = i[t];
                        e || (i[t] = e = []),
                        e.push(n)
                    }
                }
                const s = [];
                for (const t in i)
                    s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
                return s
            }
            static parseAnimation(t, e) {
                if (!t)
                    return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                    null;
                const n = function(t, e, n, i, r) {
                    if (0 !== n.length) {
                        const s = []
                          , a = [];
                        yo.flattenJSON(n, s, a, i),
                        0 !== s.length && r.push(new t(e,s,a))
                    }
                }
                  , i = []
                  , r = t.name || "default"
                  , s = t.fps || 30
                  , a = t.blendMode;
                let o = t.length || -1;
                const l = t.hierarchy || [];
                for (let t = 0; t < l.length; t++) {
                    const r = l[t].keys;
                    if (r && 0 !== r.length)
                        if (r[0].morphTargets) {
                            const t = {};
                            let e;
                            for (e = 0; e < r.length; e++)
                                if (r[e].morphTargets)
                                    for (let n = 0; n < r[e].morphTargets.length; n++)
                                        t[r[e].morphTargets[n]] = -1;
                            for (const n in t) {
                                const t = []
                                  , s = [];
                                for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                    const i = r[e];
                                    t.push(i.time),
                                    s.push(i.morphTarget === n ? 1 : 0)
                                }
                                i.push(new Eo(".morphTargetInfluence[" + n + "]",t,s))
                            }
                            o = t.length * (s || 1)
                        } else {
                            const s = ".bones[" + e[t].name + "]";
                            n(Po, s + ".position", r, "pos", i),
                            n(Ao, s + ".quaternion", r, "rot", i),
                            n(Po, s + ".scale", r, "scl", i)
                        }
                }
                if (0 === i.length)
                    return null;
                return new this(r,o,i,a)
            }
            resetDuration() {
                let t = 0;
                for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                    const n = this.tracks[e];
                    t = Math.max(t, n.times[n.times.length - 1])
                }
                return this.duration = t,
                this
            }
            trim() {
                for (let t = 0; t < this.tracks.length; t++)
                    this.tracks[t].trim(0, this.duration);
                return this
            }
            validate() {
                let t = !0;
                for (let e = 0; e < this.tracks.length; e++)
                    t = t && this.tracks[e].validate();
                return t
            }
            optimize() {
                for (let t = 0; t < this.tracks.length; t++)
                    this.tracks[t].optimize();
                return this
            }
            clone() {
                const t = [];
                for (let e = 0; e < this.tracks.length; e++)
                    t.push(this.tracks[e].clone());
                return new this.constructor(this.name,this.duration,t,this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }
        function Io(t) {
            if (void 0 === t.type)
                throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = function(t) {
                switch (t.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return Eo;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return Po;
                case "color":
                    return To;
                case "quaternion":
                    return Ao;
                case "bool":
                case "boolean":
                    return So;
                case "string":
                    return Co
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            if (void 0 === t.times) {
                const e = []
                  , n = [];
                yo.flattenJSON(t.keys, e, n, "value"),
                t.times = e,
                t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name,t.times,t.values,t.interpolation)
        }
        const Do = {
            enabled: !1,
            files: {},
            add: function(t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function(t) {
                if (!1 !== this.enabled)
                    return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        };
        class No {
            constructor(t, e, n) {
                const i = this;
                let r = !1
                  , s = 0
                  , a = 0
                  , o = void 0;
                const l = [];
                this.onStart = void 0,
                this.onLoad = t,
                this.onProgress = e,
                this.onError = n,
                this.itemStart = function(t) {
                    a++,
                    !1 === r && void 0 !== i.onStart && i.onStart(t, s, a),
                    r = !0
                }
                ,
                this.itemEnd = function(t) {
                    s++,
                    void 0 !== i.onProgress && i.onProgress(t, s, a),
                    s === a && (r = !1,
                    void 0 !== i.onLoad && i.onLoad())
                }
                ,
                this.itemError = function(t) {
                    void 0 !== i.onError && i.onError(t)
                }
                ,
                this.resolveURL = function(t) {
                    return o ? o(t) : t
                }
                ,
                this.setURLModifier = function(t) {
                    return o = t,
                    this
                }
                ,
                this.addHandler = function(t, e) {
                    return l.push(t, e),
                    this
                }
                ,
                this.removeHandler = function(t) {
                    const e = l.indexOf(t);
                    return -1 !== e && l.splice(e, 2),
                    this
                }
                ,
                this.getHandler = function(t) {
                    for (let e = 0, n = l.length; e < n; e += 2) {
                        const n = l[e]
                          , i = l[e + 1];
                        if (n.global && (n.lastIndex = 0),
                        n.test(t))
                            return i
                    }
                    return null
                }
            }
        }
        const Oo = new No;
        class zo {
            constructor(t) {
                this.manager = void 0 !== t ? t : Oo,
                this.crossOrigin = "anonymous",
                this.withCredentials = !1,
                this.path = "",
                this.resourcePath = "",
                this.requestHeader = {}
            }
            load() {}
            loadAsync(t, e) {
                const n = this;
                return new Promise((function(i, r) {
                    n.load(t, i, e, r)
                }
                ))
            }
            parse() {}
            setCrossOrigin(t) {
                return this.crossOrigin = t,
                this
            }
            setWithCredentials(t) {
                return this.withCredentials = t,
                this
            }
            setPath(t) {
                return this.path = t,
                this
            }
            setResourcePath(t) {
                return this.resourcePath = t,
                this
            }
            setRequestHeader(t) {
                return this.requestHeader = t,
                this
            }
        }
        const Bo = {};
        class ko extends zo {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                void 0 === t && (t = ""),
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const r = this
                  , s = Do.get(t);
                if (void 0 !== s)
                    return r.manager.itemStart(t),
                    setTimeout((function() {
                        e && e(s),
                        r.manager.itemEnd(t)
                    }
                    ), 0),
                    s;
                if (void 0 !== Bo[t])
                    return void Bo[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    });
                const a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                let o;
                if (a) {
                    const n = a[1]
                      , s = !!a[2];
                    let o = a[3];
                    o = decodeURIComponent(o),
                    s && (o = atob(o));
                    try {
                        let i;
                        const s = (this.responseType || "").toLowerCase();
                        switch (s) {
                        case "arraybuffer":
                        case "blob":
                            const t = new Uint8Array(o.length);
                            for (let e = 0; e < o.length; e++)
                                t[e] = o.charCodeAt(e);
                            i = "blob" === s ? new Blob([t.buffer],{
                                type: n
                            }) : t.buffer;
                            break;
                        case "document":
                            const e = new DOMParser;
                            i = e.parseFromString(o, n);
                            break;
                        case "json":
                            i = JSON.parse(o);
                            break;
                        default:
                            i = o
                        }
                        setTimeout((function() {
                            e && e(i),
                            r.manager.itemEnd(t)
                        }
                        ), 0)
                    } catch (e) {
                        setTimeout((function() {
                            i && i(e),
                            r.manager.itemError(t),
                            r.manager.itemEnd(t)
                        }
                        ), 0)
                    }
                } else {
                    Bo[t] = [],
                    Bo[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    }),
                    o = new XMLHttpRequest,
                    o.open("GET", t, !0),
                    o.addEventListener("load", (function(e) {
                        const n = this.response
                          , i = Bo[t];
                        if (delete Bo[t],
                        200 === this.status || 0 === this.status) {
                            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                            Do.add(t, n);
                            for (let t = 0, e = i.length; t < e; t++) {
                                const e = i[t];
                                e.onLoad && e.onLoad(n)
                            }
                            r.manager.itemEnd(t)
                        } else {
                            for (let t = 0, n = i.length; t < n; t++) {
                                const n = i[t];
                                n.onError && n.onError(e)
                            }
                            r.manager.itemError(t),
                            r.manager.itemEnd(t)
                        }
                    }
                    ), !1),
                    o.addEventListener("progress", (function(e) {
                        const n = Bo[t];
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            i.onProgress && i.onProgress(e)
                        }
                    }
                    ), !1),
                    o.addEventListener("error", (function(e) {
                        const n = Bo[t];
                        delete Bo[t];
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            i.onError && i.onError(e)
                        }
                        r.manager.itemError(t),
                        r.manager.itemEnd(t)
                    }
                    ), !1),
                    o.addEventListener("abort", (function(e) {
                        const n = Bo[t];
                        delete Bo[t];
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            i.onError && i.onError(e)
                        }
                        r.manager.itemError(t),
                        r.manager.itemEnd(t)
                    }
                    ), !1),
                    void 0 !== this.responseType && (o.responseType = this.responseType),
                    void 0 !== this.withCredentials && (o.withCredentials = this.withCredentials),
                    o.overrideMimeType && o.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                    for (const t in this.requestHeader)
                        o.setRequestHeader(t, this.requestHeader[t]);
                    o.send(null)
                }
                return r.manager.itemStart(t),
                o
            }
            setResponseType(t) {
                return this.responseType = t,
                this
            }
            setMimeType(t) {
                return this.mimeType = t,
                this
            }
        }
        class Fo extends zo {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const r = this
                  , s = Do.get(t);
                if (void 0 !== s)
                    return r.manager.itemStart(t),
                    setTimeout((function() {
                        e && e(s),
                        r.manager.itemEnd(t)
                    }
                    ), 0),
                    s;
                const a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                function o() {
                    a.removeEventListener("load", o, !1),
                    a.removeEventListener("error", l, !1),
                    Do.add(t, this),
                    e && e(this),
                    r.manager.itemEnd(t)
                }
                function l(e) {
                    a.removeEventListener("load", o, !1),
                    a.removeEventListener("error", l, !1),
                    i && i(e),
                    r.manager.itemError(t),
                    r.manager.itemEnd(t)
                }
                return a.addEventListener("load", o, !1),
                a.addEventListener("error", l, !1),
                "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
                r.manager.itemStart(t),
                a.src = t,
                a
            }
        }
        class Ho extends zo {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                const r = new hi
                  , s = new Fo(this.manager);
                s.setCrossOrigin(this.crossOrigin),
                s.setPath(this.path);
                let a = 0;
                function o(n) {
                    s.load(t[n], (function(t) {
                        r.images[n] = t,
                        a++,
                        6 === a && (r.needsUpdate = !0,
                        e && e(r))
                    }
                    ), void 0, i)
                }
                for (let e = 0; e < t.length; ++e)
                    o(e);
                return r
            }
        }
        class Uo extends zo {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                const r = new Gt
                  , s = new Fo(this.manager);
                return s.setCrossOrigin(this.crossOrigin),
                s.setPath(this.path),
                s.load(t, (function(n) {
                    r.image = n;
                    const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                    r.format = i ? 1022 : 1023,
                    r.needsUpdate = !0,
                    void 0 !== e && e(r)
                }
                ), n, i),
                r
            }
        }
        class Go {
            constructor() {
                this.type = "Curve",
                this.arcLengthDivisions = 200
            }
            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."),
                null
            }
            getPointAt(t, e) {
                const n = this.getUtoTmapping(t);
                return this.getPoint(n, e)
            }
            getPoints(t=5) {
                const e = [];
                for (let n = 0; n <= t; n++)
                    e.push(this.getPoint(n / t));
                return e
            }
            getSpacedPoints(t=5) {
                const e = [];
                for (let n = 0; n <= t; n++)
                    e.push(this.getPointAt(n / t));
                return e
            }
            getLength() {
                const t = this.getLengths();
                return t[t.length - 1]
            }
            getLengths(t=this.arcLengthDivisions) {
                if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                    return this.cacheArcLengths;
                this.needsUpdate = !1;
                const e = [];
                let n, i = this.getPoint(0), r = 0;
                e.push(0);
                for (let s = 1; s <= t; s++)
                    n = this.getPoint(s / t),
                    r += n.distanceTo(i),
                    e.push(r),
                    i = n;
                return this.cacheArcLengths = e,
                e
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.getLengths()
            }
            getUtoTmapping(t, e) {
                const n = this.getLengths();
                let i = 0;
                const r = n.length;
                let s;
                s = e || t * n[r - 1];
                let a, o = 0, l = r - 1;
                for (; o <= l; )
                    if (i = Math.floor(o + (l - o) / 2),
                    a = n[i] - s,
                    a < 0)
                        o = i + 1;
                    else {
                        if (!(a > 0)) {
                            l = i;
                            break
                        }
                        l = i - 1
                    }
                if (i = l,
                n[i] === s)
                    return i / (r - 1);
                const c = n[i];
                return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
            }
            getTangent(t, e) {
                let n = t - 1e-4
                  , i = t + 1e-4;
                n < 0 && (n = 0),
                i > 1 && (i = 1);
                const r = this.getPoint(n)
                  , s = this.getPoint(i)
                  , a = e || (r.isVector2 ? new Bt : new Xt);
                return a.copy(s).sub(r).normalize(),
                a
            }
            getTangentAt(t, e) {
                const n = this.getUtoTmapping(t);
                return this.getTangent(n, e)
            }
            computeFrenetFrames(t, e) {
                const n = new Xt
                  , i = []
                  , r = []
                  , s = []
                  , a = new Xt
                  , o = new Se;
                for (let e = 0; e <= t; e++) {
                    const n = e / t;
                    i[e] = this.getTangentAt(n, new Xt),
                    i[e].normalize()
                }
                r[0] = new Xt,
                s[0] = new Xt;
                let l = Number.MAX_VALUE;
                const c = Math.abs(i[0].x)
                  , h = Math.abs(i[0].y)
                  , u = Math.abs(i[0].z);
                c <= l && (l = c,
                n.set(1, 0, 0)),
                h <= l && (l = h,
                n.set(0, 1, 0)),
                u <= l && n.set(0, 0, 1),
                a.crossVectors(i[0], n).normalize(),
                r[0].crossVectors(i[0], a),
                s[0].crossVectors(i[0], r[0]);
                for (let e = 1; e <= t; e++) {
                    if (r[e] = r[e - 1].clone(),
                    s[e] = s[e - 1].clone(),
                    a.crossVectors(i[e - 1], i[e]),
                    a.length() > Number.EPSILON) {
                        a.normalize();
                        const t = Math.acos(Rt(i[e - 1].dot(i[e]), -1, 1));
                        r[e].applyMatrix4(o.makeRotationAxis(a, t))
                    }
                    s[e].crossVectors(i[e], r[e])
                }
                if (!0 === e) {
                    let e = Math.acos(Rt(r[0].dot(r[t]), -1, 1));
                    e /= t,
                    i[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
                    for (let n = 1; n <= t; n++)
                        r[n].applyMatrix4(o.makeRotationAxis(i[n], e * n)),
                        s[n].crossVectors(i[n], r[n])
                }
                return {
                    tangents: i,
                    normals: r,
                    binormals: s
                }
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions,
                this
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return t.arcLengthDivisions = this.arcLengthDivisions,
                t.type = this.type,
                t
            }
            fromJSON(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions,
                this
            }
        }
        class Vo extends Go {
            constructor(t=0, e=0, n=1, i=1, r=0, s=2 * Math.PI, a=!1, o=0) {
                super(),
                this.type = "EllipseCurve",
                this.aX = t,
                this.aY = e,
                this.xRadius = n,
                this.yRadius = i,
                this.aStartAngle = r,
                this.aEndAngle = s,
                this.aClockwise = a,
                this.aRotation = o
            }
            getPoint(t, e) {
                const n = e || new Bt
                  , i = 2 * Math.PI;
                let r = this.aEndAngle - this.aStartAngle;
                const s = Math.abs(r) < Number.EPSILON;
                for (; r < 0; )
                    r += i;
                for (; r > i; )
                    r -= i;
                r < Number.EPSILON && (r = s ? 0 : i),
                !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
                const a = this.aStartAngle + t * r;
                let o = this.aX + this.xRadius * Math.cos(a)
                  , l = this.aY + this.yRadius * Math.sin(a);
                if (0 !== this.aRotation) {
                    const t = Math.cos(this.aRotation)
                      , e = Math.sin(this.aRotation)
                      , n = o - this.aX
                      , i = l - this.aY;
                    o = n * t - i * e + this.aX,
                    l = n * e + i * t + this.aY
                }
                return n.set(o, l)
            }
            copy(t) {
                return super.copy(t),
                this.aX = t.aX,
                this.aY = t.aY,
                this.xRadius = t.xRadius,
                this.yRadius = t.yRadius,
                this.aStartAngle = t.aStartAngle,
                this.aEndAngle = t.aEndAngle,
                this.aClockwise = t.aClockwise,
                this.aRotation = t.aRotation,
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.aX = this.aX,
                t.aY = this.aY,
                t.xRadius = this.xRadius,
                t.yRadius = this.yRadius,
                t.aStartAngle = this.aStartAngle,
                t.aEndAngle = this.aEndAngle,
                t.aClockwise = this.aClockwise,
                t.aRotation = this.aRotation,
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.aX = t.aX,
                this.aY = t.aY,
                this.xRadius = t.xRadius,
                this.yRadius = t.yRadius,
                this.aStartAngle = t.aStartAngle,
                this.aEndAngle = t.aEndAngle,
                this.aClockwise = t.aClockwise,
                this.aRotation = t.aRotation,
                this
            }
        }
        Vo.prototype.isEllipseCurve = !0;
        class Wo extends Vo {
            constructor(t, e, n, i, r, s) {
                super(t, e, n, n, i, r, s),
                this.type = "ArcCurve"
            }
        }
        function jo() {
            let t = 0
              , e = 0
              , n = 0
              , i = 0;
            function r(r, s, a, o) {
                t = r,
                e = a,
                n = -3 * r + 3 * s - 2 * a - o,
                i = 2 * r - 2 * s + a + o
            }
            return {
                initCatmullRom: function(t, e, n, i, s) {
                    r(e, n, s * (n - t), s * (i - e))
                },
                initNonuniformCatmullRom: function(t, e, n, i, s, a, o) {
                    let l = (e - t) / s - (n - t) / (s + a) + (n - e) / a
                      , c = (n - e) / a - (i - e) / (a + o) + (i - n) / o;
                    l *= a,
                    c *= a,
                    r(e, n, l, c)
                },
                calc: function(r) {
                    const s = r * r;
                    return t + e * r + n * s + i * (s * r)
                }
            }
        }
        Wo.prototype.isArcCurve = !0;
        const qo = new Xt
          , Xo = new jo
          , Yo = new jo
          , Zo = new jo;
        class Jo extends Go {
            constructor(t=[], e=!1, n="centripetal", i=.5) {
                super(),
                this.type = "CatmullRomCurve3",
                this.points = t,
                this.closed = e,
                this.curveType = n,
                this.tension = i
            }
            getPoint(t, e=new Xt) {
                const n = e
                  , i = this.points
                  , r = i.length
                  , s = (r - (this.closed ? 0 : 1)) * t;
                let a, o, l = Math.floor(s), c = s - l;
                this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2,
                c = 1),
                this.closed || l > 0 ? a = i[(l - 1) % r] : (qo.subVectors(i[0], i[1]).add(i[0]),
                a = qo);
                const h = i[l % r]
                  , u = i[(l + 1) % r];
                if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (qo.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]),
                o = qo),
                "centripetal" === this.curveType || "chordal" === this.curveType) {
                    const t = "chordal" === this.curveType ? .5 : .25;
                    let e = Math.pow(a.distanceToSquared(h), t)
                      , n = Math.pow(h.distanceToSquared(u), t)
                      , i = Math.pow(u.distanceToSquared(o), t);
                    n < 1e-4 && (n = 1),
                    e < 1e-4 && (e = n),
                    i < 1e-4 && (i = n),
                    Xo.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i),
                    Yo.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i),
                    Zo.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i)
                } else
                    "catmullrom" === this.curveType && (Xo.initCatmullRom(a.x, h.x, u.x, o.x, this.tension),
                    Yo.initCatmullRom(a.y, h.y, u.y, o.y, this.tension),
                    Zo.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
                return n.set(Xo.calc(c), Yo.calc(c), Zo.calc(c)),
                n
            }
            copy(t) {
                super.copy(t),
                this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this.closed = t.closed,
                this.curveType = t.curveType,
                this.tension = t.tension,
                this
            }
            toJSON() {
                const t = super.toJSON();
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t.closed = this.closed,
                t.curveType = this.curveType,
                t.tension = this.tension,
                t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new Xt).fromArray(n))
                }
                return this.closed = t.closed,
                this.curveType = t.curveType,
                this.tension = t.tension,
                this
            }
        }
        function $o(t, e, n, i, r) {
            const s = .5 * (i - e)
              , a = .5 * (r - n)
              , o = t * t;
            return (2 * n - 2 * i + s + a) * (t * o) + (-3 * n + 3 * i - 2 * s - a) * o + s * t + n
        }
        function Ko(t, e, n, i) {
            return function(t, e) {
                const n = 1 - t;
                return n * n * e
            }(t, e) + function(t, e) {
                return 2 * (1 - t) * t * e
            }(t, n) + function(t, e) {
                return t * t * e
            }(t, i)
        }
        function Qo(t, e, n, i, r) {
            return function(t, e) {
                const n = 1 - t;
                return n * n * n * e
            }(t, e) + function(t, e) {
                const n = 1 - t;
                return 3 * n * n * t * e
            }(t, n) + function(t, e) {
                return 3 * (1 - t) * t * t * e
            }(t, i) + function(t, e) {
                return t * t * t * e
            }(t, r)
        }
        Jo.prototype.isCatmullRomCurve3 = !0;
        class tl extends Go {
            constructor(t=new Bt, e=new Bt, n=new Bt, i=new Bt) {
                super(),
                this.type = "CubicBezierCurve",
                this.v0 = t,
                this.v1 = e,
                this.v2 = n,
                this.v3 = i
            }
            getPoint(t, e=new Bt) {
                const n = e
                  , i = this.v0
                  , r = this.v1
                  , s = this.v2
                  , a = this.v3;
                return n.set(Qo(t, i.x, r.x, s.x, a.x), Qo(t, i.y, r.y, s.y, a.y)),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this.v3.copy(t.v3),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t.v3 = this.v3.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this.v3.fromArray(t.v3),
                this
            }
        }
        tl.prototype.isCubicBezierCurve = !0;
        class el extends Go {
            constructor(t=new Xt, e=new Xt, n=new Xt, i=new Xt) {
                super(),
                this.type = "CubicBezierCurve3",
                this.v0 = t,
                this.v1 = e,
                this.v2 = n,
                this.v3 = i
            }
            getPoint(t, e=new Xt) {
                const n = e
                  , i = this.v0
                  , r = this.v1
                  , s = this.v2
                  , a = this.v3;
                return n.set(Qo(t, i.x, r.x, s.x, a.x), Qo(t, i.y, r.y, s.y, a.y), Qo(t, i.z, r.z, s.z, a.z)),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this.v3.copy(t.v3),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t.v3 = this.v3.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this.v3.fromArray(t.v3),
                this
            }
        }
        el.prototype.isCubicBezierCurve3 = !0;
        class nl extends Go {
            constructor(t=new Bt, e=new Bt) {
                super(),
                this.type = "LineCurve",
                this.v1 = t,
                this.v2 = e
            }
            getPoint(t, e=new Bt) {
                const n = e;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(t).add(this.v1)),
                n
            }
            getPointAt(t, e) {
                return this.getPoint(t, e)
            }
            getTangent(t, e) {
                const n = e || new Bt;
                return n.copy(this.v2).sub(this.v1).normalize(),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        nl.prototype.isLineCurve = !0;
        class il extends Go {
            constructor(t=new Bt, e=new Bt, n=new Bt) {
                super(),
                this.type = "QuadraticBezierCurve",
                this.v0 = t,
                this.v1 = e,
                this.v2 = n
            }
            getPoint(t, e=new Bt) {
                const n = e
                  , i = this.v0
                  , r = this.v1
                  , s = this.v2;
                return n.set(Ko(t, i.x, r.x, s.x), Ko(t, i.y, r.y, s.y)),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        il.prototype.isQuadraticBezierCurve = !0;
        class rl extends Go {
            constructor(t=new Xt, e=new Xt, n=new Xt) {
                super(),
                this.type = "QuadraticBezierCurve3",
                this.v0 = t,
                this.v1 = e,
                this.v2 = n
            }
            getPoint(t, e=new Xt) {
                const n = e
                  , i = this.v0
                  , r = this.v1
                  , s = this.v2;
                return n.set(Ko(t, i.x, r.x, s.x), Ko(t, i.y, r.y, s.y), Ko(t, i.z, r.z, s.z)),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        rl.prototype.isQuadraticBezierCurve3 = !0;
        class sl extends Go {
            constructor(t=[]) {
                super(),
                this.type = "SplineCurve",
                this.points = t
            }
            getPoint(t, e=new Bt) {
                const n = e
                  , i = this.points
                  , r = (i.length - 1) * t
                  , s = Math.floor(r)
                  , a = r - s
                  , o = i[0 === s ? s : s - 1]
                  , l = i[s]
                  , c = i[s > i.length - 2 ? i.length - 1 : s + 1]
                  , h = i[s > i.length - 3 ? i.length - 1 : s + 2];
                return n.set($o(a, o.x, l.x, c.x, h.x), $o(a, o.y, l.y, c.y, h.y)),
                n
            }
            copy(t) {
                super.copy(t),
                this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this
            }
            toJSON() {
                const t = super.toJSON();
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new Bt).fromArray(n))
                }
                return this
            }
        }
        sl.prototype.isSplineCurve = !0;
        var al = Object.freeze({
            __proto__: null,
            ArcCurve: Wo,
            CatmullRomCurve3: Jo,
            CubicBezierCurve: tl,
            CubicBezierCurve3: el,
            EllipseCurve: Vo,
            LineCurve: nl,
            LineCurve3: class extends Go {
                constructor(t=new Xt, e=new Xt) {
                    super(),
                    this.type = "LineCurve3",
                    this.isLineCurve3 = !0,
                    this.v1 = t,
                    this.v2 = e
                }
                getPoint(t, e=new Xt) {
                    const n = e;
                    return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                    n.multiplyScalar(t).add(this.v1)),
                    n
                }
                getPointAt(t, e) {
                    return this.getPoint(t, e)
                }
                copy(t) {
                    return super.copy(t),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.v1 = this.v1.toArray(),
                    t.v2 = this.v2.toArray(),
                    t
                }
                fromJSON(t) {
                    return super.fromJSON(t),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this
                }
            }
            ,
            QuadraticBezierCurve: il,
            QuadraticBezierCurve3: rl,
            SplineCurve: sl
        });
        class ol extends Go {
            constructor() {
                super(),
                this.type = "CurvePath",
                this.curves = [],
                this.autoClose = !1
            }
            add(t) {
                this.curves.push(t)
            }
            closePath() {
                const t = this.curves[0].getPoint(0)
                  , e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new nl(e,t))
            }
            getPoint(t) {
                const e = t * this.getLength()
                  , n = this.getCurveLengths();
                let i = 0;
                for (; i < n.length; ) {
                    if (n[i] >= e) {
                        const t = n[i] - e
                          , r = this.curves[i]
                          , s = r.getLength()
                          , a = 0 === s ? 0 : 1 - t / s;
                        return r.getPointAt(a)
                    }
                    i++
                }
                return null
            }
            getLength() {
                const t = this.getCurveLengths();
                return t[t.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.cacheLengths = null,
                this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                    return this.cacheLengths;
                const t = [];
                let e = 0;
                for (let n = 0, i = this.curves.length; n < i; n++)
                    e += this.curves[n].getLength(),
                    t.push(e);
                return this.cacheLengths = t,
                t
            }
            getSpacedPoints(t=40) {
                const e = [];
                for (let n = 0; n <= t; n++)
                    e.push(this.getPoint(n / t));
                return this.autoClose && e.push(e[0]),
                e
            }
            getPoints(t=12) {
                const e = [];
                let n;
                for (let i = 0, r = this.curves; i < r.length; i++) {
                    const s = r[i]
                      , a = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t
                      , o = s.getPoints(a);
                    for (let t = 0; t < o.length; t++) {
                        const i = o[t];
                        n && n.equals(i) || (e.push(i),
                        n = i)
                    }
                }
                return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]),
                e
            }
            copy(t) {
                super.copy(t),
                this.curves = [];
                for (let e = 0, n = t.curves.length; e < n; e++) {
                    const n = t.curves[e];
                    this.curves.push(n.clone())
                }
                return this.autoClose = t.autoClose,
                this
            }
            toJSON() {
                const t = super.toJSON();
                t.autoClose = this.autoClose,
                t.curves = [];
                for (let e = 0, n = this.curves.length; e < n; e++) {
                    const n = this.curves[e];
                    t.curves.push(n.toJSON())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.autoClose = t.autoClose,
                this.curves = [];
                for (let e = 0, n = t.curves.length; e < n; e++) {
                    const n = t.curves[e];
                    this.curves.push((new al[n.type]).fromJSON(n))
                }
                return this
            }
        }
        class ll extends ol {
            constructor(t) {
                super(),
                this.type = "Path",
                this.currentPoint = new Bt,
                t && this.setFromPoints(t)
            }
            setFromPoints(t) {
                this.moveTo(t[0].x, t[0].y);
                for (let e = 1, n = t.length; e < n; e++)
                    this.lineTo(t[e].x, t[e].y);
                return this
            }
            moveTo(t, e) {
                return this.currentPoint.set(t, e),
                this
            }
            lineTo(t, e) {
                const n = new nl(this.currentPoint.clone(),new Bt(t,e));
                return this.curves.push(n),
                this.currentPoint.set(t, e),
                this
            }
            quadraticCurveTo(t, e, n, i) {
                const r = new il(this.currentPoint.clone(),new Bt(t,e),new Bt(n,i));
                return this.curves.push(r),
                this.currentPoint.set(n, i),
                this
            }
            bezierCurveTo(t, e, n, i, r, s) {
                const a = new tl(this.currentPoint.clone(),new Bt(t,e),new Bt(n,i),new Bt(r,s));
                return this.curves.push(a),
                this.currentPoint.set(r, s),
                this
            }
            splineThru(t) {
                const e = [this.currentPoint.clone()].concat(t)
                  , n = new sl(e);
                return this.curves.push(n),
                this.currentPoint.copy(t[t.length - 1]),
                this
            }
            arc(t, e, n, i, r, s) {
                const a = this.currentPoint.x
                  , o = this.currentPoint.y;
                return this.absarc(t + a, e + o, n, i, r, s),
                this
            }
            absarc(t, e, n, i, r, s) {
                return this.absellipse(t, e, n, n, i, r, s),
                this
            }
            ellipse(t, e, n, i, r, s, a, o) {
                const l = this.currentPoint.x
                  , c = this.currentPoint.y;
                return this.absellipse(t + l, e + c, n, i, r, s, a, o),
                this
            }
            absellipse(t, e, n, i, r, s, a, o) {
                const l = new Vo(t,e,n,i,r,s,a,o);
                if (this.curves.length > 0) {
                    const t = l.getPoint(0);
                    t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                }
                this.curves.push(l);
                const c = l.getPoint(1);
                return this.currentPoint.copy(c),
                this
            }
            copy(t) {
                return super.copy(t),
                this.currentPoint.copy(t.currentPoint),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.currentPoint = this.currentPoint.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.currentPoint.fromArray(t.currentPoint),
                this
            }
        }
        class cl extends ll {
            constructor(t) {
                super(t),
                this.uuid = Pt(),
                this.type = "Shape",
                this.holes = []
            }
            getPointsHoles(t) {
                const e = [];
                for (let n = 0, i = this.holes.length; n < i; n++)
                    e[n] = this.holes[n].getPoints(t);
                return e
            }
            extractPoints(t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            }
            copy(t) {
                super.copy(t),
                this.holes = [];
                for (let e = 0, n = t.holes.length; e < n; e++) {
                    const n = t.holes[e];
                    this.holes.push(n.clone())
                }
                return this
            }
            toJSON() {
                const t = super.toJSON();
                t.uuid = this.uuid,
                t.holes = [];
                for (let e = 0, n = this.holes.length; e < n; e++) {
                    const n = this.holes[e];
                    t.holes.push(n.toJSON())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.uuid = t.uuid,
                this.holes = [];
                for (let e = 0, n = t.holes.length; e < n; e++) {
                    const n = t.holes[e];
                    this.holes.push((new ll).fromJSON(n))
                }
                return this
            }
        }
        class hl extends Ze {
            constructor(t, e=1) {
                super(),
                this.type = "Light",
                this.color = new _n(t),
                this.intensity = e
            }
            dispose() {}
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.intensity = t.intensity,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.color = this.color.getHex(),
                e.object.intensity = this.intensity,
                void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
                void 0 !== this.distance && (e.object.distance = this.distance),
                void 0 !== this.angle && (e.object.angle = this.angle),
                void 0 !== this.decay && (e.object.decay = this.decay),
                void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
                void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
                e
            }
        }
        hl.prototype.isLight = !0;
        class ul extends hl {
            constructor(t, e, n) {
                super(t, n),
                this.type = "HemisphereLight",
                this.position.copy(Ze.DefaultUp),
                this.updateMatrix(),
                this.groundColor = new _n(e)
            }
            copy(t) {
                return hl.prototype.copy.call(this, t),
                this.groundColor.copy(t.groundColor),
                this
            }
        }
        ul.prototype.isHemisphereLight = !0;
        const dl = new Se
          , pl = new Xt
          , fl = new Xt;
        class ml {
            constructor(t) {
                this.camera = t,
                this.bias = 0,
                this.normalBias = 0,
                this.radius = 1,
                this.mapSize = new Bt(512,512),
                this.map = null,
                this.mapPass = null,
                this.matrix = new Se,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this._frustum = new mi,
                this._frameExtents = new Bt(1,1),
                this._viewportCount = 1,
                this._viewports = [new Wt(0,0,1,1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(t) {
                const e = this.camera
                  , n = this.matrix;
                pl.setFromMatrixPosition(t.matrixWorld),
                e.position.copy(pl),
                fl.setFromMatrixPosition(t.target.matrixWorld),
                e.lookAt(fl),
                e.updateMatrixWorld(),
                dl.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(dl),
                n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                n.multiply(e.projectionMatrix),
                n.multiply(e.matrixWorldInverse)
            }
            getViewport(t) {
                return this._viewports[t]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(),
                this.mapPass && this.mapPass.dispose()
            }
            copy(t) {
                return this.camera = t.camera.clone(),
                this.bias = t.bias,
                this.radius = t.radius,
                this.mapSize.copy(t.mapSize),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const t = {};
                return 0 !== this.bias && (t.bias = this.bias),
                0 !== this.normalBias && (t.normalBias = this.normalBias),
                1 !== this.radius && (t.radius = this.radius),
                512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
                t.camera = this.camera.toJSON(!1).object,
                delete t.camera.matrix,
                t
            }
        }
        class gl extends ml {
            constructor() {
                super(new li(50,1,.5,500)),
                this.focus = 1
            }
            updateMatrices(t) {
                const e = this.camera
                  , n = 2 * Ct * t.angle * this.focus
                  , i = this.mapSize.width / this.mapSize.height
                  , r = t.distance || e.far;
                n === e.fov && i === e.aspect && r === e.far || (e.fov = n,
                e.aspect = i,
                e.far = r,
                e.updateProjectionMatrix()),
                super.updateMatrices(t)
            }
            copy(t) {
                return super.copy(t),
                this.focus = t.focus,
                this
            }
        }
        gl.prototype.isSpotLightShadow = !0;
        class vl extends hl {
            constructor(t, e, n=0, i=Math.PI / 3, r=0, s=1) {
                super(t, e),
                this.type = "SpotLight",
                this.position.copy(Ze.DefaultUp),
                this.updateMatrix(),
                this.target = new Ze,
                this.distance = n,
                this.angle = i,
                this.penumbra = r,
                this.decay = s,
                this.shadow = new gl
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t),
                this.distance = t.distance,
                this.angle = t.angle,
                this.penumbra = t.penumbra,
                this.decay = t.decay,
                this.target = t.target.clone(),
                this.shadow = t.shadow.clone(),
                this
            }
        }
        vl.prototype.isSpotLight = !0;
        const yl = new Se
          , xl = new Xt
          , _l = new Xt;
        class wl extends ml {
            constructor() {
                super(new li(90,1,.5,500)),
                this._frameExtents = new Bt(4,2),
                this._viewportCount = 6,
                this._viewports = [new Wt(2,1,1,1), new Wt(0,1,1,1), new Wt(3,1,1,1), new Wt(1,1,1,1), new Wt(3,0,1,1), new Wt(1,0,1,1)],
                this._cubeDirections = [new Xt(1,0,0), new Xt(-1,0,0), new Xt(0,0,1), new Xt(0,0,-1), new Xt(0,1,0), new Xt(0,-1,0)],
                this._cubeUps = [new Xt(0,1,0), new Xt(0,1,0), new Xt(0,1,0), new Xt(0,1,0), new Xt(0,0,1), new Xt(0,0,-1)]
            }
            updateMatrices(t, e=0) {
                const n = this.camera
                  , i = this.matrix
                  , r = t.distance || n.far;
                r !== n.far && (n.far = r,
                n.updateProjectionMatrix()),
                xl.setFromMatrixPosition(t.matrixWorld),
                n.position.copy(xl),
                _l.copy(n.position),
                _l.add(this._cubeDirections[e]),
                n.up.copy(this._cubeUps[e]),
                n.lookAt(_l),
                n.updateMatrixWorld(),
                i.makeTranslation(-xl.x, -xl.y, -xl.z),
                yl.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(yl)
            }
        }
        wl.prototype.isPointLightShadow = !0;
        class bl extends hl {
            constructor(t, e, n=0, i=1) {
                super(t, e),
                this.type = "PointLight",
                this.distance = n,
                this.decay = i,
                this.shadow = new wl
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t),
                this.distance = t.distance,
                this.decay = t.decay,
                this.shadow = t.shadow.clone(),
                this
            }
        }
        bl.prototype.isPointLight = !0;
        class Ml extends oi {
            constructor(t=-1, e=1, n=1, i=-1, r=.1, s=2e3) {
                super(),
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = t,
                this.right = e,
                this.top = n,
                this.bottom = i,
                this.near = r,
                this.far = s,
                this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.left = t.left,
                this.right = t.right,
                this.top = t.top,
                this.bottom = t.bottom,
                this.near = t.near,
                this.far = t.far,
                this.zoom = t.zoom,
                this.view = null === t.view ? null : Object.assign({}, t.view),
                this
            }
            setViewOffset(t, e, n, i, r, s) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = t,
                this.view.fullHeight = e,
                this.view.offsetX = n,
                this.view.offsetY = i,
                this.view.width = r,
                this.view.height = s,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = (this.right - this.left) / (2 * this.zoom)
                  , e = (this.top - this.bottom) / (2 * this.zoom)
                  , n = (this.right + this.left) / 2
                  , i = (this.top + this.bottom) / 2;
                let r = n - t
                  , s = n + t
                  , a = i + e
                  , o = i - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom
                      , e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += t * this.view.offsetX,
                    s = r + t * this.view.width,
                    a -= e * this.view.offsetY,
                    o = a - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.zoom = this.zoom,
                e.object.left = this.left,
                e.object.right = this.right,
                e.object.top = this.top,
                e.object.bottom = this.bottom,
                e.object.near = this.near,
                e.object.far = this.far,
                null !== this.view && (e.object.view = Object.assign({}, this.view)),
                e
            }
        }
        Ml.prototype.isOrthographicCamera = !0;
        class Sl extends ml {
            constructor() {
                super(new Ml(-5,5,5,-5,.5,500))
            }
        }
        Sl.prototype.isDirectionalLightShadow = !0;
        class Tl extends hl {
            constructor(t, e) {
                super(t, e),
                this.type = "DirectionalLight",
                this.position.copy(Ze.DefaultUp),
                this.updateMatrix(),
                this.target = new Ze,
                this.shadow = new Sl
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t),
                this.target = t.target.clone(),
                this.shadow = t.shadow.clone(),
                this
            }
        }
        Tl.prototype.isDirectionalLight = !0;
        class El extends hl {
            constructor(t, e) {
                super(t, e),
                this.type = "AmbientLight"
            }
        }
        El.prototype.isAmbientLight = !0;
        class Ll extends hl {
            constructor(t, e, n=10, i=10) {
                super(t, e),
                this.type = "RectAreaLight",
                this.width = n,
                this.height = i
            }
            copy(t) {
                return super.copy(t),
                this.width = t.width,
                this.height = t.height,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.width = this.width,
                e.object.height = this.height,
                e
            }
        }
        Ll.prototype.isRectAreaLight = !0;
        class Al {
            constructor() {
                this.coefficients = [];
                for (let t = 0; t < 9; t++)
                    this.coefficients.push(new Xt)
            }
            set(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].copy(t[e]);
                return this
            }
            zero() {
                for (let t = 0; t < 9; t++)
                    this.coefficients[t].set(0, 0, 0);
                return this
            }
            getAt(t, e) {
                const n = t.x
                  , i = t.y
                  , r = t.z
                  , s = this.coefficients;
                return e.copy(s[0]).multiplyScalar(.282095),
                e.addScaledVector(s[1], .488603 * i),
                e.addScaledVector(s[2], .488603 * r),
                e.addScaledVector(s[3], .488603 * n),
                e.addScaledVector(s[4], n * i * 1.092548),
                e.addScaledVector(s[5], i * r * 1.092548),
                e.addScaledVector(s[6], .315392 * (3 * r * r - 1)),
                e.addScaledVector(s[7], n * r * 1.092548),
                e.addScaledVector(s[8], .546274 * (n * n - i * i)),
                e
            }
            getIrradianceAt(t, e) {
                const n = t.x
                  , i = t.y
                  , r = t.z
                  , s = this.coefficients;
                return e.copy(s[0]).multiplyScalar(.886227),
                e.addScaledVector(s[1], 1.023328 * i),
                e.addScaledVector(s[2], 1.023328 * r),
                e.addScaledVector(s[3], 1.023328 * n),
                e.addScaledVector(s[4], .858086 * n * i),
                e.addScaledVector(s[5], .858086 * i * r),
                e.addScaledVector(s[6], .743125 * r * r - .247708),
                e.addScaledVector(s[7], .858086 * n * r),
                e.addScaledVector(s[8], .429043 * (n * n - i * i)),
                e
            }
            add(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].add(t.coefficients[e]);
                return this
            }
            addScaledSH(t, e) {
                for (let n = 0; n < 9; n++)
                    this.coefficients[n].addScaledVector(t.coefficients[n], e);
                return this
            }
            scale(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].multiplyScalar(t);
                return this
            }
            lerp(t, e) {
                for (let n = 0; n < 9; n++)
                    this.coefficients[n].lerp(t.coefficients[n], e);
                return this
            }
            equals(t) {
                for (let e = 0; e < 9; e++)
                    if (!this.coefficients[e].equals(t.coefficients[e]))
                        return !1;
                return !0
            }
            copy(t) {
                return this.set(t.coefficients)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            fromArray(t, e=0) {
                const n = this.coefficients;
                for (let i = 0; i < 9; i++)
                    n[i].fromArray(t, e + 3 * i);
                return this
            }
            toArray(t=[], e=0) {
                const n = this.coefficients;
                for (let i = 0; i < 9; i++)
                    n[i].toArray(t, e + 3 * i);
                return t
            }
            static getBasisAt(t, e) {
                const n = t.x
                  , i = t.y
                  , r = t.z;
                e[0] = .282095,
                e[1] = .488603 * i,
                e[2] = .488603 * r,
                e[3] = .488603 * n,
                e[4] = 1.092548 * n * i,
                e[5] = 1.092548 * i * r,
                e[6] = .315392 * (3 * r * r - 1),
                e[7] = 1.092548 * n * r,
                e[8] = .546274 * (n * n - i * i)
            }
        }
        Al.prototype.isSphericalHarmonics3 = !0;
        class Cl extends hl {
            constructor(t=new Al, e=1) {
                super(void 0, e),
                this.sh = t
            }
            copy(t) {
                return super.copy(t),
                this.sh.copy(t.sh),
                this
            }
            fromJSON(t) {
                return this.intensity = t.intensity,
                this.sh.fromArray(t.sh),
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.sh = this.sh.toArray(),
                e
            }
        }
        Cl.prototype.isLightProbe = !0;
        class Pl {
            static decodeText(t) {
                if ("undefined" != typeof TextDecoder)
                    return (new TextDecoder).decode(t);
                let e = "";
                for (let n = 0, i = t.length; n < i; n++)
                    e += String.fromCharCode(t[n]);
                try {
                    return decodeURIComponent(escape(e))
                } catch (t) {
                    return e
                }
            }
            static extractUrlBase(t) {
                const e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.substr(0, e + 1)
            }
        }
        class Rl extends zn {
            constructor() {
                super(),
                this.type = "InstancedBufferGeometry",
                this.instanceCount = 1 / 0
            }
            copy(t) {
                return super.copy(t),
                this.instanceCount = t.instanceCount,
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const t = super.toJSON(this);
                return t.instanceCount = this.instanceCount,
                t.isInstancedBufferGeometry = !0,
                t
            }
        }
        Rl.prototype.isInstancedBufferGeometry = !0;
        class Il extends Sn {
            constructor(t, e, n, i) {
                "number" == typeof n && (i = n,
                n = !1,
                console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
                super(t, e, n),
                this.meshPerAttribute = i || 1
            }
            copy(t) {
                return super.copy(t),
                this.meshPerAttribute = t.meshPerAttribute,
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.meshPerAttribute = this.meshPerAttribute,
                t.isInstancedBufferAttribute = !0,
                t
            }
        }
        Il.prototype.isInstancedBufferAttribute = !0;
        (class extends zo {
            constructor(t) {
                super(t),
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(t) {
                return this.options = t,
                this
            }
            load(t, e, n, i) {
                void 0 === t && (t = ""),
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const r = this
                  , s = Do.get(t);
                if (void 0 !== s)
                    return r.manager.itemStart(t),
                    setTimeout((function() {
                        e && e(s),
                        r.manager.itemEnd(t)
                    }
                    ), 0),
                    s;
                const a = {};
                a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
                a.headers = this.requestHeader,
                fetch(t, a).then((function(t) {
                    return t.blob()
                }
                )).then((function(t) {
                    return createImageBitmap(t, Object.assign(r.options, {
                        colorSpaceConversion: "none"
                    }))
                }
                )).then((function(n) {
                    Do.add(t, n),
                    e && e(n),
                    r.manager.itemEnd(t)
                }
                )).catch((function(e) {
                    i && i(e),
                    r.manager.itemError(t),
                    r.manager.itemEnd(t)
                }
                )),
                r.manager.itemStart(t)
            }
        }
        ).prototype.isImageBitmapLoader = !0;
        class Dl {
            constructor() {
                this.type = "ShapePath",
                this.color = new _n,
                this.subPaths = [],
                this.currentPath = null
            }
            moveTo(t, e) {
                return this.currentPath = new ll,
                this.subPaths.push(this.currentPath),
                this.currentPath.moveTo(t, e),
                this
            }
            lineTo(t, e) {
                return this.currentPath.lineTo(t, e),
                this
            }
            quadraticCurveTo(t, e, n, i) {
                return this.currentPath.quadraticCurveTo(t, e, n, i),
                this
            }
            bezierCurveTo(t, e, n, i, r, s) {
                return this.currentPath.bezierCurveTo(t, e, n, i, r, s),
                this
            }
            splineThru(t) {
                return this.currentPath.splineThru(t),
                this
            }
            toShapes(t, e) {
                function n(t) {
                    const e = [];
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n]
                          , r = new cl;
                        r.curves = i.curves,
                        e.push(r)
                    }
                    return e
                }
                function i(t, e) {
                    const n = e.length;
                    let i = !1;
                    for (let r = n - 1, s = 0; s < n; r = s++) {
                        let n = e[r]
                          , a = e[s]
                          , o = a.x - n.x
                          , l = a.y - n.y;
                        if (Math.abs(l) > Number.EPSILON) {
                            if (l < 0 && (n = e[s],
                            o = -o,
                            a = e[r],
                            l = -l),
                            t.y < n.y || t.y > a.y)
                                continue;
                            if (t.y === n.y) {
                                if (t.x === n.x)
                                    return !0
                            } else {
                                const e = l * (t.x - n.x) - o * (t.y - n.y);
                                if (0 === e)
                                    return !0;
                                if (e < 0)
                                    continue;
                                i = !i
                            }
                        } else {
                            if (t.y !== n.y)
                                continue;
                            if (a.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= a.x)
                                return !0
                        }
                    }
                    return i
                }
                const r = eo.isClockWise
                  , s = this.subPaths;
                if (0 === s.length)
                    return [];
                if (!0 === e)
                    return n(s);
                let a, o, l;
                const c = [];
                if (1 === s.length)
                    return o = s[0],
                    l = new cl,
                    l.curves = o.curves,
                    c.push(l),
                    c;
                let h = !r(s[0].getPoints());
                h = t ? !h : h;
                const u = []
                  , d = [];
                let p, f, m = [], g = 0;
                d[g] = void 0,
                m[g] = [];
                for (let e = 0, n = s.length; e < n; e++)
                    o = s[e],
                    p = o.getPoints(),
                    a = r(p),
                    a = t ? !a : a,
                    a ? (!h && d[g] && g++,
                    d[g] = {
                        s: new cl,
                        p: p
                    },
                    d[g].s.curves = o.curves,
                    h && g++,
                    m[g] = []) : m[g].push({
                        h: o,
                        p: p[0]
                    });
                if (!d[0])
                    return n(s);
                if (d.length > 1) {
                    let t = !1;
                    const e = [];
                    for (let t = 0, e = d.length; t < e; t++)
                        u[t] = [];
                    for (let n = 0, r = d.length; n < r; n++) {
                        const r = m[n];
                        for (let s = 0; s < r.length; s++) {
                            const a = r[s];
                            let o = !0;
                            for (let r = 0; r < d.length; r++)
                                i(a.p, d[r].p) && (n !== r && e.push({
                                    froms: n,
                                    tos: r,
                                    hole: s
                                }),
                                o ? (o = !1,
                                u[r].push(a)) : t = !0);
                            o && u[n].push(a)
                        }
                    }
                    e.length > 0 && (t || (m = u))
                }
                for (let t = 0, e = d.length; t < e; t++) {
                    l = d[t].s,
                    c.push(l),
                    f = m[t];
                    for (let t = 0, e = f.length; t < e; t++)
                        l.holes.push(f[t].h)
                }
                return c
            }
        }
        class Nl {
            constructor(t) {
                this.type = "Font",
                this.data = t
            }
            generateShapes(t, e=100) {
                const n = []
                  , i = function(t, e, n) {
                    const i = Array.from(t)
                      , r = e / n.resolution
                      , s = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r
                      , a = [];
                    let o = 0
                      , l = 0;
                    for (let t = 0; t < i.length; t++) {
                        const e = i[t];
                        if ("\n" === e)
                            o = 0,
                            l -= s;
                        else {
                            const t = Ol(e, r, o, l, n);
                            o += t.offsetX,
                            a.push(t.path)
                        }
                    }
                    return a
                }(t, e, this.data);
                for (let t = 0, e = i.length; t < e; t++)
                    Array.prototype.push.apply(n, i[t].toShapes());
                return n
            }
        }
        function Ol(t, e, n, i, r) {
            const s = r.glyphs[t] || r.glyphs["?"];
            if (!s)
                return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + ".");
            const a = new Dl;
            let o, l, c, h, u, d, p, f;
            if (s.o) {
                const t = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
                for (let r = 0, s = t.length; r < s; ) {
                    switch (t[r++]) {
                    case "m":
                        o = t[r++] * e + n,
                        l = t[r++] * e + i,
                        a.moveTo(o, l);
                        break;
                    case "l":
                        o = t[r++] * e + n,
                        l = t[r++] * e + i,
                        a.lineTo(o, l);
                        break;
                    case "q":
                        c = t[r++] * e + n,
                        h = t[r++] * e + i,
                        u = t[r++] * e + n,
                        d = t[r++] * e + i,
                        a.quadraticCurveTo(u, d, c, h);
                        break;
                    case "b":
                        c = t[r++] * e + n,
                        h = t[r++] * e + i,
                        u = t[r++] * e + n,
                        d = t[r++] * e + i,
                        p = t[r++] * e + n,
                        f = t[r++] * e + i,
                        a.bezierCurveTo(u, d, p, f, c, h)
                    }
                }
            }
            return {
                offsetX: s.ha * e,
                path: a
            }
        }
        Nl.prototype.isFont = !0;
        let zl;
        const Bl = function() {
            return void 0 === zl && (zl = new (window.AudioContext || window.webkitAudioContext)),
            zl
        };
        class kl extends zo {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                const r = this
                  , s = new ko(this.manager);
                s.setResponseType("arraybuffer"),
                s.setPath(this.path),
                s.setRequestHeader(this.requestHeader),
                s.setWithCredentials(this.withCredentials),
                s.load(t, (function(n) {
                    try {
                        const t = n.slice(0);
                        Bl().decodeAudioData(t, (function(t) {
                            e(t)
                        }
                        ))
                    } catch (e) {
                        i ? i(e) : console.error(e),
                        r.manager.itemError(t)
                    }
                }
                ), n, i)
            }
        }
        (class extends Cl {
            constructor(t, e, n=1) {
                super(void 0, n);
                const i = (new _n).set(t)
                  , r = (new _n).set(e)
                  , s = new Xt(i.r,i.g,i.b)
                  , a = new Xt(r.r,r.g,r.b)
                  , o = Math.sqrt(Math.PI)
                  , l = o * Math.sqrt(.75);
                this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),
                this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)
            }
        }
        ).prototype.isHemisphereLightProbe = !0;
        (class extends Cl {
            constructor(t, e=1) {
                super(void 0, e);
                const n = (new _n).set(t);
                this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
        }
        ).prototype.isAmbientLightProbe = !0;
        class Fl extends Ze {
            constructor(t) {
                super(),
                this.type = "Audio",
                this.listener = t,
                this.context = t.context,
                this.gain = this.context.createGain(),
                this.gain.connect(t.getInput()),
                this.autoplay = !1,
                this.buffer = null,
                this.detune = 0,
                this.loop = !1,
                this.loopStart = 0,
                this.loopEnd = 0,
                this.offset = 0,
                this.duration = void 0,
                this.playbackRate = 1,
                this.isPlaying = !1,
                this.hasPlaybackControl = !0,
                this.source = null,
                this.sourceType = "empty",
                this._startedAt = 0,
                this._progress = 0,
                this._connected = !1,
                this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(t) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "audioNode",
                this.source = t,
                this.connect(),
                this
            }
            setMediaElementSource(t) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "mediaNode",
                this.source = this.context.createMediaElementSource(t),
                this.connect(),
                this
            }
            setMediaStreamSource(t) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "mediaStreamNode",
                this.source = this.context.createMediaStreamSource(t),
                this.connect(),
                this
            }
            setBuffer(t) {
                return this.buffer = t,
                this.sourceType = "buffer",
                this.autoplay && this.play(),
                this
            }
            play(t=0) {
                if (!0 === this.isPlaying)
                    return void console.warn("THREE.Audio: Audio is already playing.");
                if (!1 === this.hasPlaybackControl)
                    return void console.warn("THREE.Audio: this Audio has no playback control.");
                this._startedAt = this.context.currentTime + t;
                const e = this.context.createBufferSource();
                return e.buffer = this.buffer,
                e.loop = this.loop,
                e.loopStart = this.loopStart,
                e.loopEnd = this.loopEnd,
                e.onended = this.onEnded.bind(this),
                e.start(this._startedAt, this._progress + this.offset, this.duration),
                this.isPlaying = !0,
                this.source = e,
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
            }
            pause() {
                if (!1 !== this.hasPlaybackControl)
                    return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                    !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                    this.source.stop(),
                    this.source.onended = null,
                    this.isPlaying = !1),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            stop() {
                if (!1 !== this.hasPlaybackControl)
                    return this._progress = 0,
                    this.source.stop(),
                    this.source.onended = null,
                    this.isPlaying = !1,
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let t = 1, e = this.filters.length; t < e; t++)
                        this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else
                    this.source.connect(this.getOutput());
                return this._connected = !0,
                this
            }
            disconnect() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (let t = 1, e = this.filters.length; t < e; t++)
                        this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else
                    this.source.disconnect(this.getOutput());
                return this._connected = !1,
                this
            }
            getFilters() {
                return this.filters
            }
            setFilters(t) {
                return t || (t = []),
                !0 === this._connected ? (this.disconnect(),
                this.filters = t.slice(),
                this.connect()) : this.filters = t.slice(),
                this
            }
            setDetune(t) {
                if (this.detune = t,
                void 0 !== this.source.detune)
                    return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                    this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(t) {
                return this.setFilters(t ? [t] : [])
            }
            setPlaybackRate(t) {
                if (!1 !== this.hasPlaybackControl)
                    return this.playbackRate = t,
                    !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
                !1) : this.loop
            }
            setLoop(t) {
                if (!1 !== this.hasPlaybackControl)
                    return this.loop = t,
                    !0 === this.isPlaying && (this.source.loop = this.loop),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            setLoopStart(t) {
                return this.loopStart = t,
                this
            }
            setLoopEnd(t) {
                return this.loopEnd = t,
                this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(t) {
                return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
                this
            }
        }
        class Hl {
            constructor(t, e, n) {
                let i, r, s;
                switch (this.binding = t,
                this.valueSize = n,
                e) {
                case "quaternion":
                    i = this._slerp,
                    r = this._slerpAdditive,
                    s = this._setAdditiveIdentityQuaternion,
                    this.buffer = new Float64Array(6 * n),
                    this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    i = this._select,
                    r = this._select,
                    s = this._setAdditiveIdentityOther,
                    this.buffer = new Array(5 * n);
                    break;
                default:
                    i = this._lerp,
                    r = this._lerpAdditive,
                    s = this._setAdditiveIdentityNumeric,
                    this.buffer = new Float64Array(5 * n)
                }
                this._mixBufferRegion = i,
                this._mixBufferRegionAdditive = r,
                this._setIdentity = s,
                this._origIndex = 3,
                this._addIndex = 4,
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                this.useCount = 0,
                this.referenceCount = 0
            }
            accumulate(t, e) {
                const n = this.buffer
                  , i = this.valueSize
                  , r = t * i + i;
                let s = this.cumulativeWeight;
                if (0 === s) {
                    for (let t = 0; t !== i; ++t)
                        n[r + t] = n[t];
                    s = e
                } else {
                    s += e;
                    const t = e / s;
                    this._mixBufferRegion(n, r, 0, t, i)
                }
                this.cumulativeWeight = s
            }
            accumulateAdditive(t) {
                const e = this.buffer
                  , n = this.valueSize
                  , i = n * this._addIndex;
                0 === this.cumulativeWeightAdditive && this._setIdentity(),
                this._mixBufferRegionAdditive(e, i, 0, t, n),
                this.cumulativeWeightAdditive += t
            }
            apply(t) {
                const e = this.valueSize
                  , n = this.buffer
                  , i = t * e + e
                  , r = this.cumulativeWeight
                  , s = this.cumulativeWeightAdditive
                  , a = this.binding;
                if (this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                r < 1) {
                    const t = e * this._origIndex;
                    this._mixBufferRegion(n, i, t, 1 - r, e)
                }
                s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
                for (let t = e, r = e + e; t !== r; ++t)
                    if (n[t] !== n[t + e]) {
                        a.setValue(n, i);
                        break
                    }
            }
            saveOriginalState() {
                const t = this.binding
                  , e = this.buffer
                  , n = this.valueSize
                  , i = n * this._origIndex;
                t.getValue(e, i);
                for (let t = n, r = i; t !== r; ++t)
                    e[t] = e[i + t % n];
                this._setIdentity(),
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            }
            _setAdditiveIdentityNumeric() {
                const t = this._addIndex * this.valueSize
                  , e = t + this.valueSize;
                for (let n = t; n < e; n++)
                    this.buffer[n] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(),
                this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const t = this._origIndex * this.valueSize
                  , e = this._addIndex * this.valueSize;
                for (let n = 0; n < this.valueSize; n++)
                    this.buffer[e + n] = this.buffer[t + n]
            }
            _select(t, e, n, i, r) {
                if (i >= .5)
                    for (let i = 0; i !== r; ++i)
                        t[e + i] = t[n + i]
            }
            _slerp(t, e, n, i) {
                qt.slerpFlat(t, e, t, e, t, n, i)
            }
            _slerpAdditive(t, e, n, i, r) {
                const s = this._workIndex * r;
                qt.multiplyQuaternionsFlat(t, s, t, e, t, n),
                qt.slerpFlat(t, e, t, e, t, s, i)
            }
            _lerp(t, e, n, i, r) {
                const s = 1 - i;
                for (let a = 0; a !== r; ++a) {
                    const r = e + a;
                    t[r] = t[r] * s + t[n + a] * i
                }
            }
            _lerpAdditive(t, e, n, i, r) {
                for (let s = 0; s !== r; ++s) {
                    const r = e + s;
                    t[r] = t[r] + t[n + s] * i
                }
            }
        }
        const Ul = new RegExp("[\\[\\]\\.:\\/]","g")
          , Gl = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]"
          , Vl = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]")
          , Wl = /(WCOD+)?/.source.replace("WCOD", Gl)
          , jl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]")
          , ql = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]")
          , Xl = new RegExp("^" + Vl + Wl + jl + ql + "$")
          , Yl = ["material", "materials", "bones"];
        class Zl {
            constructor(t, e, n) {
                this.path = e,
                this.parsedPath = n || Zl.parseTrackName(e),
                this.node = Zl.findNode(t, this.parsedPath.nodeName) || t,
                this.rootNode = t,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
            static create(t, e, n) {
                return t && t.isAnimationObjectGroup ? new Zl.Composite(t,e,n) : new Zl(t,e,n)
            }
            static sanitizeNodeName(t) {
                return t.replace(/\s/g, "_").replace(Ul, "")
            }
            static parseTrackName(t) {
                const e = Xl.exec(t);
                if (!e)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                const n = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                }
                  , i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    const t = n.nodeName.substring(i + 1);
                    -1 !== Yl.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i),
                    n.objectName = t)
                }
                if (null === n.propertyName || 0 === n.propertyName.length)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            }
            static findNode(t, e) {
                if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
                    return t;
                if (t.skeleton) {
                    const n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n)
                        return n
                }
                if (t.children) {
                    const n = function(t) {
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i];
                            if (r.name === e || r.uuid === e)
                                return r;
                            const s = n(r.children);
                            if (s)
                                return s
                        }
                        return null
                    }
                      , i = n(t.children);
                    if (i)
                        return i
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(t, e) {
                t[e] = this.node[this.propertyName]
            }
            _getValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    t[e++] = n[i]
            }
            _getValue_arrayElement(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(t, e) {
                this.resolvedProperty.toArray(t, e)
            }
            _setValue_direct(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }
            _setValue_direct_setNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e],
                this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = t[e++]
            }
            _setValue_array_setNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = t[e++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }
            _setValue_arrayElement_setNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }
            _setValue_fromArray_setNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(t, e) {
                this.bind(),
                this.getValue(t, e)
            }
            _setValue_unbound(t, e) {
                this.bind(),
                this.setValue(t, e)
            }
            bind() {
                let t = this.node;
                const e = this.parsedPath
                  , n = e.objectName
                  , i = e.propertyName;
                let r = e.propertyIndex;
                if (t || (t = Zl.findNode(this.rootNode, e.nodeName) || this.rootNode,
                this.node = t),
                this.getValue = this._getValue_unavailable,
                this.setValue = this._setValue_unavailable,
                !t)
                    return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                if (n) {
                    let i = e.objectIndex;
                    switch (n) {
                    case "materials":
                        if (!t.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        t = t.skeleton.bones;
                        for (let e = 0; e < t.length; e++)
                            if (t[e].name === i) {
                                i = e;
                                break
                            }
                        break;
                    default:
                        if (void 0 === t[n])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        t = t[n]
                    }
                    if (void 0 !== i) {
                        if (void 0 === t[i])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[i]
                    }
                }
                const s = t[i];
                if (void 0 === s) {
                    const n = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
                }
                let a = this.Versioning.None;
                this.targetObject = t,
                void 0 !== t.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                let o = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!t.geometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!t.geometry.isBufferGeometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                        if (!t.geometry.morphAttributes)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                    }
                    o = this.BindingType.ArrayElement,
                    this.resolvedProperty = s,
                    this.propertyIndex = r
                } else
                    void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray,
                    this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray,
                    this.resolvedProperty = s) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[o],
                this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
            }
            unbind() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        }
        Zl.Composite = class {
            constructor(t, e, n) {
                const i = n || Zl.parseTrackName(e);
                this._targetGroup = t,
                this._bindings = t.subscribe_(e, i)
            }
            getValue(t, e) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_
                  , i = this._bindings[n];
                void 0 !== i && i.getValue(t, e)
            }
            setValue(t, e) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                    n[i].setValue(t, e)
            }
            bind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                    t[e].bind()
            }
            unbind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                    t[e].unbind()
            }
        }
        ,
        Zl.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Zl.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        Zl.prototype.GetterByBindingType = [Zl.prototype._getValue_direct, Zl.prototype._getValue_array, Zl.prototype._getValue_arrayElement, Zl.prototype._getValue_toArray],
        Zl.prototype.SetterByBindingTypeAndVersioning = [[Zl.prototype._setValue_direct, Zl.prototype._setValue_direct_setNeedsUpdate, Zl.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Zl.prototype._setValue_array, Zl.prototype._setValue_array_setNeedsUpdate, Zl.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Zl.prototype._setValue_arrayElement, Zl.prototype._setValue_arrayElement_setNeedsUpdate, Zl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Zl.prototype._setValue_fromArray, Zl.prototype._setValue_fromArray_setNeedsUpdate, Zl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
        (class {
            constructor() {
                this.uuid = Pt(),
                this._objects = Array.prototype.slice.call(arguments),
                this.nCachedObjects_ = 0;
                const t = {};
                this._indicesByUUID = t;
                for (let e = 0, n = arguments.length; e !== n; ++e)
                    t[arguments[e].uuid] = e;
                this._paths = [],
                this._parsedPaths = [],
                this._bindings = [],
                this._bindingsIndicesByPath = {};
                const e = this;
                this.stats = {
                    objects: {
                        get total() {
                            return e._objects.length
                        },
                        get inUse() {
                            return this.total - e.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return e._bindings.length
                    }
                }
            }
            add() {
                const t = this._objects
                  , e = this._indicesByUUID
                  , n = this._paths
                  , i = this._parsedPaths
                  , r = this._bindings
                  , s = r.length;
                let a = void 0
                  , o = t.length
                  , l = this.nCachedObjects_;
                for (let c = 0, h = arguments.length; c !== h; ++c) {
                    const h = arguments[c]
                      , u = h.uuid;
                    let d = e[u];
                    if (void 0 === d) {
                        d = o++,
                        e[u] = d,
                        t.push(h);
                        for (let t = 0, e = s; t !== e; ++t)
                            r[t].push(new Zl(h,n[t],i[t]))
                    } else if (d < l) {
                        a = t[d];
                        const o = --l
                          , c = t[o];
                        e[c.uuid] = d,
                        t[d] = c,
                        e[u] = o,
                        t[o] = h;
                        for (let t = 0, e = s; t !== e; ++t) {
                            const e = r[t]
                              , s = e[o];
                            let a = e[d];
                            e[d] = s,
                            void 0 === a && (a = new Zl(h,n[t],i[t])),
                            e[o] = a
                        }
                    } else
                        t[d] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = l
            }
            remove() {
                const t = this._objects
                  , e = this._indicesByUUID
                  , n = this._bindings
                  , i = n.length;
                let r = this.nCachedObjects_;
                for (let s = 0, a = arguments.length; s !== a; ++s) {
                    const a = arguments[s]
                      , o = a.uuid
                      , l = e[o];
                    if (void 0 !== l && l >= r) {
                        const s = r++
                          , c = t[s];
                        e[c.uuid] = l,
                        t[l] = c,
                        e[o] = s,
                        t[s] = a;
                        for (let t = 0, e = i; t !== e; ++t) {
                            const e = n[t]
                              , i = e[s]
                              , r = e[l];
                            e[l] = i,
                            e[s] = r
                        }
                    }
                }
                this.nCachedObjects_ = r
            }
            uncache() {
                const t = this._objects
                  , e = this._indicesByUUID
                  , n = this._bindings
                  , i = n.length;
                let r = this.nCachedObjects_
                  , s = t.length;
                for (let a = 0, o = arguments.length; a !== o; ++a) {
                    const o = arguments[a].uuid
                      , l = e[o];
                    if (void 0 !== l)
                        if (delete e[o],
                        l < r) {
                            const a = --r
                              , o = t[a]
                              , c = --s
                              , h = t[c];
                            e[o.uuid] = l,
                            t[l] = o,
                            e[h.uuid] = a,
                            t[a] = h,
                            t.pop();
                            for (let t = 0, e = i; t !== e; ++t) {
                                const e = n[t]
                                  , i = e[a]
                                  , r = e[c];
                                e[l] = i,
                                e[a] = r,
                                e.pop()
                            }
                        } else {
                            const r = --s
                              , a = t[r];
                            r > 0 && (e[a.uuid] = l),
                            t[l] = a,
                            t.pop();
                            for (let t = 0, e = i; t !== e; ++t) {
                                const e = n[t];
                                e[l] = e[r],
                                e.pop()
                            }
                        }
                }
                this.nCachedObjects_ = r
            }
            subscribe_(t, e) {
                const n = this._bindingsIndicesByPath;
                let i = n[t];
                const r = this._bindings;
                if (void 0 !== i)
                    return r[i];
                const s = this._paths
                  , a = this._parsedPaths
                  , o = this._objects
                  , l = o.length
                  , c = this.nCachedObjects_
                  , h = new Array(l);
                i = r.length,
                n[t] = i,
                s.push(t),
                a.push(e),
                r.push(h);
                for (let n = c, i = o.length; n !== i; ++n) {
                    const i = o[n];
                    h[n] = new Zl(i,t,e)
                }
                return h
            }
            unsubscribe_(t) {
                const e = this._bindingsIndicesByPath
                  , n = e[t];
                if (void 0 !== n) {
                    const i = this._paths
                      , r = this._parsedPaths
                      , s = this._bindings
                      , a = s.length - 1
                      , o = s[a];
                    e[t[a]] = n,
                    s[n] = o,
                    s.pop(),
                    r[n] = r[a],
                    r.pop(),
                    i[n] = i[a],
                    i.pop()
                }
            }
        }
        ).prototype.isAnimationObjectGroup = !0;
        class Jl {
            constructor(t, e, n=null, i=e.blendMode) {
                this._mixer = t,
                this._clip = e,
                this._localRoot = n,
                this.blendMode = i;
                const r = e.tracks
                  , s = r.length
                  , a = new Array(s)
                  , o = {
                    endingStart: 2400,
                    endingEnd: 2400
                };
                for (let t = 0; t !== s; ++t) {
                    const e = r[t].createInterpolant(null);
                    a[t] = e,
                    e.settings = o
                }
                this._interpolantSettings = o,
                this._interpolants = a,
                this._propertyBindings = new Array(s),
                this._cacheIndex = null,
                this._byClipCacheIndex = null,
                this._timeScaleInterpolant = null,
                this._weightInterpolant = null,
                this.loop = 2201,
                this._loopCount = -1,
                this._startTime = null,
                this.time = 0,
                this.timeScale = 1,
                this._effectiveTimeScale = 1,
                this.weight = 1,
                this._effectiveWeight = 1,
                this.repetitions = 1 / 0,
                this.paused = !1,
                this.enabled = !0,
                this.clampWhenFinished = !1,
                this.zeroSlopeAtStart = !0,
                this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this),
                this
            }
            stop() {
                return this._mixer._deactivateAction(this),
                this.reset()
            }
            reset() {
                return this.paused = !1,
                this.enabled = !0,
                this.time = 0,
                this._loopCount = -1,
                this._startTime = null,
                this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(t) {
                return this._startTime = t,
                this
            }
            setLoop(t, e) {
                return this.loop = t,
                this.repetitions = e,
                this
            }
            setEffectiveWeight(t) {
                return this.weight = t,
                this._effectiveWeight = this.enabled ? t : 0,
                this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(t) {
                return this._scheduleFading(t, 0, 1)
            }
            fadeOut(t) {
                return this._scheduleFading(t, 1, 0)
            }
            crossFadeFrom(t, e, n) {
                if (t.fadeOut(e),
                this.fadeIn(e),
                n) {
                    const n = this._clip.duration
                      , i = t._clip.duration
                      , r = i / n
                      , s = n / i;
                    t.warp(1, r, e),
                    this.warp(s, 1, e)
                }
                return this
            }
            crossFadeTo(t, e, n) {
                return t.crossFadeFrom(this, e, n)
            }
            stopFading() {
                const t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null,
                this._mixer._takeBackControlInterpolant(t)),
                this
            }
            setEffectiveTimeScale(t) {
                return this.timeScale = t,
                this._effectiveTimeScale = this.paused ? 0 : t,
                this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(t) {
                return this.timeScale = this._clip.duration / t,
                this.stopWarping()
            }
            syncWith(t) {
                return this.time = t.time,
                this.timeScale = t.timeScale,
                this.stopWarping()
            }
            halt(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            }
            warp(t, e, n) {
                const i = this._mixer
                  , r = i.time
                  , s = this.timeScale;
                let a = this._timeScaleInterpolant;
                null === a && (a = i._lendControlInterpolant(),
                this._timeScaleInterpolant = a);
                const o = a.parameterPositions
                  , l = a.sampleValues;
                return o[0] = r,
                o[1] = r + n,
                l[0] = t / s,
                l[1] = e / s,
                this
            }
            stopWarping() {
                const t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null,
                this._mixer._takeBackControlInterpolant(t)),
                this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(t, e, n, i) {
                if (!this.enabled)
                    return void this._updateWeight(t);
                const r = this._startTime;
                if (null !== r) {
                    const i = (t - r) * n;
                    if (i < 0 || 0 === n)
                        return;
                    this._startTime = null,
                    e = n * i
                }
                e *= this._updateTimeScale(t);
                const s = this._updateTime(e)
                  , a = this._updateWeight(t);
                if (a > 0) {
                    const t = this._interpolants
                      , e = this._propertyBindings;
                    switch (this.blendMode) {
                    case 2501:
                        for (let n = 0, i = t.length; n !== i; ++n)
                            t[n].evaluate(s),
                            e[n].accumulateAdditive(a);
                        break;
                    case 2500:
                    default:
                        for (let n = 0, r = t.length; n !== r; ++n)
                            t[n].evaluate(s),
                            e[n].accumulate(i, a)
                    }
                }
            }
            _updateWeight(t) {
                let e = 0;
                if (this.enabled) {
                    e = this.weight;
                    const n = this._weightInterpolant;
                    if (null !== n) {
                        const i = n.evaluate(t)[0];
                        e *= i,
                        t > n.parameterPositions[1] && (this.stopFading(),
                        0 === i && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e,
                e
            }
            _updateTimeScale(t) {
                let e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    const n = this._timeScaleInterpolant;
                    if (null !== n) {
                        e *= n.evaluate(t)[0],
                        t > n.parameterPositions[1] && (this.stopWarping(),
                        0 === e ? this.paused = !0 : this.timeScale = e)
                    }
                }
                return this._effectiveTimeScale = e,
                e
            }
            _updateTime(t) {
                const e = this._clip.duration
                  , n = this.loop;
                let i = this.time + t
                  , r = this._loopCount;
                const s = 2202 === n;
                if (0 === t)
                    return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
                if (2200 === n) {
                    -1 === r && (this._loopCount = 0,
                    this._setEndings(!0, !0, !1));
                    t: {
                        if (i >= e)
                            i = e;
                        else {
                            if (!(i < 0)) {
                                this.time = i;
                                break t
                            }
                            i = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = i,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === r && (t >= 0 ? (r = 0,
                    this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)),
                    i >= e || i < 0) {
                        const n = Math.floor(i / e);
                        i -= e * n,
                        r += Math.abs(n);
                        const a = this.repetitions - r;
                        if (a <= 0)
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            i = t > 0 ? e : 0,
                            this.time = i,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t > 0 ? 1 : -1
                            });
                        else {
                            if (1 === a) {
                                const e = t < 0;
                                this._setEndings(e, !e, s)
                            } else
                                this._setEndings(!1, !1, s);
                            this._loopCount = r,
                            this.time = i,
                            this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: n
                            })
                        }
                    } else
                        this.time = i;
                    if (s && 1 == (1 & r))
                        return e - i
                }
                return i
            }
            _setEndings(t, e, n) {
                const i = this._interpolantSettings;
                n ? (i.endingStart = 2401,
                i.endingEnd = 2401) : (i.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402,
                i.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
            }
            _scheduleFading(t, e, n) {
                const i = this._mixer
                  , r = i.time;
                let s = this._weightInterpolant;
                null === s && (s = i._lendControlInterpolant(),
                this._weightInterpolant = s);
                const a = s.parameterPositions
                  , o = s.sampleValues;
                return a[0] = r,
                o[0] = e,
                a[1] = r + t,
                o[1] = n,
                this
            }
        }
        (class extends Et {
            constructor(t) {
                super(),
                this._root = t,
                this._initMemoryManager(),
                this._accuIndex = 0,
                this.time = 0,
                this.timeScale = 1
            }
            _bindAction(t, e) {
                const n = t._localRoot || this._root
                  , i = t._clip.tracks
                  , r = i.length
                  , s = t._propertyBindings
                  , a = t._interpolants
                  , o = n.uuid
                  , l = this._bindingsByRootAndName;
                let c = l[o];
                void 0 === c && (c = {},
                l[o] = c);
                for (let t = 0; t !== r; ++t) {
                    const r = i[t]
                      , l = r.name;
                    let h = c[l];
                    if (void 0 !== h)
                        s[t] = h;
                    else {
                        if (h = s[t],
                        void 0 !== h) {
                            null === h._cacheIndex && (++h.referenceCount,
                            this._addInactiveBinding(h, o, l));
                            continue
                        }
                        const i = e && e._propertyBindings[t].binding.parsedPath;
                        h = new Hl(Zl.create(n, l, i),r.ValueTypeName,r.getValueSize()),
                        ++h.referenceCount,
                        this._addInactiveBinding(h, o, l),
                        s[t] = h
                    }
                    a[t].resultBuffer = h.buffer
                }
            }
            _activateAction(t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        const e = (t._localRoot || this._root).uuid
                          , n = t._clip.uuid
                          , i = this._actionsByClip[n];
                        this._bindAction(t, i && i.knownActions[0]),
                        this._addInactiveAction(t, n, e)
                    }
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 == n.useCount++ && (this._lendBinding(n),
                        n.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            }
            _deactivateAction(t) {
                if (this._isActiveAction(t)) {
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 == --n.useCount && (n.restoreOriginalState(),
                        this._takeBackBinding(n))
                    }
                    this._takeBackAction(t)
                }
            }
            _initMemoryManager() {
                this._actions = [],
                this._nActiveActions = 0,
                this._actionsByClip = {},
                this._bindings = [],
                this._nActiveBindings = 0,
                this._bindingsByRootAndName = {},
                this._controlInterpolants = [],
                this._nActiveControlInterpolants = 0;
                const t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(t) {
                const e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            }
            _addInactiveAction(t, e, n) {
                const i = this._actions
                  , r = this._actionsByClip;
                let s = r[e];
                if (void 0 === s)
                    s = {
                        knownActions: [t],
                        actionByRoot: {}
                    },
                    t._byClipCacheIndex = 0,
                    r[e] = s;
                else {
                    const e = s.knownActions;
                    t._byClipCacheIndex = e.length,
                    e.push(t)
                }
                t._cacheIndex = i.length,
                i.push(t),
                s.actionByRoot[n] = t
            }
            _removeInactiveAction(t) {
                const e = this._actions
                  , n = e[e.length - 1]
                  , i = t._cacheIndex;
                n._cacheIndex = i,
                e[i] = n,
                e.pop(),
                t._cacheIndex = null;
                const r = t._clip.uuid
                  , s = this._actionsByClip
                  , a = s[r]
                  , o = a.knownActions
                  , l = o[o.length - 1]
                  , c = t._byClipCacheIndex;
                l._byClipCacheIndex = c,
                o[c] = l,
                o.pop(),
                t._byClipCacheIndex = null;
                delete a.actionByRoot[(t._localRoot || this._root).uuid],
                0 === o.length && delete s[r],
                this._removeInactiveBindingsForAction(t)
            }
            _removeInactiveBindingsForAction(t) {
                const e = t._propertyBindings;
                for (let t = 0, n = e.length; t !== n; ++t) {
                    const n = e[t];
                    0 == --n.referenceCount && this._removeInactiveBinding(n)
                }
            }
            _lendAction(t) {
                const e = this._actions
                  , n = t._cacheIndex
                  , i = this._nActiveActions++
                  , r = e[i];
                t._cacheIndex = i,
                e[i] = t,
                r._cacheIndex = n,
                e[n] = r
            }
            _takeBackAction(t) {
                const e = this._actions
                  , n = t._cacheIndex
                  , i = --this._nActiveActions
                  , r = e[i];
                t._cacheIndex = i,
                e[i] = t,
                r._cacheIndex = n,
                e[n] = r
            }
            _addInactiveBinding(t, e, n) {
                const i = this._bindingsByRootAndName
                  , r = this._bindings;
                let s = i[e];
                void 0 === s && (s = {},
                i[e] = s),
                s[n] = t,
                t._cacheIndex = r.length,
                r.push(t)
            }
            _removeInactiveBinding(t) {
                const e = this._bindings
                  , n = t.binding
                  , i = n.rootNode.uuid
                  , r = n.path
                  , s = this._bindingsByRootAndName
                  , a = s[i]
                  , o = e[e.length - 1]
                  , l = t._cacheIndex;
                o._cacheIndex = l,
                e[l] = o,
                e.pop(),
                delete a[r],
                0 === Object.keys(a).length && delete s[i]
            }
            _lendBinding(t) {
                const e = this._bindings
                  , n = t._cacheIndex
                  , i = this._nActiveBindings++
                  , r = e[i];
                t._cacheIndex = i,
                e[i] = t,
                r._cacheIndex = n,
                e[n] = r
            }
            _takeBackBinding(t) {
                const e = this._bindings
                  , n = t._cacheIndex
                  , i = --this._nActiveBindings
                  , r = e[i];
                t._cacheIndex = i,
                e[i] = t,
                r._cacheIndex = n,
                e[n] = r
            }
            _lendControlInterpolant() {
                const t = this._controlInterpolants
                  , e = this._nActiveControlInterpolants++;
                let n = t[e];
                return void 0 === n && (n = new wo(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
                n.__cacheIndex = e,
                t[e] = n),
                n
            }
            _takeBackControlInterpolant(t) {
                const e = this._controlInterpolants
                  , n = t.__cacheIndex
                  , i = --this._nActiveControlInterpolants
                  , r = e[i];
                t.__cacheIndex = i,
                e[i] = t,
                r.__cacheIndex = n,
                e[n] = r
            }
            clipAction(t, e, n) {
                const i = e || this._root
                  , r = i.uuid;
                let s = "string" == typeof t ? Ro.findByName(i, t) : t;
                const a = null !== s ? s.uuid : t
                  , o = this._actionsByClip[a];
                let l = null;
                if (void 0 === n && (n = null !== s ? s.blendMode : 2500),
                void 0 !== o) {
                    const t = o.actionByRoot[r];
                    if (void 0 !== t && t.blendMode === n)
                        return t;
                    l = o.knownActions[0],
                    null === s && (s = l._clip)
                }
                if (null === s)
                    return null;
                const c = new Jl(this,s,e,n);
                return this._bindAction(c, l),
                this._addInactiveAction(c, a, r),
                c
            }
            existingAction(t, e) {
                const n = e || this._root
                  , i = n.uuid
                  , r = "string" == typeof t ? Ro.findByName(n, t) : t
                  , s = r ? r.uuid : t
                  , a = this._actionsByClip[s];
                return void 0 !== a && a.actionByRoot[i] || null
            }
            stopAllAction() {
                const t = this._actions;
                for (let e = this._nActiveActions - 1; e >= 0; --e)
                    t[e].stop();
                return this
            }
            update(t) {
                t *= this.timeScale;
                const e = this._actions
                  , n = this._nActiveActions
                  , i = this.time += t
                  , r = Math.sign(t)
                  , s = this._accuIndex ^= 1;
                for (let a = 0; a !== n; ++a) {
                    e[a]._update(i, t, r, s)
                }
                const a = this._bindings
                  , o = this._nActiveBindings;
                for (let t = 0; t !== o; ++t)
                    a[t].apply(s);
                return this
            }
            setTime(t) {
                this.time = 0;
                for (let t = 0; t < this._actions.length; t++)
                    this._actions[t].time = 0;
                return this.update(t)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(t) {
                const e = this._actions
                  , n = t.uuid
                  , i = this._actionsByClip
                  , r = i[n];
                if (void 0 !== r) {
                    const t = r.knownActions;
                    for (let n = 0, i = t.length; n !== i; ++n) {
                        const i = t[n];
                        this._deactivateAction(i);
                        const r = i._cacheIndex
                          , s = e[e.length - 1];
                        i._cacheIndex = null,
                        i._byClipCacheIndex = null,
                        s._cacheIndex = r,
                        e[r] = s,
                        e.pop(),
                        this._removeInactiveBindingsForAction(i)
                    }
                    delete i[n]
                }
            }
            uncacheRoot(t) {
                const e = t.uuid
                  , n = this._actionsByClip;
                for (const t in n) {
                    const i = n[t].actionByRoot[e];
                    void 0 !== i && (this._deactivateAction(i),
                    this._removeInactiveAction(i))
                }
                const i = this._bindingsByRootAndName[e];
                if (void 0 !== i)
                    for (const t in i) {
                        const e = i[t];
                        e.restoreOriginalState(),
                        this._removeInactiveBinding(e)
                    }
            }
            uncacheAction(t, e) {
                const n = this.existingAction(t, e);
                null !== n && (this._deactivateAction(n),
                this._removeInactiveAction(n))
            }
        }
        ).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
        class $l {
            constructor(t) {
                "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
                t = arguments[1]),
                this.value = t
            }
            clone() {
                return new $l(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }
        (class extends Ns {
            constructor(t, e, n=1) {
                super(t, e),
                this.meshPerAttribute = n || 1
            }
            copy(t) {
                return super.copy(t),
                this.meshPerAttribute = t.meshPerAttribute,
                this
            }
            clone(t) {
                const e = super.clone(t);
                return e.meshPerAttribute = this.meshPerAttribute,
                e
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.isInstancedInterleavedBuffer = !0,
                e.meshPerAttribute = this.meshPerAttribute,
                e
            }
        }
        ).prototype.isInstancedInterleavedBuffer = !0;
        (class {
            constructor(t, e, n, i, r) {
                this.buffer = t,
                this.type = e,
                this.itemSize = n,
                this.elementSize = i,
                this.count = r,
                this.version = 0
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setBuffer(t) {
                return this.buffer = t,
                this
            }
            setType(t, e) {
                return this.type = t,
                this.elementSize = e,
                this
            }
            setItemSize(t) {
                return this.itemSize = t,
                this
            }
            setCount(t) {
                return this.count = t,
                this
            }
        }
        ).prototype.isGLBufferAttribute = !0;
        const Kl = new Bt;
        class Ql {
            constructor(t=new Bt(1 / 0,1 / 0), e=new Bt(-1 / 0,-1 / 0)) {
                this.min = t,
                this.max = e
            }
            set(t, e) {
                return this.min.copy(t),
                this.max.copy(e),
                this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++)
                    this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = Kl.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n),
                this.max.copy(t).add(n),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min),
                this.max.copy(t.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0,
                this.max.x = this.max.y = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }
            getCenter(t) {
                return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"),
                t = new Bt),
                this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"),
                t = new Bt),
                this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t),
                this.max.max(t),
                this
            }
            expandByVector(t) {
                return this.min.sub(t),
                this.max.add(t),
                this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t),
                this.max.addScalar(t),
                this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            }
            getParameter(t, e) {
                return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"),
                e = new Bt),
                e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            }
            clampPoint(t, e) {
                return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"),
                e = new Bt),
                e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return Kl.copy(t).clamp(this.min, this.max).sub(t).length()
            }
            intersect(t) {
                return this.min.max(t.min),
                this.max.min(t.max),
                this
            }
            union(t) {
                return this.min.min(t.min),
                this.max.max(t.max),
                this
            }
            translate(t) {
                return this.min.add(t),
                this.max.add(t),
                this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        Ql.prototype.isBox2 = !0;
        const tc = new Xt
          , ec = new Xt;
        (class extends Ze {
            constructor(t) {
                super(),
                this.material = t,
                this.render = function() {}
                ,
                this.hasPositions = !1,
                this.hasNormals = !1,
                this.hasColors = !1,
                this.hasUvs = !1,
                this.positionArray = null,
                this.normalArray = null,
                this.colorArray = null,
                this.uvArray = null,
                this.count = 0
            }
        }
        ).prototype.isImmediateRenderObject = !0;
        const nc = new Xt
          , ic = new Se
          , rc = new Se;
        const sc = new Float32Array(1);
        new Int32Array(sc.buffer);
        Math.pow(2, 8);
        const ac = [.125, .215, .35, .446, .526, .582]
          , oc = 5 + ac.length
          , lc = new wn({
            side: 1,
            depthWrite: !1,
            depthTest: !1
        })
          , {_lodPlanes: cc, _sizeLods: hc, _sigmas: uc} = (new ti(new ni,lc),
        dc());
        Math.sqrt(5);
        function dc() {
            const t = []
              , e = []
              , n = [];
            let i = 8;
            for (let r = 0; r < oc; r++) {
                const s = Math.pow(2, i);
                e.push(s);
                let a = 1 / s;
                r > 4 ? a = ac[r - 8 + 4 - 1] : 0 == r && (a = 0),
                n.push(a);
                const o = 1 / (s - 1)
                  , l = -o / 2
                  , c = 1 + o / 2
                  , h = [l, l, c, l, c, c, l, l, c, c, l, c]
                  , u = 6
                  , d = 6
                  , p = 3
                  , f = 2
                  , m = 1
                  , g = new Float32Array(p * d * u)
                  , v = new Float32Array(f * d * u)
                  , y = new Float32Array(m * d * u);
                for (let t = 0; t < u; t++) {
                    const e = t % 3 * 2 / 3 - 1
                      , n = t > 2 ? 0 : -1
                      , i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                    g.set(i, p * d * t),
                    v.set(h, f * d * t);
                    const r = [t, t, t, t, t, t];
                    y.set(r, m * d * t)
                }
                const x = new zn;
                x.setAttribute("position", new Sn(g,p)),
                x.setAttribute("uv", new Sn(v,f)),
                x.setAttribute("faceIndex", new Sn(y,m)),
                t.push(x),
                i > 4 && i--
            }
            return {
                _lodPlanes: t,
                _sizeLods: e,
                _sigmas: n
            }
        }
        Go.create = function(t, e) {
            return console.log("THREE.Curve.create() has been deprecated"),
            t.prototype = Object.create(Go.prototype),
            t.prototype.constructor = t,
            t.prototype.getPoint = e,
            t
        }
        ,
        ll.prototype.fromPoints = function(t) {
            return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
            this.setFromPoints(t)
        }
        ,
        class extends _a {
            constructor(t=10, e=10, n=4473924, i=8947848) {
                n = new _n(n),
                i = new _n(i);
                const r = e / 2
                  , s = t / e
                  , a = t / 2
                  , o = []
                  , l = [];
                for (let t = 0, c = 0, h = -a; t <= e; t++,
                h += s) {
                    o.push(-a, 0, h, a, 0, h),
                    o.push(h, 0, -a, h, 0, a);
                    const e = t === r ? n : i;
                    e.toArray(l, c),
                    c += 3,
                    e.toArray(l, c),
                    c += 3,
                    e.toArray(l, c),
                    c += 3,
                    e.toArray(l, c),
                    c += 3
                }
                const c = new zn;
                c.setAttribute("position", new Ln(o,3)),
                c.setAttribute("color", new Ln(l,3));
                super(c, new ua({
                    vertexColors: !0,
                    toneMapped: !1
                })),
                this.type = "GridHelper"
            }
        }
        .prototype.setColors = function() {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }
        ,
        class extends _a {
            constructor(t) {
                const e = function t(e) {
                    const n = [];
                    e && e.isBone && n.push(e);
                    for (let i = 0; i < e.children.length; i++)
                        n.push.apply(n, t(e.children[i]));
                    return n
                }(t)
                  , n = new zn
                  , i = []
                  , r = []
                  , s = new _n(0,0,1)
                  , a = new _n(0,1,0);
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    n.parent && n.parent.isBone && (i.push(0, 0, 0),
                    i.push(0, 0, 0),
                    r.push(s.r, s.g, s.b),
                    r.push(a.r, a.g, a.b))
                }
                n.setAttribute("position", new Ln(i,3)),
                n.setAttribute("color", new Ln(r,3));
                super(n, new ua({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                })),
                this.type = "SkeletonHelper",
                this.isSkeletonHelper = !0,
                this.root = t,
                this.bones = e,
                this.matrix = t.matrixWorld,
                this.matrixAutoUpdate = !1
            }
            updateMatrixWorld(t) {
                const e = this.bones
                  , n = this.geometry
                  , i = n.getAttribute("position");
                rc.copy(this.root.matrixWorld).invert();
                for (let t = 0, n = 0; t < e.length; t++) {
                    const r = e[t];
                    r.parent && r.parent.isBone && (ic.multiplyMatrices(rc, r.matrixWorld),
                    nc.setFromMatrixPosition(ic),
                    i.setXYZ(n, nc.x, nc.y, nc.z),
                    ic.multiplyMatrices(rc, r.parent.matrixWorld),
                    nc.setFromMatrixPosition(ic),
                    i.setXYZ(n + 1, nc.x, nc.y, nc.z),
                    n += 2)
                }
                n.getAttribute("position").needsUpdate = !0,
                super.updateMatrixWorld(t)
            }
        }
        .prototype.update = function() {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }
        ,
        zo.prototype.extractUrlBase = function(t) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
            Pl.extractUrlBase(t)
        }
        ,
        zo.Handlers = {
            add: function() {
                console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
            },
            get: function() {
                console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
            }
        },
        Ql.prototype.center = function(t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
            this.getCenter(t)
        }
        ,
        Ql.prototype.empty = function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        }
        ,
        Ql.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        }
        ,
        Ql.prototype.size = function(t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(t)
        }
        ,
        Jt.prototype.center = function(t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
            this.getCenter(t)
        }
        ,
        Jt.prototype.empty = function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        }
        ,
        Jt.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        }
        ,
        Jt.prototype.isIntersectionSphere = function(t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(t)
        }
        ,
        Jt.prototype.size = function(t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(t)
        }
        ,
        me.prototype.empty = function() {
            return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        }
        ,
        mi.prototype.setFromMatrix = function(t) {
            return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),
            this.setFromProjectionMatrix(t)
        }
        ,
        class {
            constructor(t=new Xt, e=new Xt) {
                this.start = t,
                this.end = e
            }
            set(t, e) {
                return this.start.copy(t),
                this.end.copy(e),
                this
            }
            copy(t) {
                return this.start.copy(t.start),
                this.end.copy(t.end),
                this
            }
            getCenter(t) {
                return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"),
                t = new Xt),
                t.addVectors(this.start, this.end).multiplyScalar(.5)
            }
            delta(t) {
                return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"),
                t = new Xt),
                t.subVectors(this.end, this.start)
            }
            distanceSq() {
                return this.start.distanceToSquared(this.end)
            }
            distance() {
                return this.start.distanceTo(this.end)
            }
            at(t, e) {
                return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"),
                e = new Xt),
                this.delta(e).multiplyScalar(t).add(this.start)
            }
            closestPointToPointParameter(t, e) {
                tc.subVectors(t, this.start),
                ec.subVectors(this.end, this.start);
                const n = ec.dot(ec);
                let i = ec.dot(tc) / n;
                return e && (i = Rt(i, 0, 1)),
                i
            }
            closestPointToPoint(t, e, n) {
                const i = this.closestPointToPointParameter(t, e);
                return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"),
                n = new Xt),
                this.delta(n).multiplyScalar(i).add(this.start)
            }
            applyMatrix4(t) {
                return this.start.applyMatrix4(t),
                this.end.applyMatrix4(t),
                this
            }
            equals(t) {
                return t.start.equals(this.start) && t.end.equals(this.end)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        .prototype.center = function(t) {
            return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
            this.getCenter(t)
        }
        ,
        kt.prototype.flattenToArrayOffset = function(t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(t, e)
        }
        ,
        kt.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
            t.applyMatrix3(this)
        }
        ,
        kt.prototype.multiplyVector3Array = function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        }
        ,
        kt.prototype.applyToBufferAttribute = function(t) {
            return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),
            t.applyMatrix3(this)
        }
        ,
        kt.prototype.applyToVector3Array = function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
        ,
        kt.prototype.getInverse = function(t) {
            return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
            this.copy(t).invert()
        }
        ,
        Se.prototype.extractPosition = function(t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
            this.copyPosition(t)
        }
        ,
        Se.prototype.flattenToArrayOffset = function(t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(t, e)
        }
        ,
        Se.prototype.getPosition = function() {
            return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
            (new Xt).setFromMatrixColumn(this, 3)
        }
        ,
        Se.prototype.setRotationFromQuaternion = function(t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
            this.makeRotationFromQuaternion(t)
        }
        ,
        Se.prototype.multiplyToArray = function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        }
        ,
        Se.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        }
        ,
        Se.prototype.multiplyVector4 = function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        }
        ,
        Se.prototype.multiplyVector3Array = function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        }
        ,
        Se.prototype.rotateAxis = function(t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
            t.transformDirection(this)
        }
        ,
        Se.prototype.crossVector = function(t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        }
        ,
        Se.prototype.translate = function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        }
        ,
        Se.prototype.rotateX = function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        }
        ,
        Se.prototype.rotateY = function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        }
        ,
        Se.prototype.rotateZ = function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        }
        ,
        Se.prototype.rotateByAxis = function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        }
        ,
        Se.prototype.applyToBufferAttribute = function(t) {
            return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        }
        ,
        Se.prototype.applyToVector3Array = function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        }
        ,
        Se.prototype.makeFrustum = function(t, e, n, i, r, s) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
            this.makePerspective(t, e, i, n, r, s)
        }
        ,
        Se.prototype.getInverse = function(t) {
            return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
            this.copy(t).invert()
        }
        ,
        Qe.prototype.isIntersectionLine = function(t) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
            this.intersectsLine(t)
        }
        ,
        qt.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
            t.applyQuaternion(this)
        }
        ,
        qt.prototype.inverse = function() {
            return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
            this.invert()
        }
        ,
        Me.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        }
        ,
        Me.prototype.isIntersectionPlane = function(t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
            this.intersectsPlane(t)
        }
        ,
        Me.prototype.isIntersectionSphere = function(t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(t)
        }
        ,
        un.prototype.area = function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
            this.getArea()
        }
        ,
        un.prototype.barycoordFromPoint = function(t, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            this.getBarycoord(t, e)
        }
        ,
        un.prototype.midpoint = function(t) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
            this.getMidpoint(t)
        }
        ,
        un.prototypenormal = function(t) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            this.getNormal(t)
        }
        ,
        un.prototype.plane = function(t) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
            this.getPlane(t)
        }
        ,
        un.barycoordFromPoint = function(t, e, n, i, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            un.getBarycoord(t, e, n, i, r)
        }
        ,
        un.normal = function(t, e, n, i) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            un.getNormal(t, e, n, i)
        }
        ,
        cl.prototype.extractAllPoints = function(t) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
            this.extractPoints(t)
        }
        ,
        cl.prototype.extrude = function(t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
            new ro(this,t)
        }
        ,
        cl.prototype.makeGeometry = function(t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
            new ao(this,t)
        }
        ,
        Bt.prototype.fromAttribute = function(t, e, n) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        }
        ,
        Bt.prototype.distanceToManhattan = function(t) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(t)
        }
        ,
        Bt.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
        ,
        Xt.prototype.setEulerFromRotationMatrix = function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        }
        ,
        Xt.prototype.setEulerFromQuaternion = function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        }
        ,
        Xt.prototype.getPositionFromMatrix = function(t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
            this.setFromMatrixPosition(t)
        }
        ,
        Xt.prototype.getScaleFromMatrix = function(t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
            this.setFromMatrixScale(t)
        }
        ,
        Xt.prototype.getColumnFromMatrix = function(t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
            this.setFromMatrixColumn(e, t)
        }
        ,
        Xt.prototype.applyProjection = function(t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
            this.applyMatrix4(t)
        }
        ,
        Xt.prototype.fromAttribute = function(t, e, n) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        }
        ,
        Xt.prototype.distanceToManhattan = function(t) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(t)
        }
        ,
        Xt.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
        ,
        Wt.prototype.fromAttribute = function(t, e, n) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        }
        ,
        Wt.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
        ,
        Ze.prototype.getChildByName = function(t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
            this.getObjectByName(t)
        }
        ,
        Ze.prototype.renderDepth = function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        }
        ,
        Ze.prototype.translate = function(t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
            this.translateOnAxis(e, t)
        }
        ,
        Ze.prototype.getWorldRotation = function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
        ,
        Ze.prototype.applyMatrix = function(t) {
            return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),
            this.applyMatrix4(t)
        }
        ,
        Object.defineProperties(Ze.prototype, {
            eulerOrder: {
                get: function() {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                    this.rotation.order
                },
                set: function(t) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                    this.rotation.order = t
                }
            },
            useQuaternion: {
                get: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }),
        ti.prototype.setDrawMode = function() {
            console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
        ,
        Object.defineProperties(ti.prototype, {
            drawMode: {
                get: function() {
                    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),
                    0
                },
                set: function() {
                    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }
            }
        }),
        ra.prototype.initBones = function() {
            console.error("THREE.SkinnedMesh: initBones() has been removed.")
        }
        ,
        li.prototype.setLens = function(t, e) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
            void 0 !== e && (this.filmGauge = e),
            this.setFocalLength(t)
        }
        ,
        Object.defineProperties(hl.prototype, {
            onlyShadow: {
                set: function() {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                    this.shadow.camera.fov = t
                }
            },
            shadowCameraLeft: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                    this.shadow.camera.left = t
                }
            },
            shadowCameraRight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                    this.shadow.camera.right = t
                }
            },
            shadowCameraTop: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                    this.shadow.camera.top = t
                }
            },
            shadowCameraBottom: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                    this.shadow.camera.bottom = t
                }
            },
            shadowCameraNear: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                    this.shadow.camera.near = t
                }
            },
            shadowCameraFar: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                    this.shadow.camera.far = t
                }
            },
            shadowCameraVisible: {
                set: function() {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                    this.shadow.bias = t
                }
            },
            shadowDarkness: {
                set: function() {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                    this.shadow.mapSize.width = t
                }
            },
            shadowMapHeight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                    this.shadow.mapSize.height = t
                }
            }
        }),
        Object.defineProperties(Sn.prototype, {
            length: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                    this.array.length
                }
            },
            dynamic: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                    35048 === this.usage
                },
                set: function() {
                    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                    this.setUsage(35048)
                }
            }
        }),
        Sn.prototype.setDynamic = function(t) {
            return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
            this.setUsage(!0 === t ? 35048 : 35044),
            this
        }
        ,
        Sn.prototype.copyIndicesArray = function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
        ,
        Sn.prototype.setArray = function() {
            console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
        ,
        zn.prototype.addIndex = function(t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
            this.setIndex(t)
        }
        ,
        zn.prototype.addAttribute = function(t, e) {
            return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
            e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
            this.setIndex(e),
            this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
            this.setAttribute(t, new Sn(arguments[1],arguments[2])))
        }
        ,
        zn.prototype.addDrawCall = function(t, e, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
            this.addGroup(t, e)
        }
        ,
        zn.prototype.clearDrawCalls = function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
            this.clearGroups()
        }
        ,
        zn.prototype.computeOffsets = function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
        ,
        zn.prototype.removeAttribute = function(t) {
            return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
            this.deleteAttribute(t)
        }
        ,
        zn.prototype.applyMatrix = function(t) {
            return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),
            this.applyMatrix4(t)
        }
        ,
        Object.defineProperties(zn.prototype, {
            drawcalls: {
                get: function() {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                    this.groups
                }
            },
            offsets: {
                get: function() {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                    this.groups
                }
            }
        }),
        Ns.prototype.setDynamic = function(t) {
            return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
            this.setUsage(!0 === t ? 35048 : 35044),
            this
        }
        ,
        Ns.prototype.setArray = function() {
            console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
        ,
        ro.prototype.getArrays = function() {
            console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
        }
        ,
        ro.prototype.addShapeList = function() {
            console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
        }
        ,
        ro.prototype.addShape = function() {
            console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
        }
        ,
        Ds.prototype.dispose = function() {
            console.error("THREE.Scene: .dispose() has been removed.")
        }
        ,
        $l.prototype.onUpdate = function() {
            return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
            this
        }
        ,
        Object.defineProperties(pn.prototype, {
            wrapAround: {
                get: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            },
            overdraw: {
                get: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }
            },
            wrapRGB: {
                get: function() {
                    return console.warn("THREE.Material: .wrapRGB has been removed."),
                    new _n
                }
            },
            shading: {
                get: function() {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                    this.flatShading = 1 === t
                }
            },
            stencilMask: {
                get: function() {
                    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                    this.stencilFuncMask
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                    this.stencilFuncMask = t
                }
            }
        }),
        Object.defineProperties(ai.prototype, {
            derivatives: {
                get: function() {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                    this.extensions.derivatives
                },
                set: function(t) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                    this.extensions.derivatives = t
                }
            }
        }),
        Ps.prototype.clearTarget = function(t, e, n, i) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
            this.setRenderTarget(t),
            this.clear(e, n, i)
        }
        ,
        Ps.prototype.animate = function(t) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
            this.setAnimationLoop(t)
        }
        ,
        Ps.prototype.getCurrentRenderTarget = function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
            this.getRenderTarget()
        }
        ,
        Ps.prototype.getMaxAnisotropy = function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
            this.capabilities.getMaxAnisotropy()
        }
        ,
        Ps.prototype.getPrecision = function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
            this.capabilities.precision
        }
        ,
        Ps.prototype.resetGLState = function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
            this.state.reset()
        }
        ,
        Ps.prototype.supportsFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
            this.extensions.get("OES_texture_float")
        }
        ,
        Ps.prototype.supportsHalfFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
            this.extensions.get("OES_texture_half_float")
        }
        ,
        Ps.prototype.supportsStandardDerivatives = function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
            this.extensions.get("OES_standard_derivatives")
        }
        ,
        Ps.prototype.supportsCompressedTextureS3TC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
        }
        ,
        Ps.prototype.supportsCompressedTexturePVRTC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
        }
        ,
        Ps.prototype.supportsBlendMinMax = function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
            this.extensions.get("EXT_blend_minmax")
        }
        ,
        Ps.prototype.supportsVertexTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
            this.capabilities.vertexTextures
        }
        ,
        Ps.prototype.supportsInstancedArrays = function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
            this.extensions.get("ANGLE_instanced_arrays")
        }
        ,
        Ps.prototype.enableScissorTest = function(t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
            this.setScissorTest(t)
        }
        ,
        Ps.prototype.initMaterial = function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        }
        ,
        Ps.prototype.addPrePlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        }
        ,
        Ps.prototype.addPostPlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        }
        ,
        Ps.prototype.updateShadowMap = function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }
        ,
        Ps.prototype.setFaceCulling = function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }
        ,
        Ps.prototype.allocTextureUnit = function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        }
        ,
        Ps.prototype.setTexture = function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        }
        ,
        Ps.prototype.setTexture2D = function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        }
        ,
        Ps.prototype.setTextureCube = function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        }
        ,
        Ps.prototype.getActiveMipMapLevel = function() {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
            this.getActiveMipmapLevel()
        }
        ,
        Object.defineProperties(Ps.prototype, {
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                    this.shadowMap.enabled = t
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                    this.shadowMap.type = t
                }
            },
            shadowMapCullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            context: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
                    this.getContext()
                }
            },
            vr: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
                    this.xr
                }
            },
            gammaInput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),
                    !1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                }
            },
            gammaOutput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                    !1
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                    this.outputEncoding = !0 === t ? 3001 : 3e3
                }
            },
            toneMappingWhitePoint: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),
                    1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                }
            }
        }),
        Object.defineProperties(_s.prototype, {
            cullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            renderReverseSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }
            },
            renderSingleSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }
            }
        }),
        Object.defineProperties(jt.prototype, {
            wrapS: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                    this.texture.wrapS
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                    this.texture.wrapS = t
                }
            },
            wrapT: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                    this.texture.wrapT
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                    this.texture.wrapT = t
                }
            },
            magFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                    this.texture.magFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                    this.texture.magFilter = t
                }
            },
            minFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                    this.texture.minFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                    this.texture.minFilter = t
                }
            },
            anisotropy: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                    this.texture.anisotropy
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                    this.texture.anisotropy = t
                }
            },
            offset: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                    this.texture.offset
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                    this.texture.offset = t
                }
            },
            repeat: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                    this.texture.repeat
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                    this.texture.repeat = t
                }
            },
            format: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                    this.texture.format
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                    this.texture.format = t
                }
            },
            type: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                    this.texture.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                    this.texture.type = t
                }
            },
            generateMipmaps: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                    this.texture.generateMipmaps
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                    this.texture.generateMipmaps = t
                }
            }
        }),
        Fl.prototype.load = function(t) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            const e = this;
            return (new kl).load(t, (function(t) {
                e.setBuffer(t)
            }
            )),
            this
        }
        ,
        class {
            constructor(t, e=2048) {
                this.analyser = t.context.createAnalyser(),
                this.analyser.fftSize = e,
                this.data = new Uint8Array(this.analyser.frequencyBinCount),
                t.getOutput().connect(this.analyser)
            }
            getFrequencyData() {
                return this.analyser.getByteFrequencyData(this.data),
                this.data
            }
            getAverageFrequency() {
                let t = 0;
                const e = this.getFrequencyData();
                for (let n = 0; n < e.length; n++)
                    t += e[n];
                return t / e.length
            }
        }
        .prototype.getData = function() {
            return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
            this.getFrequencyData()
        }
        ,
        ci.prototype.updateCubeMap = function(t, e) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
            this.update(t, e)
        }
        ,
        ci.prototype.clear = function(t, e, n, i) {
            return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
            this.renderTarget.clear(t, e, n, i)
        }
        ,
        Ht.crossOrigin = void 0,
        Ht.loadTexture = function(t, e, n, i) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            const r = new Uo;
            r.setCrossOrigin(this.crossOrigin);
            const s = r.load(t, n, void 0, i);
            return e && (s.mapping = e),
            s
        }
        ,
        Ht.loadTextureCube = function(t, e, n, i) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            const r = new Ho;
            r.setCrossOrigin(this.crossOrigin);
            const s = r.load(t, n, void 0, i);
            return e && (s.mapping = e),
            s
        }
        ,
        Ht.loadCompressedTexture = function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        }
        ,
        Ht.loadCompressedTextureCube = function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        }
        ;
        function pc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
            detail: {
                revision: "128"
            }
        })),
        "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "128");
        var fc = function() {
            function t() {
                !function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }(this, t),
                this.mesh = null,
                this.spreadSpeed = .5,
                this.fadeSpeed = .05
            }
            var e, n, i;
            return e = t,
            (n = [{
                key: "init",
                value: function(t, e) {
                    this.mesh = t,
                    this.mesh.position.x = e.x,
                    this.mesh.position.y = e.y;
                    var n = 360 * Math.random();
                    this.mesh.rotation.z = n
                }
            }, {
                key: "update",
                value: function() {
                    this.mesh.scale.x += this.spreadSpeed,
                    this.mesh.scale.y += this.spreadSpeed,
                    this.mesh.material.opacity -= this.fadeSpeed
                }
            }]) && pc(e.prototype, n),
            i && pc(e, i),
            t
        }();
        function mc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        var gc = function(t) {
            var e = Math.random() * (t.w / 2 - t.w / 2 * .6) + t.w / 2 * .6
              , n = Math.random() - .5;
            return e * (n / Math.abs(n))
        }
          , vc = function() {
            function t() {
                !function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }(this, t),
                this.mesh = null,
                this.upSpeed = 0,
                this.flowAmp = 0,
                this.flowFreq = 0,
                this.speedRatio = 1,
                this.selfTime = 0
            }
            var e, n, i;
            return e = t,
            (n = [{
                key: "init",
                value: function(t, e) {
                    this.mesh = t,
                    this.initTransform(e),
                    this.upSpeed = .4 * Math.random() + .9,
                    this.flowAmp = .4 * Math.random() + .4,
                    this.flowFreq = Math.random() * (.03 - .005) + .005,
                    this.selfTime = 10 * Math.random()
                }
            }, {
                key: "initTransform",
                value: function(t) {
                    var e = gc(t)
                      , n = Math.random() * t.h - t.h / 2;
                    if (this.mesh.position.set(e, n, 0),
                    t.w > window.BREAKPOINT) {
                        var i = window.innerWidth / 1280;
                        i = Math.min(i, 1.12),
                        this.mesh.scale.x = i,
                        this.mesh.scale.y = i,
                        this.speedRatio = 1
                    } else
                        this.mesh.scale.x = .65,
                        this.mesh.scale.y = .65,
                        this.speedRatio = .65
                }
            }, {
                key: "update",
                value: function(t, e) {
                    this.mesh.position.y += this.upSpeed,
                    this.mesh.position.x += this.flowAmp * Math.cos(this.flowFreq * e + this.selfTime),
                    this.mesh.position.y > t.h / 2 + 100 && (this.mesh.position.y = -t.h / 2 - 100,
                    this.mesh.position.x = gc(t),
                    this.flowAmp = .4 * Math.random() - .4,
                    this.flowFreq = Math.random() * (.03 - .005) - .005)
                }
            }]) && mc(e.prototype, n),
            i && mc(e, i),
            t
        }();
        function yc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        var xc = Math.PI / 180 * 22.5
          , _c = new Uo
          , wc = function() {
            function t() {
                !function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }(this, t),
                this.$canvas = null,
                this.canvasSize = {
                    w: 0,
                    h: 0
                },
                this.prevWindowWidth = 0,
                this.renderer = null,
                this.scene = null,
                this.camera = null,
                this.ripples = [],
                this.rippleGeometry = null,
                this.rippleMaterial = null,
                this.rippleTexture = null,
                this.rippleMesh = null,
                this.bubblesNum = 15,
                this.bubbles = [],
                this.bubbleGroup = null,
                this.bubbleTextureNum = 4,
                this.bubbleGeometrySize = 72,
                this.bubbleMaterialList = [],
                this.background = null,
                this.animationTime = 0
            }
            var e, n, i;
            return e = t,
            (n = [{
                key: "init",
                value: function() {
                    this.$canvas = document.querySelector(".js-fixed-canvas"),
                    this.canvasSize = {
                        w: window.innerWidth,
                        h: window.innerHeight
                    },
                    this.renderer = new Ps({
                        canvas: this.$canvas,
                        alpha: !0
                    }),
                    this.renderer.setPixelRatio(window.devicePixelRatio),
                    this.renderer.setSize(this.canvasSize.w, this.canvasSize.h),
                    this.scene = new Ds;
                    var t = this.canvasSize.h / 2 / Math.tan(xc);
                    this.camera = new li(45,this.canvasSize.w / this.canvasSize.h,.1,1e4),
                    this.camera.position.z = t,
                    this.rippleTexture = _c.load(this.$canvas.getAttribute("data-image-url-ripple")),
                    this.rippleGeometry = new yi(10,10),
                    this.createBubbles(),
                    this.prevWindowWidth = window.innerWidth
                }
            }, {
                key: "createRipple",
                value: function(t) {
                    var e = this;
                    t.x = t.x - this.canvasSize.w / 2,
                    t.y = -(t.y - this.canvasSize.h / 2);
                    var n = new wn({
                        map: this.rippleTexture,
                        opacity: 3,
                        color: 16777215,
                        transparent: !0
                    })
                      , i = new ti(this.rippleGeometry,n)
                      , r = new fc;
                    r.init(i, t),
                    this.scene.add(r.mesh),
                    this.ripples.push(r),
                    setTimeout((function() {
                        i.geometry.dispose(),
                        n.dispose(),
                        i.material.dispose(),
                        e.scene.remove(i),
                        e.ripples.shift()
                    }
                    ), 3e3)
                }
            }, {
                key: "createBubbles",
                value: function() {
                    for (var t = new yi(this.bubbleGeometrySize,this.bubbleGeometrySize,1,1), e = 0; e < this.bubbleTextureNum; e++) {
                        var n = e + 1
                          , i = _c.load(this.$canvas.getAttribute("data-image-url-0".concat(n)))
                          , r = new wn({
                            map: i,
                            transparent: !0,
                            alphaTest: .9
                        });
                        this.bubbleMaterialList.push(r)
                    }
                    this.bubbleGroup = new Ts;
                    for (var s = 0; s < this.bubblesNum; s++) {
                        var a = new ti(t,this.bubbleMaterialList[s % 4]);
                        this.bubbles[s] = new vc,
                        this.bubbles[s].init(a, this.canvasSize),
                        this.bubbleGroup.add(this.bubbles[s].mesh)
                    }
                    this.scene.add(this.bubbleGroup),
                    gsap.fromTo(this.bubbleGroup.position, {
                        y: -2e3
                    }, {
                        y: 0,
                        duration: .8,
                        ease: "power2.out",
                        scrollTrigger: {
                            trigger: ".js-index-mv",
                            toggleActions: "play none reverse none",
                            start: "bottom top",
                            end: "bottom top"
                        }
                    }),
                    gsap.fromTo(this.bubbleGroup.position, {
                        y: 0
                    }, {
                        y: 2e3,
                        duration: .8,
                        ease: "power2.in",
                        scrollTrigger: {
                            trigger: ".js-bg-color-change-clear",
                            toggleActions: "play none reverse none",
                            start: "top bottom",
                            end: "top bottom"
                        }
                    }),
                    gsap.set(this.bubbleGroup.position, {
                        y: -2e3
                    })
                }
            }, {
                key: "loop",
                value: function() {
                    var t = !0
                      , e = !1
                      , n = void 0;
                    try {
                        for (var i, r = this.ripples[Symbol.iterator](); !(t = (i = r.next()).done); t = !0)
                            i.value.update()
                    } catch (t) {
                        e = !0,
                        n = t
                    } finally {
                        try {
                            t || null == r.return || r.return()
                        } finally {
                            if (e)
                                throw n
                        }
                    }
                    var s = !0
                      , a = !1
                      , o = void 0;
                    try {
                        for (var l, c = this.bubbles[Symbol.iterator](); !(s = (l = c.next()).done); s = !0)
                            l.value.update(this.canvasSize, this.animationTime)
                    } catch (t) {
                        a = !0,
                        o = t
                    } finally {
                        try {
                            s || null == c.return || c.return()
                        } finally {
                            if (a)
                                throw o
                        }
                    }
                    this.renderer.render(this.scene, this.camera),
                    this.animationTime++
                }
            }, {
                key: "resize",
                value: function() {
                    this.canvasSize.w = window.innerWidth,
                    this.canvasSize.h = window.innerHeight,
                    this.renderer.setPixelRatio(window.devicePixelRatio),
                    this.renderer.setSize(this.canvasSize.w, this.canvasSize.h);
                    var t = this.canvasSize.h / 2 / Math.tan(xc);
                    if (this.camera.position.z = t,
                    this.camera.aspect = this.canvasSize.w / this.canvasSize.h,
                    this.camera.updateProjectionMatrix(),
                    window.innerWidth > window.BREAKPOINT || window.innerWidth !== this.prevWindowWidth) {
                        var e = !0
                          , n = !1
                          , i = void 0;
                        try {
                            for (var r, s = this.bubbles[Symbol.iterator](); !(e = (r = s.next()).done); e = !0)
                                r.value.initTransform(this.canvasSize)
                        } catch (t) {
                            n = !0,
                            i = t
                        } finally {
                            try {
                                e || null == s.return || s.return()
                            } finally {
                                if (n)
                                    throw i
                            }
                        }
                    }
                    this.prevWindowWidth = window.innerWidth
                }
            }]) && yc(e.prototype, n),
            i && yc(e, i),
            t
        }()
          , bc = (n("0mN4"),
        n("vX6Q"))
          , Mc = n.n(bc);
        function Sc(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        var Tc = new (function() {
            function t() {
                !function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }(this, t),
                this.body = document.querySelector("body"),
                this.currentScrollTop = 0,
                this.modalFlag = !1
            }
            var e, n, i;
            return e = t,
            (n = [{
                key: "fixed",
                value: function(t) {
                    t && (this.currentScrollTop = window.pageYOffset,
                    this.body.style.position = "fixed",
                    this.body.style.top = "".concat(-1 * this.currentScrollTop, "px"),
                    this.body.style.left = "0",
                    this.body.style.width = "100%"),
                    t || (this.body.style.position = "",
                    this.body.style.top = "",
                    this.body.style.left = "",
                    this.body.style.width = "",
                    window.scrollTo(0, this.currentScrollTop))
                }
            }, {
                key: "toggleModalFlag",
                value: function() {
                    this.modalFlag = !this.modalFlag
                }
            }]) && Sc(e.prototype, n),
            i && Sc(e, i),
            t
        }())
          , Ec = n("cRqm");
        function Lc(t) {
            return function(t) {
                if (Array.isArray(t)) {
                    for (var e = 0, n = new Array(t.length); e < t.length; e++)
                        n[e] = t[e];
                    return n
                }
            }(t) || function(t) {
                if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t))
                    return Array.from(t)
            }(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance")
            }()
        }
        function Ac(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        var Cc, Pc = {
            x: 0,
            y: 0
        }, Rc = {
            x: 0,
            y: 0
        }, Ic = {
            x: 0,
            y: 0
        }, Dc = null, Nc = 0, Oc = null;
        new (function() {
            function t() {
                var e = this;
                !function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }(this, t),
                sessionStorage.getItem("visited") ? (this.$op = document.querySelector(".js-index-opening"),
                Tc.fixed(!1),
                this.onVisitOpening()) : (this.$op = document.querySelector(".js-index-opening"),
                this.$titles = Lc(document.querySelectorAll(".js-index-opening__title")),
                Tc.fixed(!0),
                this.tl = gsap.timeline(),
                this.images = document.querySelectorAll(".js-load-first"),
                this.imagesLoaded = Mc()(this.images),
                this.imagesLoaded.on("done", (function() {
                    e.onNotVisitOpening()
                }
                ))),
                new Ec.a
            }
            var e, n, i;
            return e = t,
            (n = [{
                key: "onNotVisitOpening",
                value: function() {
                    var t = this;
                    this.tl.to(this.$op, {
                        duration: 1e-5,
                        ease: "none",
                        backgroundColor: "#88ddcf",
                        onComplete: function() {
                            var e = !0
                              , n = !1
                              , i = void 0;
                            try {
                                for (var r, s = t.$titles[Symbol.iterator](); !(e = (r = s.next()).done); e = !0)
                                    r.value.classList.add("is-active")
                            } catch (t) {
                                n = !0,
                                i = t
                            } finally {
                                try {
                                    e || null == s.return || s.return()
                                } finally {
                                    if (n)
                                        throw i
                                }
                            }
                        }
                    }).to(this.$op, {
                        duration: 1.4,
                        delay: 2,
                        ease: "power1.out",
                        opacity: 0
                    }),
                    this.tl.eventCallback("onComplete", (function() {
                        t.$op.remove(),
                        Tc.fixed(!1)
                    }
                    ))
                }
            }, {
                key: "onVisitOpening",
                value: function() {
                    var t = this;
                    gsap.to(this.$op, {
                        duration: .3,
                        ease: "power1.out",
                        opacity: 0,
                        onComplete: function() {
                            t.$op.remove()
                        }
                    })
                }
            }]) && Ac(e.prototype, n),
            i && Ac(e, i),
            t
        }()),
        function() {
            bt = document.querySelector(".js-index-mv"),
            Mt = wt(document.querySelectorAll(".js-index-mv__images-item"));
            for (var t = 0; t < Mt.length; t++)
                St[t] = new yt,
                St[t].init(Mt[t]);
            if (_t.isSafari()) {
                bt.classList.add("is-safari");
                var e = !0
                  , n = !1
                  , i = void 0;
                try {
                    for (var r, s = Mt[Symbol.iterator](); !(e = (r = s.next()).done); e = !0) {
                        var a = r.value.querySelector("img")
                          , o = a.getAttribute("data-png");
                        a.setAttribute("src", o)
                    }
                } catch (t) {
                    n = !0,
                    i = t
                } finally {
                    try {
                        e || null == s.return || s.return()
                    } finally {
                        if (n)
                            throw i
                    }
                }
            }
            new IntersectionObserver((function(t) {
                t.forEach((function(t) {
                    Tt = !!t.isIntersecting
                }
                ))
            }
            ),{
                rootMargin: "0px"
            }).observe(bt)
        }(),
        (Oc = new wc).init(),
        ot(),
        Object(r.a)(),
        function() {
            var t = document.querySelectorAll(".js-flip")
              , e = !0
              , n = !1
              , i = void 0;
            try {
                for (var r, s = t[Symbol.iterator](); !(e = (r = s.next()).done); e = !0) {
                    var a = r.value
                      , o = new ut;
                    o.init(a),
                    o.resize(),
                    ct.push(o)
                }
            } catch (t) {
                n = !0,
                i = t
            } finally {
                try {
                    e || null == s.return || s.return()
                } finally {
                    if (n)
                        throw i
                }
            }
            window.addEventListener("resize", (function() {
                ht = window.innerWidth < window.BREAKPOINT;
                var t = !0
                  , e = !1
                  , n = void 0;
                try {
                    for (var i, r = ct[Symbol.iterator](); !(t = (i = r.next()).done); t = !0)
                        i.value.resize()
                } catch (t) {
                    e = !0,
                    n = t
                } finally {
                    try {
                        t || null == r.return || r.return()
                    } finally {
                        if (e)
                            throw n
                    }
                }
            }
            ))
        }(),
        ft(),
        Object(i.a)(),
        Cc = document.body,
        gsap.fromTo(Cc, {
            backgroundColor: mt
        }, {
            backgroundColor: gt,
            ease: "power2.in",
            scrollTrigger: {
                trigger: ".js-bg-color-change-area",
                scrub: .3,
                start: "top bottom",
                end: "bottom bottom"
            }
        }),
        gsap.fromTo(Cc, {
            backgroundColor: gt
        }, {
            backgroundColor: mt,
            ease: "power2.out",
            scrollTrigger: {
                trigger: ".js-bg-color-change-clear",
                toggleActions: "play none reverse none",
                start: "top bottom",
                end: "top bottom"
            }
        }),
        gsap.set(Cc, {
            backgroundColor: mt
        }),
        document.addEventListener("mousemove", (function(t) {
            Pc.x = t.pageX,
            Pc.y = t.pageY,
            Rc.x = t.clientX,
            Rc.y = t.clientY;
            var e = Math.abs(t.movementX) < 1 ? 0 : t.movementX
              , n = Math.abs(t.movementY) < 1 ? 0 : t.movementY;
            Math.abs(e) > 100 && (e = e / Math.abs(e) * 100),
            Math.abs(n) > 100 && (n = n / Math.abs(n) * 100),
            Ic.x = e,
            Ic.y = n,
            Tt && window.innerWidth > window.BREAKPOINT && (Nc % 12 == 0 && Oc.createRipple(Rc),
            Nc++),
            Dc && clearTimeout(Dc),
            Dc = setTimeout((function() {
                Ic.x = 0,
                Ic.y = 0,
                Nc = 0
            }
            ), 50)
        }
        )),
        window.addEventListener("resize", (function() {
            !function() {
                for (var t = 0; t < St.length; t++)
                    St[t].resetPosition()
            }(),
            Oc.resize()
        }
        )),
        function t() {
            !function(t, e) {
                if (Tt)
                    for (var n = 0; n < St.length; n++)
                        St[n].loop(t, e)
            }(Pc, Ic),
            Oc.loop(),
            requestAnimationFrame(t)
        }()
    },
    zhAb: function(t, e, n) {
        var i = n("aagx")
          , r = n("aCFj")
          , s = n("w2a5")(!1)
          , a = n("YTvA")("IE_PROTO");
        t.exports = function(t, e) {
            var n, o = r(t), l = 0, c = [];
            for (n in o)
                n != a && i(o, n) && c.push(n);
            for (; e.length > l; )
                i(o, n = e[l++]) && (~s(c, n) || c.push(n));
            return c
        }
    }
});
